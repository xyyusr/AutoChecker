开始

========================================== Rule MethodNamingConventionsRule ===========================================
一共 12 个测试用例
正例 5 个
反例 7 个
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is an instance method.
3. Check whether the method is a static method.
4. Check whether the method is a native method.
5. Check whether the method is a JUnit method.
6. Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".
7. Check whether the method name matches the regex for static methods "[a-z][a-zA-Z0-9]*".
8. Check whether the method name matches the regex for native methods "[a-z][a-zA-Z0-9]*".
9. Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".
10. Check whether the method name matches the regex for JUnit 4 test methods "[a-z][a-zA-Z0-9]*".
11. Check whether the method name matches the regex for JUnit 5 test methods "[a-z][a-zA-Z0-9]*".

In this test case:
- The method name is "Bar".
- This method is an instance method (not static, not native, and not JUnit).
- The method name does not match the regex for instance methods "[a-z][a-zA-Z0-9]*".
- Therefore, there is 1 violation of the rule in this test case.
['Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the method is a static method.', 'Check whether the method is a native method.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for static methods "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for native methods "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 4 test methods "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 5 test methods "[a-z][a-zA-Z0-9]*".']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Check whether the method is a static method.* 匹配到的元操作或API：
logic: Check whether the method is a static method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.959594190120697
*Check whether the method is a native method.* 匹配到的元操作或API：
logic: Check whether the method is a native method.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9731003046035767
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for static methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test methods "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8242838978767395
*Check whether the method name matches the regex for JUnit 4 test methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test methods "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8176634311676025
*Check whether the method name matches the regex for JUnit 5 test methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test methods "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit5 method
cosine Similarity: 0.8242758512496948
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        boolean isJUnitTest = TestFrameworksUtil.isJUnitMethod(node);

        if (isJUnitTest) {
            if (!methodName.matches("^[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isStatic() || node.isNative()) {
            if (!methodName.matches("^[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else {
            if (!methodName.matches("^[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is an instance method.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
4. Check whether the method is a static method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
6. Check whether the method is a native method.
7. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
8. Check whether the method is a JUnit method.
9. Check whether the method name matches the regex for JUnit test method names ("test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3, "[a-z][a-zA-Z0-9]*" for JUnit 4 and JUnit 5).

Given the test case:
1. The method name is "Bar".
2. The method is an instance method.
3. The method name does not match the regex "[a-z][a-zA-Z0-9]*", as it starts with an uppercase character.
4. The method is not a static method.
5. The check for static method name is not applicable here.
6. The method is not a native method.
7. The check for native method name is not applicable here.
8. The method is not a JUnit method.
9. The check for JUnit method name is not applicable here.

Since the method name "Bar" does not match the regex "[a-z][a-zA-Z0-9]*" and it is an instance method, it violates the rule. The number of violations in this test case is 1.
['Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a static method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a native method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex for JUnit test method names ("test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3, "[a-z][a-zA-Z0-9]*" for JUnit 4 and JUnit 5).', 'The method name is "Bar".', 'The method is an instance method.', 'The method name does not match the regex "[a-z][a-zA-Z0-9]*", as it starts with an uppercase character.', 'The method is not a static method.', 'The check for static method name is not applicable here.', 'The method is not a native method.', 'The check for native method name is not applicable here.', 'The method is not a JUnit method.', 'The check for JUnit method name is not applicable here.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a static method.* 匹配到的元操作或API：
logic: Check whether the method is a static method.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.959594190120697
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a native method.* 匹配到的元操作或API：
logic: Check whether the method is a native method.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9731003046035767
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for JUnit test method names ("test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3, "[a-z][a-zA-Z0-9]*" for JUnit 4 and JUnit 5).* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name is "Bar".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is an instance method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name does not match the regex "[a-z][a-zA-Z0-9]*", as it starts with an uppercase character.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not a static method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The check for static method name is not applicable here.* 匹配到的元操作或API：
未匹配成功元操作或API
*The method is not a native method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The check for native method name is not applicable here.* 匹配到的元操作或API：
query: The check for native method name is not applicable here.
most similar API: Check whether the method is native
cosine Similarity: 0.807682454586029
*The method is not a JUnit method.* 匹配到的元操作或API：
未匹配成功元操作或API
*The check for JUnit method name is not applicable here.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isNative() || node.isStatic()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a junit method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
        If the method name does not match the regex "[a-z][a-zA-Z0-9]*" and it is not static, not native, and not a JUnit method, then this test case violates the rule.

Based on the provided test case:
1. Get the name of method. // Method name is "Bar"
2. Check whether the method is static. // Method is not static
3. Check whether the method is native. // Method is not native
4. Check whether the method is a junit method. // Method is not a JUnit method
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // Method name "Bar" does not match the regex

Therefore, the test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method. // Method name is "Bar"', 'Check whether the method is static. // Method is not static', 'Check whether the method is native. // Method is not native', 'Check whether the method is a junit method. // Method is not a JUnit method', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // Method name "Bar" does not match the regex']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // Method name is "Bar"* 匹配到的元操作或API：
logic: Get the name of method. // Method name is "Bar"
most similar meta operation: Get the name of method
cosine Similarity: 0.8762560486793518
*Check whether the method is static. // Method is not static* 匹配到的元操作或API：
logic: Check whether the method is static. // Method is not static
most similar meta operation: Check whether the method is static
cosine Similarity: 0.938136637210846
*Check whether the method is native. // Method is not native* 匹配到的元操作或API：
logic: Check whether the method is native. // Method is not native
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9610273241996765
*Check whether the method is a junit method. // Method is not a JUnit method* 匹配到的元操作或API：
logic: Check whether the method is a junit method. // Method is not a JUnit method
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9361914992332458
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // Method name "Bar" does not match the regex* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is an instance method.
3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For the given test case:
- 1. Get the name of method: Bar
- 2. Check whether the method is an instance method: Yes
- 3. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": No, because "Bar" starts with an uppercase character.

Since the method name does not match the regex for an instance method, this test case violates the rule. The number of violations is 1.
['Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
        2. Check whether the method is an instance method.
        3. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
        If the method name does not match the regex for instance method names, then this test case violates the rule.
        
Given the test case:
```java
public class Foo {
    void Bar() {}
}
```

4. Get the name of method.
        5. Check whether the method is an instance method.
        6. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
        In this test case, the method name is "Bar", which does not match the regex for instance method names "[a-z][a-zA-Z0-9]*". Thus, it violates the rule.
['Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is an instance method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is an instance method.* 匹配到的元操作或API：
query: Check whether the method is an instance method.
most similar API: Check whether is test method
cosine Similarity: 0.8555017709732056
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should start with lowercase character
public class Foo {
    void Bar() {}
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'Bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isTestMethod(node)) {
            if (!JUNIT45_TEST_METHOD_PATTERN.matcher(methodName).matches() && !JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
        2. Check whether the method is static.
        3. Check whether the method is a junit method.
        4. Check whether the method is native.
        5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
        If the method name does not match the regex "[a-z][a-zA-Z0-9]*" and it is not static or a JUnit method or a native method, then this test case violates the rule. 

In this specific test case:
1. Get the name of method. // bar_foo
        2. Check whether the method is static. // false
        3. Check whether the method is a junit method. // false
        4. Check whether the method is native. // false
        5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false, because it contains an underscore
        Therefore, the method `bar_foo` violates the rule.
            
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is a junit method.', 'Check whether the method is native.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method. // bar_foo', 'Check whether the method is static. // false', 'Check whether the method is a junit method. // false', 'Check whether the method is native. // false', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false, because it contains an underscore']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // bar_foo* 匹配到的元操作或API：
logic: Get the name of method. // bar_foo
most similar meta operation: Get the name of method
cosine Similarity: 0.8687623143196106
*Check whether the method is static. // false* 匹配到的元操作或API：
logic: Check whether the method is static. // false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9482631087303162
*Check whether the method is a junit method. // false* 匹配到的元操作或API：
logic: Check whether the method is a junit method. // false
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9505062699317932
*Check whether the method is native. // false* 匹配到的元操作或API：
logic: Check whether the method is native. // false
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9598884582519531
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false, because it contains an underscore* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (methodName.contains("_")) {
            if (TestFrameworksUtil.isJUnitMethod(node)) {
                if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            } else if (node.isNative()) {
                if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            } else if (node.isStatic()) {
                if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            } else {
                if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - If the method is static, check against the regex "[a-z][a-zA-Z0-9]*".
   - If the method is native, check against the regex "[a-z][a-zA-Z0-9]*".
   - If the method is a JUnit method, check against the appropriate JUnit method name regex.
   - If none of the above, check against the instance method name regex "[a-z][a-zA-Z0-9]*".

In this specific test case:
6. The method name is "bar_foo".
7. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
8. Since the method name contains an underscore, it does not match the instance method name regex "[a-z][a-zA-Z0-9]*", indicating a violation of the rule.

The number of violating the rule in this test case is: 1
The description of this test case is: bad 2
            
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'The method name is "bar_foo".', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Since the method name contains an underscore, it does not match the instance method name regex "[a-z][a-zA-Z0-9]*", indicating a violation of the rule.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*The method name is "bar_foo".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the method name contains an underscore, it does not match the instance method name regex "[a-z][a-zA-Z0-9]*", indicating a violation of the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_METHOD_PATTERN.matcher(methodName).matches() &&
                !JUNIT4_METHOD_PATTERN.matcher(methodName).matches() &&
                !JUNIT5_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a junit method.
5. Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".
6. Check whether the method name contains underscores.

Given the test case:

```java
public class Foo {
    void bar_foo() {}
}
```

The granular checks would be:

1. Get the name of method.
   - Result: bar_foo
2. Check whether the method is static.
   - Result: False
3. Check whether the method is native.
   - Result: False
4. Check whether the method is a junit method.
   - Result: False (assuming no JUnit annotations are present)
5. Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".
   - Result: False (because of the underscore)
6. Check whether the method name contains underscores.
   - Result: True

Since the method name `bar_foo` contains underscores and does not match the regex for instance methods, this test case violates the rule.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".', 'Check whether the method name contains underscores.', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".', 'Check whether the method name contains underscores.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name contains underscores.* 匹配到的元操作或API：
query: Check whether the method name contains underscores.
most similar API: Check whether the method has modifiers
cosine Similarity: 0.8104332685470581
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance methods "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name contains underscores.* 匹配到的元操作或API：
query: Check whether the method name contains underscores.
most similar API: Check whether the method has modifiers
cosine Similarity: 0.8104332685470581
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean hasModifiers(net.sourceforge.pmd.lang.java.ast.JModifier, [Lnet.sourceforge.pmd.lang.java.ast.JModifier;)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();

        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_METHOD_PATTERN.matcher(methodName).matches() && !JUNIT4_METHOD_PATTERN.matcher(methodName).matches() && !JUNIT5_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!NATIVE_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else if (node.isStatic()) {
            if (!INSTANCE_STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!INSTANCE_STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
        2. Check whether the method is abstract.
        3. Check whether the method is static.
        4. Check whether the method is final.
        5. Check whether the method is native.
        6. Check whether the method is a junit method.
        7. Get the signature of method.
        8. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For the provided test case:
1. Get the name of method. // bar_foo
2. Check whether the method is abstract. // False
3. Check whether the method is static. // False
4. Check whether the method is final. // False
5. Check whether the method is native. // False
6. Check whether the method is a junit method. // False
7. Get the signature of method. // void bar_foo()
8. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // False, because bar_foo contains an underscore

Since the method name `bar_foo` does not match the default Java naming convention regex for instance methods and is not a JUnit method, this test case violates the rule.
['Get the name of method.', 'Check whether the method is abstract.', 'Check whether the method is static.', 'Check whether the method is final.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method. // bar_foo', 'Check whether the method is abstract. // False', 'Check whether the method is static. // False', 'Check whether the method is final. // False', 'Check whether the method is native. // False', 'Check whether the method is a junit method. // False', 'Get the signature of method. // void bar_foo()', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // False, because bar_foo contains an underscore']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is final.* 匹配到的元操作或API：
logic: Check whether the method is final.
most similar meta operation: Check whether the method is final
cosine Similarity: 0.985183835029602
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // bar_foo* 匹配到的元操作或API：
logic: Get the name of method. // bar_foo
most similar meta operation: Get the name of method
cosine Similarity: 0.8687623143196106
*Check whether the method is abstract. // False* 匹配到的元操作或API：
logic: Check whether the method is abstract. // False
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9525656700134277
*Check whether the method is static. // False* 匹配到的元操作或API：
logic: Check whether the method is static. // False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9482631087303162
*Check whether the method is final. // False* 匹配到的元操作或API：
logic: Check whether the method is final. // False
most similar meta operation: Check whether the method is final
cosine Similarity: 0.9531562924385071
*Check whether the method is native. // False* 匹配到的元操作或API：
logic: Check whether the method is native. // False
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9598884582519531
*Check whether the method is a junit method. // False* 匹配到的元操作或API：
logic: Check whether the method is a junit method. // False
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9505062699317932
*Get the signature of method. // void bar_foo()* 匹配到的元操作或API：
logic: Get the signature of method. // void bar_foo()
most similar meta operation: Get the signature of method
cosine Similarity: 0.9081332087516785
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // False, because bar_foo contains an underscore* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isFinal()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!methodName.matches("test[A-Z0-9][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (node.isNative()) {
            if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
                addViolation(data, node);
            }
        } else if (!methodName.matches("[a-z][a-zA-Z0-9]*")) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of method.
2. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
3. Check whether the method is a JUnit method.
4. Check whether the method is static.
5. Check whether the method is native.

Since the method name is `bar_foo`, which contains an underscore, and it does not match the regex "[a-z][a-zA-Z0-9]*", the test case violates the rule. There is no need to further check if it is a JUnit method, static, or native because the name itself already violates the naming convention for instance methods.

The number of violating the rule in this test case is indeed 1.
['Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Check whether the method is a JUnit method.', 'Check whether the method is static.', 'Check whether the method is native.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// method names should not contain underscores
public class Foo {
    void bar_foo() {}
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar_foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        // JUnit 3 and 4 and 5 follow the same regex for test methods
        if (!TestFrameworksUtil.isJUnitMethod(node) && 
            !node.isNative() && 
            !node.isStatic() && 
            !methodName.matches("[a-z][a-zA-Z0-9]*")) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2
1233
939
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
To check if the test case adheres to the rule, let's perform the necessary granular checks on the method declarations in the class `Foo`.

1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".
4. Get the name of method.
5. Check whether the method is static.
6. Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".
7. Get the name of method.
8. Check whether the method is static.
9. Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*".
10. Get the name of method.
11. Check whether the method is static.
12. Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".

Let's apply these checks to the methods in the provided test case:

1. Get the name of method. (Method: `foo`)
2. Check whether the method is static. (Result: True)
3. Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "foo" matches the pattern)

4. Get the name of method. (Method: `st_whatever`)
5. Check whether the method is static. (Result: True)
6. Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "st_whatever" matches the pattern)

7. Get the name of method. (Method: `bar`)
8. Check whether the method is static. (Result: False)
9. Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*". (Result: True, as "bar" matches the pattern)

10. Since there is no JUnit 3, 4, or 5 test method in the provided test case, we do not need to check the JUnit method names.

From the above checks, we can conclude that the static method `foo` and `st_whatever` follow the naming convention for static methods, and the instance method `bar` follows the naming convention for instance methods.

However, since the provided description states that there is one violation in the test case, let's review the description again. It seems there might be a misunderstanding, as the provided test case does not contain any method names that violate the specified regex patterns. If the test case is meant to include a method name that does not follow the pattern, it should be included.

For example, if the test case were:
```java
class Foo {
    static void foo() {
    }

    static void St_whatever() { // Violation of static method naming convention
    }

    void bar() {
    }
}
```

Then the checks would be:
1. Get the name of method. (Method: `foo`)
2. Check whether the method is static. (Result: True)
3. Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "foo" matches the pattern)

4. Get the name of method. (Method: `St_whatever`)
5. Check whether the method is static. (Result: True)
6. Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: False, as "St_whatever" does not match the pattern due to the uppercase "S" at the beginning)

7. Get the name of method. (Method: `bar`)
8. Check whether the method is static. (Result: False)
9. Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*". (Result: True, as "bar" matches the pattern)

In this case, `St_whatever` would be the method that violates the rule, and the number of violations would be 1, as described.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method. (Method: `foo`)', 'Check whether the method is static. (Result: True)', 'Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "foo" matches the pattern)', 'Get the name of method. (Method: `st_whatever`)', 'Check whether the method is static. (Result: True)', 'Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "st_whatever" matches the pattern)', 'Get the name of method. (Method: `bar`)', 'Check whether the method is static. (Result: False)', 'Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*". (Result: True, as "bar" matches the pattern)', 'Since there is no JUnit 3, 4, or 5 test method in the provided test case, we do not need to check the JUnit method names.', 'Get the name of method. (Method: `foo`)', 'Check whether the method is static. (Result: True)', 'Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "foo" matches the pattern)', 'Get the name of method. (Method: `St_whatever`)', 'Check whether the method is static. (Result: True)', 'Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: False, as "St_whatever" does not match the pattern due to the uppercase "S" at the beginning)', 'Get the name of method. (Method: `bar`)', 'Check whether the method is static. (Result: False)', 'Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*". (Result: True, as "bar" matches the pattern)']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (Method: `foo`)* 匹配到的元操作或API：
logic: Get the name of method. (Method: `foo`)
most similar meta operation: Get the name of method
cosine Similarity: 0.9232608079910278
*Check whether the method is static. (Result: True)* 匹配到的元操作或API：
logic: Check whether the method is static. (Result: True)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9568052887916565
*Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "foo" matches the pattern)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (Method: `st_whatever`)* 匹配到的元操作或API：
logic: Get the name of method. (Method: `st_whatever`)
most similar meta operation: Get the name of method
cosine Similarity: 0.8817710876464844
*Check whether the method is static. (Result: True)* 匹配到的元操作或API：
logic: Check whether the method is static. (Result: True)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9568052887916565
*Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "st_whatever" matches the pattern)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (Method: `bar`)* 匹配到的元操作或API：
logic: Get the name of method. (Method: `bar`)
most similar meta operation: Get the name of method
cosine Similarity: 0.9008549451828003
*Check whether the method is static. (Result: False)* 匹配到的元操作或API：
logic: Check whether the method is static. (Result: False)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9587125778198242
*Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*". (Result: True, as "bar" matches the pattern)* 匹配到的元操作或API：
未匹配成功元操作或API
*Since there is no JUnit 3, 4, or 5 test method in the provided test case, we do not need to check the JUnit method names.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (Method: `foo`)* 匹配到的元操作或API：
logic: Get the name of method. (Method: `foo`)
most similar meta operation: Get the name of method
cosine Similarity: 0.9232608079910278
*Check whether the method is static. (Result: True)* 匹配到的元操作或API：
logic: Check whether the method is static. (Result: True)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9568052887916565
*Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: True, as "foo" matches the pattern)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (Method: `St_whatever`)* 匹配到的元操作或API：
logic: Get the name of method. (Method: `St_whatever`)
most similar meta operation: Get the name of method
cosine Similarity: 0.8817710876464844
*Check whether the method is static. (Result: True)* 匹配到的元操作或API：
logic: Check whether the method is static. (Result: True)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9568052887916565
*Check whether the method name matches the regex pattern for static method names "[a-z][a-zA-Z0-9]*". (Result: False, as "St_whatever" does not match the pattern due to the uppercase "S" at the beginning)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. (Method: `bar`)* 匹配到的元操作或API：
logic: Get the name of method. (Method: `bar`)
most similar meta operation: Get the name of method
cosine Similarity: 0.9008549451828003
*Check whether the method is static. (Result: False)* 匹配到的元操作或API：
logic: Check whether the method is static. (Result: False)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9587125778198242
*Check whether the method name matches the regex pattern for instance method names "[a-z][a-zA-Z0-9]*". (Result: True, as "bar" matches the pattern)* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


出现语法错误，这一轮舍弃，直接重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
To perform granular checks on the provided test case to ascertain adherence to the rule, let's follow these steps:

1. Get the name of class.
2. Get all methods declared in class.
3. Check whether the method is static.
4. Get the name of method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
6. If the method is static and its name does not match the regex, report it.

Let's apply these checks to the provided test case:

1. Get the name of class.
   - The name of class is Foo.

2. Get all methods declared in class.
   - The methods declared in class are foo, st_whatever, and bar.

3. Check whether the method is static.
   - Method foo is static.
   - Method st_whatever is static.
   - Method bar is not static.

4. Get the name of method.
   - For method foo, the name is "foo".
   - For method st_whatever, the name is "st_whatever".
   - For method bar, the name is "bar".

5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - For method foo, the name "foo" matches the regex "[a-z][a-zA-Z0-9]*".
   - For method st_whatever, the name "st_whatever" matches the regex "[a-z][a-zA-Z0-9]*".
   - For method bar, the name "bar" matches the regex "[a-z][a-zA-Z0-9]*".

6. If the method is static and its name does not match the regex, report it.
   - For method foo, the name "foo" matches the regex, so no report.
   - For method st_whatever, the name "st_whatever" matches the regex, so no report.
   - For method bar, it is not static, so the regex for static methods does not apply.

Since the provided description states that there is a bad 3 test case and that the number of violations is 1, we need to identify which method is being referred to. Given the provided code, all static method names match the regex for static methods. Therefore, we need to revisit the test case and its description:

From the provided description, it seems like there might be a misunderstanding or an error in the test case or its description. Since all static method names in the provided code match the regex for static methods, there are no violations based on the given test case.

However, if we consider that the original test case might have contained a static method name that did not match the regex, let's assume a hypothetical counterexample:

```java
class Foo {
    static void foo() {
    }

    static void St_whatever() {
    }

    void bar() {
    }
}
```

For this hypothetical counterexample:

1. Get the name of class.
   - The name of class is Foo.

2. Get all methods declared in class.
   - The methods declared in class are foo, St_whatever, and bar.

3. Check whether the method is static.
   - Method foo is static.
   - Method St_whatever is static.
   - Method bar is not static.

4. Get the name of method.
   - For method foo, the name is "foo".
   - For method St_whatever, the name is "St_whatever".
   - For method bar, the name is "bar".

5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - For method foo, the name "foo" matches the regex "[a-z][a-zA-Z0-9]*".
   - For method St_whatever, the name "St_whatever" does not match the regex "[a-z][a-zA-Z0-9]*".
   - For method bar, the name "bar" matches the regex "[a-z][a-zA-Z0-9]*".

6. If the method is static and its name does not match the regex, report it.
   - For method foo, the name "foo" matches the regex, so no report.
   - For method St_whatever, the name "St_whatever" does not match the regex, so report it.
   - For method bar, it is not static, so the regex for static methods does not apply.

In this hypothetical counterexample, the static method `St_whatever` violates the rule because its name does not match the required regex pattern.
['Get the name of class.', 'Get all methods declared in class.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'If the method is static and its name does not match the regex, report it.', 'Get the name of class.', 'Get all methods declared in class.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'If the method is static and its name does not match the regex, report it.', 'Get the name of class.', 'Get all methods declared in class.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'If the method is static and its name does not match the regex, report it.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method is static and its name does not match the regex, report it.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method is static and its name does not match the regex, report it.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method is static and its name does not match the regex, report it.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
            addViolation(data, node);
        } else if (node.getDeclaredAnnotations().anyMatch(annotation -> "Test".equals(annotation.getTypeName()))) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches() && 
                !JUNIT4_TEST_METHOD_PATTERN.matcher(methodName).matches() && 
                !JUNIT5_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches() && 
                !JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
Let's break down the test case and check it against the given rule description step-by-step.

1. Get the name of class.
2. Check whether the class has declared annotations.
3. Get the javadoc comment of class.
4. Check whether the class is abstract.
5. Check whether the class is public.
6. Check whether the class is private.
7. Check whether the class is protected.
8. Check whether the class is default package-private.
9. Check whether the class is final.
10. Check whether the class is static.
11. Get the super class of class.
12. Check whether the class has extended x class.
13. Get a implemented interface of class.
14. Check whether the class has implemented x interface.
15. Get the name of the package where the class is located.
16. Check whether the class is interface.
17. Check whether the class is inner class.
18. Check whether the class is anonymous class.

The above checks are not relevant for this test case as we are focusing on method declarations. Let's continue with the relevant checks:

19. Get the name of method.
20. Get the signature of method.
21. Get the javadoc comment of method.
22. Check whether the method is abstract.
23. Check whether the method is private.
24. Check whether the method is public.
25. Check whether the method is default package-private.
26. Check whether the method is protected.
27. Check whether the method is main method.
28. Get a formal parameter of method.
29. Get the number of formal parameters of method.
30. Get the name of formal parameter.
31. Get the type of formal parameter.
32. Check whether the formal parameter is string type.
33. Check whether the formal parameter is boolean type.
34. Check whether the formal parameter is char type.
35. Check whether the formal parameter is byte type.
36. Check whether the formal parameter is short type.
37. Check whether the formal parameter is int type.
38. Check whether the formal parameter is long type.
39. Check whether the formal parameter is float type.
40. Check whether the formal parameter is double type.
41. Check whether the formal parameter is boxed type.
42. Check whether the formal parameter is a x class type.
43. Check whether the formal parameter is array type.
44. Check whether the formal parameter is enum type.
45. Check whether the formal parameter is record type.
46. Check whether formal parameter has declared annotations.
47. Get a declared annotation of formal parameter.
48. Check whether the formal parameter has x annotation.
49. Get an usage of formal parameter.
50. Check whether the formal parameter is final.
51. Get the return type of method.
52. Check whether the return type of method is void.
53. Check whether the return type of method is string type.
54. Check whether the return type of method is boolean type.
55. Check whether the return type of method is char type.
56. Check whether the return type of method is byte type.
57. Check whether the return type of method is short type.
58. Check whether the return type of method is int type.
59. Check whether the return type of method is long type.
60. Check whether the return type of method is float type.
61. Check whether the return type of method is double type.
62. Check whether the return type of method is boxed type.
63. Check whether the return type of method is x class type.
64. Check whether the return type of method is array type.
65. Check whether the return type of method is enum type.
66. Check whether the return type of method is record type.
67. Get a throw exception in method signature.
68. Check whether the method signature throws x Exception.
69. Check whether method has declared annotations.
70. Get a declared annotation of method.
71. Check whether the method has x annotation.
72. Check whether the method is synchronized.
73. Check whether the method is static.
74. Check whether the method is final.
75. Check whether the method is native.
76. Check whether the method is overridable.
77. Check whether the method is overridden.
78. Get the original method of this overridden method.
79. Get the class that method located in.
80. Check whether the method is a junit method.

Performing the checks:

1. Get the name of method.
   - Method name: foo
2. Check whether the method is static.
   - Result: true
3. Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".
   - Result: true (matches)
   
4. Get the name of method.
   - Method name: st_whatever
5. Check whether the method is static.
   - Result: true
6. Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".
   - Result: true (matches)

7. Get the name of method.
   - Method name: bar
8. Check whether the method is static.
   - Result: false
9. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".
   - Result: true (matches)

Since there are no methods that violate the regex pattern according to the given rule description, the test case "bad 3" seems to be incorrectly described. However, if we consider the rule description to include that JUnit 3 test method names should follow a different pattern "test[A-Z0-9][a-zA-Z0-9]*", let's check for that pattern:

1. Get the name of method.
   - Method name: foo
2. Check whether the method is a junit method.
   - Assume: false (not a JUnit method)
   
1. Get the name of method.
   - Method name: st_whatever
2. Check whether the method is a junit method.
   - Assume: false (not a JUnit method)
   
1. Get the name of method.
   - Method name: bar
2. Check whether the method is a junit method.
   - Assume: false (not a JUnit method)

If the rule description intended to check for JUnit 3 methods and we assume there's a JUnit 3 method in the test case (which is not present in the given code), we would then check if the name matches "test[A-Z0-9][a-zA-Z0-9]*".

Since there are no JUnit 3 methods in the provided test case, and all static and instance method names match the given regex patterns, the test case does not violate the rule as described.

However, if the rule description includes additional checks for JUnit 3 methods that are not present in this test case, those should be addressed separately with the appropriate checks.
['Get the name of class.', 'Check whether the class has declared annotations.', 'Get the javadoc comment of class.', 'Check whether the class is abstract.', 'Check whether the class is public.', 'Check whether the class is private.', 'Check whether the class is protected.', 'Check whether the class is default package-private.', 'Check whether the class is final.', 'Check whether the class is static.', 'Get the super class of class.', 'Check whether the class has extended x class.', 'Get a implemented interface of class.', 'Check whether the class has implemented x interface.', 'Get the name of the package where the class is located.', 'Check whether the class is interface.', 'Check whether the class is inner class.', 'Check whether the class is anonymous class.', 'Get the name of method.', 'Get the signature of method.', 'Get the javadoc comment of method.', 'Check whether the method is abstract.', 'Check whether the method is private.', 'Check whether the method is public.', 'Check whether the method is default package-private.', 'Check whether the method is protected.', 'Check whether the method is main method.', 'Get a formal parameter of method.', 'Get the number of formal parameters of method.', 'Get the name of formal parameter.', 'Get the type of formal parameter.', 'Check whether the formal parameter is string type.', 'Check whether the formal parameter is boolean type.', 'Check whether the formal parameter is char type.', 'Check whether the formal parameter is byte type.', 'Check whether the formal parameter is short type.', 'Check whether the formal parameter is int type.', 'Check whether the formal parameter is long type.', 'Check whether the formal parameter is float type.', 'Check whether the formal parameter is double type.', 'Check whether the formal parameter is boxed type.', 'Check whether the formal parameter is a x class type.', 'Check whether the formal parameter is array type.', 'Check whether the formal parameter is enum type.', 'Check whether the formal parameter is record type.', 'Check whether formal parameter has declared annotations.', 'Get a declared annotation of formal parameter.', 'Check whether the formal parameter has x annotation.', 'Get an usage of formal parameter.', 'Check whether the formal parameter is final.', 'Get the return type of method.', 'Check whether the return type of method is void.', 'Check whether the return type of method is string type.', 'Check whether the return type of method is boolean type.', 'Check whether the return type of method is char type.', 'Check whether the return type of method is byte type.', 'Check whether the return type of method is short type.', 'Check whether the return type of method is int type.', 'Check whether the return type of method is long type.', 'Check whether the return type of method is float type.', 'Check whether the return type of method is double type.', 'Check whether the return type of method is boxed type.', 'Check whether the return type of method is x class type.', 'Check whether the return type of method is array type.', 'Check whether the return type of method is enum type.', 'Check whether the return type of method is record type.', 'Get a throw exception in method signature.', 'Check whether the method signature throws x Exception.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has x annotation.', 'Check whether the method is synchronized.', 'Check whether the method is static.', 'Check whether the method is final.', 'Check whether the method is native.', 'Check whether the method is overridable.', 'Check whether the method is overridden.', 'Get the original method of this overridden method.', 'Get the class that method located in.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method is a junit method.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has declared annotations.* 匹配到的元操作或API：
logic: Check whether the class has declared annotations.
most similar meta operation: Check whether class has declared annotations
cosine Similarity: 0.9833341240882874
*Get the javadoc comment of class.* 匹配到的元操作或API：
logic: Get the javadoc comment of class.
most similar meta operation: Get the javadoc comment of class
cosine Similarity: 0.9901880025863647
*Check whether the class is abstract.* 匹配到的元操作或API：
logic: Check whether the class is abstract.
most similar meta operation: Check whether the class is abstract
cosine Similarity: 0.9844731092453003
*Check whether the class is public.* 匹配到的元操作或API：
logic: Check whether the class is public.
most similar meta operation: Check whether the class is public
cosine Similarity: 0.9849746227264404
*Check whether the class is private.* 匹配到的元操作或API：
logic: Check whether the class is private.
most similar meta operation: Check whether the class is private
cosine Similarity: 0.9853935241699219
*Check whether the class is protected.* 匹配到的元操作或API：
logic: Check whether the class is protected.
most similar meta operation: Check whether the class is protected
cosine Similarity: 0.9844120740890503
*Check whether the class is default package-private.* 匹配到的元操作或API：
logic: Check whether the class is default package-private.
most similar meta operation: Check whether the class is default package-private
cosine Similarity: 0.9734809398651123
*Check whether the class is final.* 匹配到的元操作或API：
logic: Check whether the class is final.
most similar meta operation: Check whether the class is final
cosine Similarity: 0.9887726306915283
*Check whether the class is static.* 匹配到的元操作或API：
logic: Check whether the class is static.
most similar meta operation: Check whether the class is static
cosine Similarity: 0.9831520318984985
*Get the super class of class.* 匹配到的元操作或API：
logic: Get the super class of class.
most similar meta operation: Get the super class of class
cosine Similarity: 0.9851946830749512
*Check whether the class has extended x class.* 匹配到的元操作或API：
logic: Check whether the class has extended x class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.9917446374893188
*Get a implemented interface of class.* 匹配到的元操作或API：
logic: Get a implemented interface of class.
most similar meta operation: Get a implemented interface of class
cosine Similarity: 0.9851537942886353
*Check whether the class has implemented x interface.* 匹配到的元操作或API：
logic: Check whether the class has implemented x interface.
most similar meta operation: Check whether the class has implemented x interface
cosine Similarity: 0.9905824661254883
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the class is interface.* 匹配到的元操作或API：
logic: Check whether the class is interface.
most similar meta operation: Check whether the class is interface
cosine Similarity: 0.9844173789024353
*Check whether the class is inner class.* 匹配到的元操作或API：
logic: Check whether the class is inner class.
most similar meta operation: Check whether the class is inner class
cosine Similarity: 0.987544596195221
*Check whether the class is anonymous class.* 匹配到的元操作或API：
logic: Check whether the class is anonymous class.
most similar meta operation: Check whether the class is anonymous class
cosine Similarity: 0.9849605560302734
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Get the javadoc comment of method.* 匹配到的元操作或API：
logic: Get the javadoc comment of method.
most similar meta operation: Get the javadoc comment of method
cosine Similarity: 0.9902204871177673
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether the method is private.* 匹配到的元操作或API：
logic: Check whether the method is private.
most similar meta operation: Check whether the method is private
cosine Similarity: 0.9821236729621887
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is default package-private.* 匹配到的元操作或API：
logic: Check whether the method is default package-private.
most similar meta operation: Check whether the method is default package-private
cosine Similarity: 0.972201406955719
*Check whether the method is protected.* 匹配到的元操作或API：
logic: Check whether the method is protected.
most similar meta operation: Check whether the method is protected
cosine Similarity: 0.9815421104431152
*Check whether the method is main method.* 匹配到的元操作或API：
logic: Check whether the method is main method.
most similar meta operation: Check whether the method is main method
cosine Similarity: 0.9875174760818481
*Get a formal parameter of method.* 匹配到的元操作或API：
logic: Get a formal parameter of method.
most similar meta operation: Get a formal parameter of method
cosine Similarity: 0.9826655983924866
*Get the number of formal parameters of method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.9860840439796448
*Get the name of formal parameter.* 匹配到的元操作或API：
logic: Get the name of formal parameter.
most similar meta operation: Get the name of formal parameter
cosine Similarity: 0.9837440252304077
*Get the type of formal parameter.* 匹配到的元操作或API：
logic: Get the type of formal parameter.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9854808449745178
*Check whether the formal parameter is string type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is string type.
most similar meta operation: Check whether the formal parameter is string type
cosine Similarity: 0.9882045984268188
*Check whether the formal parameter is boolean type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boolean type.
most similar meta operation: Check whether the formal parameter is boolean type
cosine Similarity: 0.9861541986465454
*Check whether the formal parameter is char type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is char type.
most similar meta operation: Check whether the formal parameter is char type
cosine Similarity: 0.9883654713630676
*Check whether the formal parameter is byte type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is byte type.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.989282488822937
*Check whether the formal parameter is short type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is short type.
most similar meta operation: Check whether the formal parameter is short type
cosine Similarity: 0.9876381158828735
*Check whether the formal parameter is int type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is int type.
most similar meta operation: Check whether the formal parameter is int type
cosine Similarity: 0.9879910945892334
*Check whether the formal parameter is long type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is long type.
most similar meta operation: Check whether the formal parameter is long type
cosine Similarity: 0.988408625125885
*Check whether the formal parameter is float type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is float type.
most similar meta operation: Check whether the formal parameter is float type
cosine Similarity: 0.9876444935798645
*Check whether the formal parameter is double type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is double type.
most similar meta operation: Check whether the formal parameter is double type
cosine Similarity: 0.9877136945724487
*Check whether the formal parameter is boxed type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is boxed type.
most similar meta operation: Check whether the formal parameter is boxed primitive type
cosine Similarity: 0.9612672328948975
*Check whether the formal parameter is a x class type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is a x class type.
most similar meta operation: Check whether the formal parameter is a x class type
cosine Similarity: 0.9905358552932739
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113036155701
*Check whether the formal parameter is enum type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is enum type.
most similar meta operation: Check whether the formal parameter is enum type
cosine Similarity: 0.9871471524238586
*Check whether the formal parameter is record type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is record type.
most similar meta operation: Check whether the formal parameter is record type
cosine Similarity: 0.9890471696853638
*Check whether formal parameter has declared annotations.* 匹配到的元操作或API：
logic: Check whether formal parameter has declared annotations.
most similar meta operation: Check whether formal parameter has declared annotations
cosine Similarity: 0.9899719953536987
*Get a declared annotation of formal parameter.* 匹配到的元操作或API：
logic: Get a declared annotation of formal parameter.
most similar meta operation: Get a declared annotation of formal parameter
cosine Similarity: 0.9871978759765625
*Check whether the formal parameter has x annotation.* 匹配到的元操作或API：
logic: Check whether the formal parameter has x annotation.
most similar meta operation: Check whether the formal parameter has x annotation
cosine Similarity: 0.9898931980133057
*Get an usage of formal parameter.* 匹配到的元操作或API：
logic: Get an usage of formal parameter.
most similar meta operation: Get an usage of formal parameter
cosine Similarity: 0.986284613609314
*Check whether the formal parameter is final.* 匹配到的元操作或API：
logic: Check whether the formal parameter is final.
most similar meta operation: Check whether the formal parameter is final
cosine Similarity: 0.9881319403648376
*Get the return type of method.* 匹配到的元操作或API：
logic: Get the return type of method.
most similar meta operation: Get the return type of method
cosine Similarity: 0.983596682548523
*Check whether the return type of method is void.* 匹配到的元操作或API：
logic: Check whether the return type of method is void.
most similar meta operation: Check whether the return type of method is void
cosine Similarity: 0.9854096174240112
*Check whether the return type of method is string type.* 匹配到的元操作或API：
logic: Check whether the return type of method is string type.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9892082214355469
*Check whether the return type of method is boolean type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boolean type.
most similar meta operation: Check whether the return type of method is boolean
cosine Similarity: 0.9835399389266968
*Check whether the return type of method is char type.* 匹配到的元操作或API：
logic: Check whether the return type of method is char type.
most similar meta operation: Check whether the return type of method is char
cosine Similarity: 0.9825600981712341
*Check whether the return type of method is byte type.* 匹配到的元操作或API：
logic: Check whether the return type of method is byte type.
most similar meta operation: Check whether the return type of method is byte
cosine Similarity: 0.984508216381073
*Check whether the return type of method is short type.* 匹配到的元操作或API：
logic: Check whether the return type of method is short type.
most similar meta operation: Check whether the return type of called method is short type
cosine Similarity: 0.9720065593719482
*Check whether the return type of method is int type.* 匹配到的元操作或API：
logic: Check whether the return type of method is int type.
most similar meta operation: Check whether the return type of method is int
cosine Similarity: 0.9842365384101868
*Check whether the return type of method is long type.* 匹配到的元操作或API：
logic: Check whether the return type of method is long type.
most similar meta operation: Check whether the return type of method is long
cosine Similarity: 0.9787604212760925
*Check whether the return type of method is float type.* 匹配到的元操作或API：
logic: Check whether the return type of method is float type.
most similar meta operation: Check whether the return type of method is float
cosine Similarity: 0.9870142936706543
*Check whether the return type of method is double type.* 匹配到的元操作或API：
logic: Check whether the return type of method is double type.
most similar meta operation: Check whether the return type of method is double
cosine Similarity: 0.9748761653900146
*Check whether the return type of method is boxed type.* 匹配到的元操作或API：
logic: Check whether the return type of method is boxed type.
most similar meta operation: Check whether the return type of called method is boxed type
cosine Similarity: 0.9796503782272339
*Check whether the return type of method is x class type.* 匹配到的元操作或API：
logic: Check whether the return type of method is x class type.
most similar meta operation: Check whether the return type of method is x class type
cosine Similarity: 0.9898589849472046
*Check whether the return type of method is array type.* 匹配到的元操作或API：
logic: Check whether the return type of method is array type.
most similar meta operation: Check whether the return type of method is array type
cosine Similarity: 0.9890990853309631
*Check whether the return type of method is enum type.* 匹配到的元操作或API：
logic: Check whether the return type of method is enum type.
most similar meta operation: Check whether the return type of method is enum type
cosine Similarity: 0.9887509346008301
*Check whether the return type of method is record type.* 匹配到的元操作或API：
logic: Check whether the return type of method is record type.
most similar meta operation: Check whether the return type of method is record type
cosine Similarity: 0.9906391501426697
*Get a throw exception in method signature.* 匹配到的元操作或API：
logic: Get a throw exception in method signature.
most similar meta operation: Get a throw exception in method signature
cosine Similarity: 0.9811146259307861
*Check whether the method signature throws x Exception.* 匹配到的元操作或API：
logic: Check whether the method signature throws x Exception.
most similar meta operation: Check whether the method signature throws x Exception
cosine Similarity: 0.9918776750564575
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has x annotation.* 匹配到的元操作或API：
logic: Check whether the method has x annotation.
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9902997016906738
*Check whether the method is synchronized.* 匹配到的元操作或API：
logic: Check whether the method is synchronized.
most similar meta operation: Check whether the method is synchronized
cosine Similarity: 0.9820958375930786
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is final.* 匹配到的元操作或API：
logic: Check whether the method is final.
most similar meta operation: Check whether the method is final
cosine Similarity: 0.985183835029602
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is overridable.* 匹配到的元操作或API：
logic: Check whether the method is overridable.
most similar meta operation: Check whether the method is overridable
cosine Similarity: 0.9839692115783691
*Check whether the method is overridden.* 匹配到的元操作或API：
logic: Check whether the method is overridden.
most similar meta operation: Check whether the method is overridden
cosine Similarity: 0.9829655885696411
*Get the original method of this overridden method.* 匹配到的元操作或API：
logic: Get the original method of this overridden method.
most similar meta operation: Get the original method of this overridden method
cosine Similarity: 0.9831136465072632
*Get the class that method located in.* 匹配到的元操作或API：
logic: Get the class that method located in.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.9805244207382202
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex for static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPrivate()
6. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isProtected()
7. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isPackagePrivate()
8. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isFinal()
9. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isStatic()
10. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getSuperClassTypeNode()
11. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getSuperInterfaceTypeNodes()
12. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
13. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isInterface()
14. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isNested()
15. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnonymous()
16. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
17. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
18. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.JavadocComment getJavadocComment()
19. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
20. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPrivate()
21. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
22. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPackagePrivate()
23. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isProtected()
24. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isMainMethod()
25. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTFormalParameters getFormalParameters()
26. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
27. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
28. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isAnyAnnotationPresent(java.util.Collection)
29. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public boolean isFinal()
30. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
31. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isVoid()
32. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTThrowsList getThrowsList()
33. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
34. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
35. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isSynchronized()
36. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
37. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isFinal()
38. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
39. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isOverridden()
40. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getOverriddenMethod()
41. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
42. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Check whether class has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node){
    NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
    return annotations.nonEmpty();
}
```
2.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```
3.  //Check whether the class has implemented x interface
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node) {
    if (TypeTestUtil.isA(interfaceName.class, node)) {
        return true;
    }
    return false;
}
```
4.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
5.  //Get the name of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
public String getFormalParameterName(ASTFormalParameter node) {
    return node.getVarId().getName();
}
```
6.  //Check whether the formal parameter is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterStringType(ASTFormalParameter node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
7.  //Check whether the formal parameter is boolean type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterBooleanType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
}
```
8.  //Check whether the formal parameter is char type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterCharType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
}
```
9.  //Check whether the formal parameter is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterByteType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
10.  //Check whether the formal parameter is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterShortType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
11.  //Check whether the formal parameter is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterIntType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
12.  //Check whether the formal parameter is long type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterLongType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
}
```
13.  //Check whether the formal parameter is float type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterFloatType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
}
```
14.  //Check whether the formal parameter is double type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterDoubleType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
}
```
15.  //Check whether the formal parameter is boxed primitive type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public boolean isFormalParameterBoxedPrimitiveType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isBoxedPrimitive();
}
```
16.  //Check whether the formal parameter is a x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFormalParameterClassType(ASTFormalParameter node) {
    return TypeTestUtil.isA(x.class, node.getTypeNode());
}
```
17.  //Check whether the formal parameter is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFormalParameterArrayType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
18.  //Check whether the formal parameter is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterEnumType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
}
```
19.  //Check whether the formal parameter is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isFormalParameterRecordType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
}
```
20.  //Check whether formal parameter has declared annotations
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean hasAnnotation(ASTFormalParameter node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
21.  //Get an usage of formal parameter
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.ASTAssignableExpr;
import java.util.List;
public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFormalParameter node){
    List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = node.getVarId().getLocalUsages();
    return localUsages;
}
```
22.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
23.  //Check whether the return type of method is boolean
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueBooleanType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN)) {
        return true;
    }
    return false;
}
```
24.  //Check whether the return type of method is char
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueCharType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR)) {
        return true;
    }
    return false;
}
```
25.  //Check whether the return type of method is byte
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueByteType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
        return true;
    }
    return false;
}
```
26.  //Check whether the return type of called method is short type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnShortType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
}
```
27.  //Check whether the return type of method is int
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueIntType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT)) {
        return true;
    }
    return false;
}
```
28.  //Check whether the return type of method is long
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueLongType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG)) {
        return true;
    }
    return false;
}
```
29.  //Check whether the return type of method is float
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueFloatType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT)) {
        return true;
    }
    return false;
}
```
30.  //Check whether the return type of method is double
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isReturnValueDoubleType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE)) {
        return true;
    }
    return false;
}
```
31.  //Check whether the return type of called method is boxed type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
public boolean isReturnBoxedPrimitiveType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isBoxedPrimitive();
}
```
32.  //Check whether the return type of method is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueClassType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(x.class, method.getResultTypeNode());
}
```
33.  //Check whether the return type of method is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
public boolean isReturnValueArrayType(ASTMethodDeclaration method) {
    if (method.getResultTypeNode().getTypeMirror().isArray()) {
        return true;
    }
    return false;
}
```
34.  //Check whether the return type of method is enum type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isReturnValueEnumType(ASTMethodDeclaration method) {
    return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isEnum();
}
```
35.  //Check whether the return type of method is record type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;
public boolean isReturnValueRecordType(ASTMethodDeclaration method) {
    return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isRecord();
}
```
36.  //Check whether the method signature throws x Exception
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean throwsSpecificException(ASTMethodDeclaration node){
    ASTThrowsList list = node.getThrowsList();
    if(list == null){
        return false;
    }else{
        for(ASTClassOrInterfaceType classOrInterfaceType : list){
            if(TypeTestUtil.isA(x.class, classOrInterfaceType)){
                return true;
            }
        }
    }
    return false;
}
```
37.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```
38.  //Check whether the method is overridable
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.ast.JModifier;
public boolean isOverridable(ASTMethodDeclaration method){
    return method.hasModifiers(JModifier.STATIC, JModifier.PRIVATE, JModifier.FINAL);
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        Matcher matcher;

        if (TestFrameworksUtil.isJUnitMethod(node)) {
            matcher = JUNIT3_TEST_METHOD_PATTERN.matcher(methodName);
        } else if (node.isNative()) {
            matcher = NATIVE_METHOD_PATTERN.matcher(methodName);
        } else if (node.isStatic()) {
            matcher = STATIC_METHOD_PATTERN.matcher(methodName);
        } else {
            matcher = INSTANCE_METHOD_PATTERN.matcher(methodName);
        }

        if (!matcher.matches()) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    // Utility methods for checking formal parameter types
    public boolean isFormalParameterStringType(ASTFormalParameter node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isFormalParameterBooleanType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN);
    }

    public boolean isFormalParameterCharType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR);
    }

    public boolean isFormalParameterByteType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
    }

    public boolean isFormalParameterShortType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT);
    }

    public boolean isFormalParameterIntType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
    }

    public boolean isFormalParameterLongType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG);
    }

    public boolean isFormalParameterFloatType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT);
    }

    public boolean isFormalParameterDoubleType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE);
    }

    public boolean isFormalParameterBoxedPrimitiveType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        JTypeMirror t = type.getTypeMirror();
        return t.isBoxedPrimitive();
    }

    public boolean isFormalParameterClassType(ASTFormalParameter node, Class<?> clazz) {
        return TypeTestUtil.isA(clazz, node.getTypeNode());
    }

    public boolean isFormalParameterArrayType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().isArray();
    }

    public boolean isFormalParameterEnumType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isEnum();
    }

    public boolean isFormalParameterRecordType(ASTFormalParameter node) {
        ASTType type = node.getTypeNode();
        return type.getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) type.getTypeMirror().getSymbol()).isRecord();
    }

    public int getFormalParametersNumber(ASTMethodDeclaration node) {
        ASTFormalParameters formalParameters = node.getFormalParameters();
        return formalParameters.size();
    }

    public String getFormalParameterName(ASTFormalParameter node) {
        return node.getVarId().getName();
    }

    public boolean hasAnnotation(ASTFormalParameter node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }

    public List<ASTAssignableExpr.ASTNamedReferenceExpr> getAUsage(ASTFormalParameter node) {
        List<ASTAssignableExpr.ASTNamedReferenceExpr> localUsages = node.getVarId().getLocalUsages();
        return localUsages;
    }

    // Utility methods for checking return types
    public boolean isReturnValueStringType(ASTMethodDeclaration method) {
        return TypeTestUtil.isA(String.class, method.getResultTypeNode());
    }

    public boolean isReturnValueBooleanType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BOOLEAN)) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueCharType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.CHAR)) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueByteType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueShortType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.SHORT)) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueIntType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT)) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueLongType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.LONG)) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueFloatType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.FLOAT)) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueDoubleType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.DOUBLE)) {
            return true;
        }
        return false;
    }

    public boolean isReturnBoxedPrimitiveType(ASTMethodCall call) {
        JMethodSig m = call.getMethodType();
        return m.getReturnType().isBoxedPrimitive();
    }

    public boolean isReturnValueClassType(ASTMethodDeclaration method, Class<?> clazz) {
        return TypeTestUtil.isA(clazz, method.getResultTypeNode());
    }

    public boolean isReturnValueArrayType(ASTMethodDeclaration method) {
        if (method.getResultTypeNode().getTypeMirror().isArray()) {
            return true;
        }
        return false;
    }

    public boolean isReturnValueEnumType(ASTMethodDeclaration method) {
        return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isEnum();
    }

    public boolean isReturnValueRecordType(ASTMethodDeclaration method) {
        return method.getResultTypeNode().getTypeMirror().getSymbol() instanceof JClassSymbol && ((JClassSymbol) method.getResultTypeNode().getTypeMirror().getSymbol()).isRecord();
    }

    // Utility method for checking whether the method signature throws x Exception
    public boolean throwsSpecificException(ASTMethodDeclaration node, Class<?> exceptionClass) {
        ASTThrowsList list = node.getThrowsList();
        if (list == null) {
            return false;
        } else {
            for (ASTClassOrInterfaceType classOrInterfaceType : list) {
                if (TypeTestUtil.isA(exceptionClass, classOrInterfaceType)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Utility method for checking whether method has declared annotations
    public boolean hasAnnotation(ASTMethodDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.nonEmpty();
    }

    // Utility method for checking whether the method is overridable
    public boolean isOverridable(ASTMethodDeclaration method) {
        return !method.hasModifiers(JModifier.STATIC, JModifier.PRIVATE, JModifier.FINAL);
    }

    // Utility method for checking whether class has declared annotations
    public boolean hasAnnotations(ASTClassOrInterfaceDeclaration node) {
        NodeStream<ASTAnnotation> annotations = node.getDeclaredAnnotations();
        return annotations.nonEmpty();
    }

    // Utility method for checking whether the class has extended x class
    public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, Class<?> clazz) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(clazz, classOrInterfaceType);
    }

    // Utility method for checking whether the class has implemented x interface
    public boolean hasImplementComparable(ASTClassOrInterfaceDeclaration node, Class<?> interfaceClass) {
        return TypeTestUtil.isA(interfaceClass, node);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
Let's perform granular checks to ascertain the adherence of the test case to the rule:

1. Get the name of the class.
2. Get the name of method.
3. Check whether the method is static.
4. Get the signature of method.
5. Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*".
6. Repeat steps 2 to 5 for all methods in the class.

For the provided test case:

1. Get the name of the class: `Foo`
2. Get the name of method: `foo`
3. Check whether the method is static: `True`
4. Get the signature of method: `static void foo()`
5. Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*". `foo` matches the regex.
6. Get the name of method: `st_whatever`
7. Check whether the method is static: `True`
8. Get the signature of method: `static void st_whatever()`
9. Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*". `st_whatever` matches the regex.
10. Get the name of method: `bar`
11. Check whether the method is static: `False`
12. Get the signature of method: `void bar()`
13. Check whether the method name matches the regex for instance method names: "[a-z][a-zA-Z0-9]*". `bar` matches the regex.

Based on the provided test case, neither `foo` nor `st_whatever` violate the rule as their names match the regex for static method names. The `bar` method is an instance method and its name also matches the regex for instance method names. However, based on the description provided ("bad 3"), it seems there is an expectation to find a violation. This discrepancy suggests the test case description might be inaccurate or there might be additional context not covered in the provided rule description.

Given the rule and the provided test case, no methods violate the rule as described. If there is a specific method that should be violating the rule, please provide that method's name and details so we can accurately perform the checks.
['Get the name of the class.', 'Get the name of method.', 'Check whether the method is static.', 'Get the signature of method.', 'Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*".', 'Repeat steps 2 to 5 for all methods in the class.', 'Get the name of the class: `Foo`', 'Get the name of method: `foo`', 'Check whether the method is static: `True`', 'Get the signature of method: `static void foo()`', 'Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*". `foo` matches the regex.', 'Get the name of method: `st_whatever`', 'Check whether the method is static: `True`', 'Get the signature of method: `static void st_whatever()`', 'Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*". `st_whatever` matches the regex.', 'Get the name of method: `bar`', 'Check whether the method is static: `False`', 'Get the signature of method: `void bar()`', 'Check whether the method name matches the regex for instance method names: "[a-z][a-zA-Z0-9]*". `bar` matches the regex.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of the class.* 匹配到的元操作或API：
logic: Get the name of the class.
most similar meta operation: Get the name of class
cosine Similarity: 0.968898594379425
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2 to 5 for all methods in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the class: `Foo`* 匹配到的元操作或API：
logic: Get the name of the class: `Foo`
most similar meta operation: Get the name of class
cosine Similarity: 0.9016551971435547
*Get the name of method: `foo`* 匹配到的元操作或API：
logic: Get the name of method: `foo`
most similar meta operation: Get the name of method
cosine Similarity: 0.908697247505188
*Check whether the method is static: `True`* 匹配到的元操作或API：
logic: Check whether the method is static: `True`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9441307187080383
*Get the signature of method: `static void foo()`* 匹配到的元操作或API：
logic: Get the signature of method: `static void foo()`
most similar meta operation: Get the signature of method
cosine Similarity: 0.904498279094696
*Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*". `foo` matches the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `st_whatever`* 匹配到的元操作或API：
query: Get the name of method: `st_whatever`
most similar API: get name of method
cosine Similarity: 0.8276785016059875
*Check whether the method is static: `True`* 匹配到的元操作或API：
logic: Check whether the method is static: `True`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9441307187080383
*Get the signature of method: `static void st_whatever()`* 匹配到的元操作或API：
logic: Get the signature of method: `static void st_whatever()`
most similar meta operation: Get the signature of method
cosine Similarity: 0.8643409013748169
*Check whether the method name matches the regex for static method names: "[a-z][a-zA-Z0-9]*". `st_whatever` matches the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `bar`* 匹配到的元操作或API：
logic: Get the name of method: `bar`
most similar meta operation: Get the name of method
cosine Similarity: 0.870496392250061
*Check whether the method is static: `False`* 匹配到的元操作或API：
logic: Check whether the method is static: `False`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9453908801078796
*Get the signature of method: `void bar()`* 匹配到的元操作或API：
logic: Get the signature of method: `void bar()`
most similar meta operation: Get the signature of method
cosine Similarity: 0.8893681168556213
*Check whether the method name matches the regex for instance method names: "[a-z][a-zA-Z0-9]*". `bar` matches the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        String methodName = node.getName();
        if (node.isStatic()) {
            if (!STATIC_METHOD_PATTERN.matcher(methodName).matches()) {
                addViolation(data, node);
            }
        } else {
            // Assuming no JUnit 4 or 5 test methods in this example, only checking JUnit 3 test methods
            if (node.getAnnotations().stream().anyMatch(a -> a.getName().endsWith("Test"))) {
                if (!JUNIT3_TEST_METHOD_PATTERN.matcher(methodName).matches()) {
                    addViolation(data, node);
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
To verify the adherence of the provided test case to the rule, we need to perform a series of granular checks on the method declarations within the class `Foo`. Let's proceed step by step.

1. Get the name of class.
2. Get a method declared in class.
3. Check whether the method is static.
4. Get the name of method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
6. Repeat steps 2-5 for all methods declared in class.

Let's apply these checks to the test case:

1. Get the name of class.
   - The name of the class is `Foo`.

2. Get a method declared in class.
   - The first method declared in class `Foo` is `foo`.

3. Check whether the method is static.
   - `foo` is a static method.

4. Get the name of method.
   - The name of the method is `foo`.

5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - The name `foo` matches the regex "[a-z][a-zA-Z0-9]*".

6. Repeat steps 2-5 for all methods declared in class.
   - The next method declared in class `Foo` is `st_whatever`.

7. Check whether the method is static.
   - `st_whatever` is a static method.

8. Get the name of method.
   - The name of the method is `st_whatever`.

9. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - The name `st_whatever` matches the regex "[a-z][a-zA-Z0-9]*".

10. Repeat steps 2-5 for all methods declared in class.
    - The next method declared in class `Foo` is `bar`.

11. Check whether the method is static.
    - `bar` is not a static method.

12. Get the name of method.
    - The name of the method is `bar`.

13. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
    - The name `bar` matches the regex "[a-z][a-zA-Z0-9]*".

The test case provided does not include any method names that violate the specified regex patterns for their respective kinds. Specifically, the static methods `foo` and `st_whatever` match the regex "[a-z][a-zA-Z0-9]*", and the instance method `bar` also matches the same regex pattern.

Given the description of the test case "bad 3" and the expected number of violations as 1, there seems to be a discrepancy. To identify the violation, let's consider the provided description more closely.

If the description "bad 3" implies that the test case should have a method that violates the rule, we need to look at the provided regex patterns more carefully. Since the regex pattern for static method names is "[a-z][a-zA-Z0-9]*", and both `foo` and `st_whatever` match this pattern, they do not violate the rule.

Therefore, the test case provided does not contain any violations based on the given regex patterns. If there is an expected violation, the test case might need to be adjusted to include a method name that does not match the respective regex pattern.
['Get the name of class.', 'Get a method declared in class.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Repeat steps 2-5 for all methods declared in class.', 'Get the name of class.', 'Get a method declared in class.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Repeat steps 2-5 for all methods declared in class.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Repeat steps 2-5 for all methods declared in class.', 'Check whether the method is static.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get a method declared in class.* 匹配到的元操作或API：
logic: Get a method declared in class.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.8743379712104797
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-5 for all methods declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get a method declared in class.* 匹配到的元操作或API：
logic: Get a method declared in class.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.8743379712104797
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-5 for all methods declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 2-5 for all methods declared in class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
The test case corresponding to the rule:
```
// Static method pattern
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
The description of this test case is: bad 3
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'st_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 3


======================接下来开始迭代=====================
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is native.
3. Get the signature of method.
4. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.
5. Get the name of method.
6. Check whether the method is native.
7. Get the signature of method.
8. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.
9. Get the name of method.
10. Check whether the method is native.
11. Get the signature of method.
12. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.

In this test case, the method `foo` is native, but it does not match the regex "[a-z][a-zA-Z0-9]*" because it is not strictly camel case (starting with a lowercase letter). The method `nt_whatever` does match the regex for native methods. Therefore, the number of violations is 1, as reported.
['Get the name of method.', 'Check whether the method is native.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.', 'Get the name of method.', 'Check whether the method is native.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.', 'Get the name of method.', 'Check whether the method is native.', 'Get the signature of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*" for native methods.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Native method pattern
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'nt_whatever')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 5" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
84
70
94
78
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class extends TestCase.
3. Get all methods declared in class.
4. Get the name of method.
5. Check whether the method is a junit method.
6. Get the name of called method.
7. Check whether the called method name matches the regex for JUnit 3 test method names.
8. Check whether the method is public.
9. Check whether the method is static.
10. Check whether the method is a test method.
11. Get the signature of method.
12. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names.

For the provided test case:
1. Get the name of class: TournamentTest
2. Check whether the class extends TestCase: True
3. Get all methods declared in class: testGetBestTeam, test_getBestTeam
4. Get the name of method: testGetBestTeam
5. Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)
6. Get the name of called method: Not applicable (we’re checking the method name, not a called method)
7. Check whether the called method name matches the regex for JUnit 3 test method names: True
8. Check whether the method is public: True
9. Check whether the method is static: False
10. Check whether the method is a test method: True (since it’s named testGetBestTeam and is public void)
11. Get the signature of method: public void testGetBestTeam()
12. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: True

4. Get the name of method: test_getBestTeam
5. Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)
6. Get the name of called method: Not applicable (we’re checking the method name, not a called method)
7. Check whether the called method name matches the regex for JUnit 3 test method names: False (since it does not match the JUnit 3 test method name pattern)
8. Check whether the method is public: True
9. Check whether the method is static: False
10. Check whether the method is a test method: False (since it does not match the JUnit 3 test method name pattern)
11. Get the signature of method: public void test_getBestTeam()
12. Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: False

The number of methods violating the rule in this test case is: 1 (test_getBestTeam method)
['Get the name of class.', 'Check whether the class extends TestCase.', 'Get all methods declared in class.', 'Get the name of method.', 'Check whether the method is a junit method.', 'Get the name of called method.', 'Check whether the called method name matches the regex for JUnit 3 test method names.', 'Check whether the method is public.', 'Check whether the method is static.', 'Check whether the method is a test method.', 'Get the signature of method.', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names.', 'Get the name of class: TournamentTest', 'Check whether the class extends TestCase: True', 'Get all methods declared in class: testGetBestTeam, test_getBestTeam', 'Get the name of method: testGetBestTeam', "Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)", 'Get the name of called method: Not applicable (we’re checking the method name, not a called method)', 'Check whether the called method name matches the regex for JUnit 3 test method names: True', 'Check whether the method is public: True', 'Check whether the method is static: False', 'Check whether the method is a test method: True (since it’s named testGetBestTeam and is public void)', 'Get the signature of method: public void testGetBestTeam()', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: True', 'Get the name of method: test_getBestTeam', "Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)", 'Get the name of called method: Not applicable (we’re checking the method name, not a called method)', 'Check whether the called method name matches the regex for JUnit 3 test method names: False (since it does not match the JUnit 3 test method name pattern)', 'Check whether the method is public: True', 'Check whether the method is static: False', 'Check whether the method is a test method: False (since it does not match the JUnit 3 test method name pattern)', 'Get the signature of method: public void test_getBestTeam()', 'Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: False']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class extends TestCase.* 匹配到的元操作或API：
query: Check whether the class extends TestCase.
most similar API: Check whether is test class
cosine Similarity: 0.8235633373260498
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of called method.* 匹配到的元操作或API：
logic: Get the name of called method.
most similar meta operation: Get the name of called method
cosine Similarity: 0.9817375540733337
*Check whether the called method name matches the regex for JUnit 3 test method names.* 匹配到的元操作或API：
query: Check whether the called method name matches the regex for JUnit 3 test method names.
most similar API: Check whether is junit3 method
cosine Similarity: 0.8315608501434326
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is a test method.* 匹配到的元操作或API：
logic: Check whether the method is a test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.886772871017456
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names.* 匹配到的元操作或API：
query: Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names.
most similar API: Check whether is junit3 method
cosine Similarity: 0.811194121837616
*Get the name of class: TournamentTest* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the class extends TestCase: True* 匹配到的元操作或API：
query: Check whether the class extends TestCase: True
most similar API: Check whether is test class
cosine Similarity: 0.8161604404449463
*Get all methods declared in class: testGetBestTeam, test_getBestTeam* 匹配到的元操作或API：
query: Get all methods declared in class: testGetBestTeam, test_getBestTeam
most similar API: get declared annotations of method
cosine Similarity: 0.8041825294494629
*Get the name of method: testGetBestTeam* 匹配到的元操作或API：
query: Get the name of method: testGetBestTeam
most similar API: get name of method
cosine Similarity: 0.8378527164459229
*Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)* 匹配到的元操作或API：
logic: Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8982032537460327
*Get the name of called method: Not applicable (we’re checking the method name, not a called method)* 匹配到的元操作或API：
query: Get the name of called method: Not applicable (we’re checking the method name, not a called method)
most similar API: get method name of method
cosine Similarity: 0.8109339475631714
*Check whether the called method name matches the regex for JUnit 3 test method names: True* 匹配到的元操作或API：
query: Check whether the called method name matches the regex for JUnit 3 test method names: True
most similar API: Check whether is junit3 method
cosine Similarity: 0.8304612636566162
*Check whether the method is public: True* 匹配到的元操作或API：
logic: Check whether the method is public: True
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9710834622383118
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is a test method: True (since it’s named testGetBestTeam and is public void)* 匹配到的元操作或API：
query: Check whether the method is a test method: True (since it’s named testGetBestTeam and is public void)
most similar API: Check whether is test method
cosine Similarity: 0.8689538240432739
*Get the signature of method: public void testGetBestTeam()* 匹配到的元操作或API：
logic: Get the signature of method: public void testGetBestTeam()
most similar meta operation: Get the signature of method
cosine Similarity: 0.8770496249198914
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: True* 匹配到的元操作或API：
query: Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: True
most similar API: Check whether is junit3 method
cosine Similarity: 0.8117899298667908
*Get the name of method: test_getBestTeam* 匹配到的元操作或API：
query: Get the name of method: test_getBestTeam
most similar API: get name of method
cosine Similarity: 0.8494269847869873
*Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)* 匹配到的元操作或API：
logic: Check whether the method is a junit method: True (since it's a public void method and the class extends TestCase)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8982032537460327
*Get the name of called method: Not applicable (we’re checking the method name, not a called method)* 匹配到的元操作或API：
query: Get the name of called method: Not applicable (we’re checking the method name, not a called method)
most similar API: get method name of method
cosine Similarity: 0.8109339475631714
*Check whether the called method name matches the regex for JUnit 3 test method names: False (since it does not match the JUnit 3 test method name pattern)* 匹配到的元操作或API：
query: Check whether the called method name matches the regex for JUnit 3 test method names: False (since it does not match the JUnit 3 test method name pattern)
most similar API: Check whether is junit3 method
cosine Similarity: 0.8371301293373108
*Check whether the method is public: True* 匹配到的元操作或API：
logic: Check whether the method is public: True
most similar meta operation: Check whether the method is public
cosine Similarity: 0.9710834622383118
*Check whether the method is static: False* 匹配到的元操作或API：
logic: Check whether the method is static: False
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9611486196517944
*Check whether the method is a test method: False (since it does not match the JUnit 3 test method name pattern)* 匹配到的元操作或API：
logic: Check whether the method is a test method: False (since it does not match the JUnit 3 test method name pattern)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8958357572555542
*Get the signature of method: public void test_getBestTeam()* 匹配到的元操作或API：
logic: Get the signature of method: public void test_getBestTeam()
most similar meta operation: Get the signature of method
cosine Similarity: 0.8803106546401978
*Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: False* 匹配到的元操作或API：
query: Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test method names: False
most similar API: Check whether is junit3 method
cosine Similarity: 0.8109359741210938
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
9. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
10. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
11. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.
12. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getMethodName(), //Returns the simple name of the method. @deprecated Use {@link #getName()}
13. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isTestClass(node.getDeclaringTypeNode()) && node.isPublic() && node.getParameterCount() == 0) {
            if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            } else if (TestFrameworksUtil.isTestMethod(node) && !JUNIT45_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is a junit method.
3. Check whether the method is a JUnit 3 test method.
4. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".
5. Get the name of method.
6. Check whether the method is a junit method.
7. Check whether the method is a JUnit 3 test method.
8. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".

By performing these checks, we can determine the adherence of the methods in the test case to the specified naming conventions for JUnit 3 test methods:

- For `testGetBestTeam()`: 
  - 1. Get the name of method -> "testGetBestTeam"
  - 2. Check whether the method is a junit method -> Yes (assuming it's a test method because it starts with "test" and follows JUnit conventions)
  - 3. Check whether the method is a JUnit 3 test method -> Yes (method name starts with "test")
  - 4. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*" -> Yes (it matches the specified regex)

- For `test_getBestTeam()`:
  - 5. Get the name of method -> "test_getBestTeam"
  - 6. Check whether the method is a junit method -> Yes (assuming it's a test method because it starts with "test" and follows JUnit conventions)
  - 7. Check whether the method is a JUnit 3 test method -> Yes (method name starts with "test")
  - 8. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*" -> No (it does not match the specified regex because it contains an underscore)

The test case contains 1 method that violates the rule: `test_getBestTeam()`.
['Get the name of method.', 'Check whether the method is a junit method.', 'Check whether the method is a JUnit 3 test method.', 'Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is a junit method.', 'Check whether the method is a JUnit 3 test method.', 'Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is a JUnit 3 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.917560875415802
*Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8107518553733826
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is a JUnit 3 test method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit 3 test method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.917560875415802
*Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8107518553733826
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnitMethod(node) && !JUNIT45_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
        2. Check whether the class has extended TestCase class.
        3. Get all methods declared in class.
        4. Get the name of method.
        5. Check whether the method is public.
        6. Check whether the method is a junit method.
        7. If the method is a JUnit method, get the specific JUnit version.
        8. For JUnit 3 test methods, check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".
        9. For JUnit 4 and 5 test methods, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
        
Given the test case:
- 1. Get the name of class: `TournamentTest`
- 2. Check whether the class has extended TestCase class: Yes, it extends `TestCase`.
- 3. Get all methods declared in class: `testGetBestTeam` and `test_getBestTeam`
- 4. Get the name of method: `testGetBestTeam`
- 5. Check whether the method is public: Yes, the method is `public`.
- 6. Check whether the method is a junit method: Yes, it is a JUnit method.
- 7. If the method is a JUnit method, get the specific JUnit version: Since the class extends `TestCase`, it is a JUnit 3 test case.
- 8. For JUnit 3 test methods, check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*": `testGetBestTeam` matches the regex.
- 4. Get the name of method: `test_getBestTeam`
- 5. Check whether the method is public: Yes, the method is `public`.
- 6. Check whether the method is a junit method: Yes, it is a JUnit method.
- 7. If the method is a JUnit method, get the specific JUnit version: Since the class extends `TestCase`, it is a JUnit 3 test case.
- 8. For JUnit 3 test methods, check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*": `test_getBestTeam` does not match the regex.

The method `test_getBestTeam` violates the rule because its name does not match the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*". Therefore, the number of violations in this test case is 1.
['Get the name of class.', 'Check whether the class has extended TestCase class.', 'Get all methods declared in class.', 'Get the name of method.', 'Check whether the method is public.', 'Check whether the method is a junit method.', 'If the method is a JUnit method, get the specific JUnit version.', 'For JUnit 3 test methods, check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".', 'For JUnit 4 and 5 test methods, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has extended TestCase class.* 匹配到的元操作或API：
logic: Check whether the class has extended TestCase class.
most similar meta operation: Check whether the class has extended x class
cosine Similarity: 0.8671178817749023
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is public.* 匹配到的元操作或API：
logic: Check whether the method is public.
most similar meta operation: Check whether the method is public
cosine Similarity: 0.982057511806488
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*If the method is a JUnit method, get the specific JUnit version.* 匹配到的元操作或API：
未匹配成功元操作或API
*For JUnit 3 test methods, check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: For JUnit 3 test methods, check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8347771763801575
*For JUnit 4 and 5 test methods, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: For JUnit 4 and 5 test methods, check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit5 method
cosine Similarity: 0.8240450620651245
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isPublic()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)

1.  //Check whether the class has extended x class
```java
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node){
    ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
    return TypeTestUtil.isA(x.class, classOrInterfaceType);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnitMethod(node) && !JUNIT45_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean extendsSpecificClass(ASTClassOrInterfaceDeclaration node, Class<?> clazz) {
        ASTClassOrInterfaceType classOrInterfaceType = node.getSuperClassTypeNode();
        return TypeTestUtil.isA(clazz, classOrInterfaceType);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Check whether the class extends TestCase.
3. Get all methods declared in class.
4. Check whether the method is a junit method.
5. Get the name of method.
6. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").

For the method `testGetBestTeam`:

1. Get the name of method.
2. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").

For the method `test_getBestTeam`:

1. Get the name of method.
2. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").

The method `test_getBestTeam` does not violate the rule as its name does not start with "test" followed directly by an uppercase letter or a digit. The method `testGetBestTeam` does violate the rule as its name matches the JUnit 3 test method name regex, but the test case specifies that there is only one violation. Therefore, we need to identify the specific method that violates the rule:

- For `testGetBestTeam`:
  1. Get the name of method.
  2. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").

- For `test_getBestTeam`:
  1. Get the name of method.
  2. Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").

The method `testGetBestTeam` matches the JUnit 3 test method name regex and thus violates the rule.
['Get the name of class.', 'Check whether the class extends TestCase.', 'Get all methods declared in class.', 'Check whether the method is a junit method.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class extends TestCase.* 匹配到的元操作或API：
query: Check whether the class extends TestCase.
most similar API: Check whether is test class
cosine Similarity: 0.8235633373260498
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099056482315063
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099056482315063
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099056482315063
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099056482315063
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8099056482315063
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestClass(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnitMethod(node) && !JUNIT45_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
        2. Check whether the method is a junit method.
        3. If the method is a JUnit method, get the name of the JUnit test method.
        4. Check whether the JUnit test method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
        5. Repeat steps 1-4 for each method in the class.

For the provided test case:

1. Get the name of method `testGetBestTeam`.
        2. Check whether the method `testGetBestTeam` is a JUnit method.
        3. Get the name of the JUnit test method `testGetBestTeam`.
        4. Check whether the JUnit test method name `testGetBestTeam` matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). This name matches the regex.
        5. Get the name of method `test_getBestTeam`.
        6. Check whether the method `test_getBestTeam` is a JUnit method.
        7. Get the name of the JUnit test method `test_getBestTeam`.
        8. Check whether the JUnit test method name `test_getBestTeam` matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). This name does not match the regex.

The number of violating the rule in this test case is: 1 (method `test_getBestTeam` does not match the regex for JUnit 3 test method names).
['Get the name of method.', 'Check whether the method is a junit method.', 'If the method is a JUnit method, get the name of the JUnit test method.', 'Check whether the JUnit test method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").', 'Repeat steps 1-4 for each method in the class.', 'Get the name of method `testGetBestTeam`.', 'Check whether the method `testGetBestTeam` is a JUnit method.', 'Get the name of the JUnit test method `testGetBestTeam`.', 'Check whether the JUnit test method name `testGetBestTeam` matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). This name matches the regex.', 'Get the name of method `test_getBestTeam`.', 'Check whether the method `test_getBestTeam` is a JUnit method.', 'Get the name of the JUnit test method `test_getBestTeam`.', 'Check whether the JUnit test method name `test_getBestTeam` matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). This name does not match the regex.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTExtendsList', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*If the method is a JUnit method, get the name of the JUnit test method.* 匹配到的元操作或API：
query: If the method is a JUnit method, get the name of the JUnit test method.
most similar API: Check whether is junit method
cosine Similarity: 0.8290703296661377
*Check whether the JUnit test method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the JUnit test method name matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*").
most similar API: Check whether is junit3 method
cosine Similarity: 0.8098170757293701
*Repeat steps 1-4 for each method in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method `testGetBestTeam`.* 匹配到的元操作或API：
query: Get the name of method `testGetBestTeam`.
most similar API: get name of method
cosine Similarity: 0.8239880204200745
*Check whether the method `testGetBestTeam` is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method `testGetBestTeam` is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8638796806335449
*Get the name of the JUnit test method `testGetBestTeam`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the JUnit test method name `testGetBestTeam` matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). This name matches the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method `test_getBestTeam`.* 匹配到的元操作或API：
query: Get the name of method `test_getBestTeam`.
most similar API: get name of method
cosine Similarity: 0.8377048969268799
*Check whether the method `test_getBestTeam` is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method `test_getBestTeam` is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8702070713043213
*Get the name of the JUnit test method `test_getBestTeam`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the JUnit test method name `test_getBestTeam` matches the regex for JUnit 3 test method names ("test[A-Z0-9][a-zA-Z0-9]*"). This name does not match the regex.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 3 test detection
import junit.framework.Assert;
import junit.framework.TestCase;

public class TournamentTest extends TestCase {

    public void testGetBestTeam() {
    }

    // this is ok tho
    public void test_getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTExtendsList
    ——ASTClassOrInterfaceType (this is a class type)
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'testGetBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'test_getBestTeam')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //True if this is a junit @Test method (or a junit 3 method).
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 5
[ERROR]   "bad 6" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
99
82
84
70
107
91
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get a declared annotation of class.
3. Check whether the class has x annotation (org.junit.Test).
4. Get all methods declared in class.
5. Get a declared annotation of method.
6. Check whether the method has x annotation (org.junit.Test).
7. Get the name of method.
8. Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").
9. Get the name of method.
10. Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").

For the method `get_best_team`:

11. Get the name of method (get_best_team).
12. Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").

For the method `getBestTeam`:

13. Get the name of method (getBestTeam).
14. Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").

If the method `get_best_team` does not match the regex for JUnit 4 test method names, then it violates the rule. The method `getBestTeam` matches the regex, so it does not violate the rule.
            
['Get the name of class.', 'Get a declared annotation of class.', 'Check whether the class has x annotation (org.junit.Test).', 'Get all methods declared in class.', 'Get a declared annotation of method.', 'Check whether the method has x annotation (org.junit.Test).', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").', 'Get the name of method (get_best_team).', 'Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").', 'Get the name of method (getBestTeam).', 'Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").']
['ASTAnnotation', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get a declared annotation of class.* 匹配到的元操作或API：
logic: Get a declared annotation of class.
most similar meta operation: Get a declared annotation of class
cosine Similarity: 0.987838864326477
*Check whether the class has x annotation (org.junit.Test).* 匹配到的元操作或API：
logic: Check whether the class has x annotation (org.junit.Test).
most similar meta operation: Check whether the class has x annotation
cosine Similarity: 0.9487923979759216
*Get all methods declared in class.* 匹配到的元操作或API：
query: Get all methods declared in class.
most similar API: get declared annotations of method
cosine Similarity: 0.8366352915763855
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has x annotation (org.junit.Test).* 匹配到的元操作或API：
logic: Check whether the method has x annotation (org.junit.Test).
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9527726173400879
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").
most similar API: Check whether is junit4 method
cosine Similarity: 0.8051496148109436
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").
most similar API: Check whether is junit4 method
cosine Similarity: 0.8051496148109436
*Get the name of method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method (get_best_team).
most similar API: get name of method
cosine Similarity: 0.809440553188324
*Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").
most similar API: Check whether is junit4 method
cosine Similarity: 0.8051496148109436
*Get the name of method (getBestTeam).* 匹配到的元操作或API：
logic: Get the name of method (getBestTeam).
most similar meta operation: Get the name of method
cosine Similarity: 0.9083284735679626
*Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names ("[a-z][a-zA-Z0-9]*").
most similar API: Check whether is junit4 method
cosine Similarity: 0.8051496148109436
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
3. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is a JUnit method.
3. Check whether the method has the @Test annotation.
4. Get the name of method.
5. Check whether the method name matches the regex for JUnit 4 test method names, which is "[a-z][a-zA-Z0-9]*".
6. Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
7. Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".

For the method `get_best_team`:

1. Get the name of method.
        - The name is `get_best_team`.
2. Check whether the method is a JUnit method.
        - The method is a JUnit method because it has the @Test annotation.
3. Check whether the method has the @Test annotation.
        - It does have the @Test annotation.
4. Get the name of method.
        - The name is `get_best_team`.
5. Check whether the method name matches the regex for JUnit 4 test method names, which is "[a-z][a-zA-Z0-9]*".
        - The method name does not match the regex, as it contains an underscore.
6. Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
        - The method name does not match this regex either.
7. Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".
        - The method name does not match this regex either.

Since the method name `get_best_team` does not match any of the regex patterns for JUnit methods, it violates the rule. The method `getBestTeam` matches the pattern and does not violate the rule. Therefore, the number of violations in this test case is 1.
['Get the name of method.', 'Check whether the method is a JUnit method.', 'Check whether the method has the @Test annotation.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 4 test method names, which is "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is a JUnit method.', 'Check whether the method has the @Test annotation.', 'Get the name of method.', 'Check whether the method name matches the regex for JUnit 4 test method names, which is "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".']
['ASTAnnotation', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method has the @Test annotation.* 匹配到的元操作或API：
query: Check whether the method has the @Test annotation.
most similar API: Check whether the method is annotation present
cosine Similarity: 0.8465760946273804
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 4 test method names, which is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8015706539154053
*Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit5 method
cosine Similarity: 0.8037692904472351
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method has the @Test annotation.* 匹配到的元操作或API：
query: Check whether the method has the @Test annotation.
most similar API: Check whether the method is annotation present
cosine Similarity: 0.8465760946273804
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex for JUnit 4 test method names, which is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names, which is "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8015706539154053
*Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names, which is "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit5 method
cosine Similarity: 0.8037692904472351
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnnotationPresent(java.lang.Class), //Returns true if an annotation with the given type is applied to this node.
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnitMethod(node) && !JUNIT45_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the name of method.
3. Check whether method has declared annotations.
4. Get a declared annotation of method.
5. Check whether the method has Test annotation.
6. Get the signature of method.
7. Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".
8. Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
9. Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".

Let's apply these checks to the provided test case:

1. Get the name of class.
        - The name of the class is `TournamentTest`.

2. Get the name of method.
        - The first method name is `get_best_team`.
        - The second method name is `getBestTeam`.

3. Check whether method has declared annotations.
        - Both methods have declared annotations.

4. Get a declared annotation of method.
        - The declared annotation for both methods is `@Test`.

5. Check whether the method has Test annotation.
        - Both methods have the `Test` annotation.

6. Get the signature of method.
        - The signature of the first method is `public void get_best_team()`.
        - The signature of the second method is `public void getBestTeam()`.

7. Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".
        - The first method signature does not match the regex (contains an underscore).
        - The second method signature matches the regex.

8. Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
        - The first method signature does not match the regex (contains an underscore).
        - The second method signature matches the regex.

9. Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
        - This is redundant as it's the same check as step 8 for JUnit 4.

Based on the checks, the method `get_best_team` does not match the regex "[a-z][a-zA-Z0-9]*" and thus violates the rule. The method `getBestTeam` adheres to the rule. Therefore, the number of violations in this test case is 1.
['Get the name of class.', 'Get the name of method.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has Test annotation.', 'Get the signature of method.', 'Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".', 'Get the name of class.', 'Get the name of method.', 'Check whether method has declared annotations.', 'Get a declared annotation of method.', 'Check whether the method has Test annotation.', 'Get the signature of method.', 'Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".']
['ASTAnnotation', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has Test annotation.* 匹配到的元操作或API：
logic: Check whether the method has Test annotation.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8841646909713745
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8021494150161743
*Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8428394198417664
*Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8428394198417664
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether method has declared annotations.* 匹配到的元操作或API：
logic: Check whether method has declared annotations.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.9891549348831177
*Get a declared annotation of method.* 匹配到的元操作或API：
logic: Get a declared annotation of method.
most similar meta operation: Get a declared annotation of method
cosine Similarity: 0.9867770671844482
*Check whether the method has Test annotation.* 匹配到的元操作或API：
logic: Check whether the method has Test annotation.
most similar meta operation: Check whether method has declared annotations
cosine Similarity: 0.8841646909713745
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8021494150161743
*Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8428394198417664
*Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method signature matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8428394198417664
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.ast.NodeStream<ASTAnnotation> getDeclaredAnnotations()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJunit3MethodSignature(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Does not check the class (use {@link #isJUnit3Class(ASTAnyTypeDeclaration)}).

1.  //Check whether method has declared annotations
```java
import net.sourceforge.pmd.lang.ast.NodeStream;
import net.sourceforge.pmd.lang.java.ast.*;
public boolean hasAnnotation(ASTMethodDeclaration node){
    NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
    return declaredAnnotations.nonEmpty();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (hasJUnitTestAnnotation(node) && !JUNIT_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean hasJUnitTestAnnotation(ASTMethodDeclaration node) {
        NodeStream<ASTAnnotation> declaredAnnotations = node.getDeclaredAnnotations();
        return declaredAnnotations.anyMatch(annotation -> annotation.getTypeReference().getName().equals("Test"));
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of class.
2. Get the methods of class.
3. Get a method of class.
4. Check whether the method has @Test annotation.
5. Get the name of method.
6. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For the first method (`get_best_team`):

1. Get the methods of class.
2. Get the method named `get_best_team`.
3. Check whether the method has @Test annotation.
4. Get the name of method `get_best_team`.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For the second method (`getBestTeam`):

1. Get the methods of class.
2. Get the method named `getBestTeam`.
3. Check whether the method has @Test annotation.
4. Get the name of method `getBestTeam`.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

If the method name `get_best_team` does not match the regex "[a-z][a-zA-Z0-9]*" and has the @Test annotation, then this method violates the rule.

In this case:
- Method `get_best_team` has the @Test annotation and its name does not match the regex "[a-z][a-zA-Z0-9]*", so it violates the rule.
- Method `getBestTeam` has the @Test annotation and its name matches the regex "[a-z][a-zA-Z0-9]*", so it does not violate the rule.
['Get the name of class.', 'Get the methods of class.', 'Get a method of class.', 'Check whether the method has @Test annotation.', 'Get the name of method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the methods of class.', 'Get the method named `get_best_team`.', 'Check whether the method has @Test annotation.', 'Get the name of method `get_best_team`.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the methods of class.', 'Get the method named `getBestTeam`.', 'Check whether the method has @Test annotation.', 'Get the name of method `getBestTeam`.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['ASTAnnotation', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Get the methods of class.* 匹配到的元操作或API：
query: Get the methods of class.
most similar API: get class of method
cosine Similarity: 0.8241114616394043
*Get a method of class.* 匹配到的元操作或API：
logic: Get a method of class.
most similar meta operation: Get the class that method located in
cosine Similarity: 0.8517357707023621
*Check whether the method has @Test annotation.* 匹配到的元操作或API：
query: Check whether the method has @Test annotation.
most similar API: Check whether the method is annotation present
cosine Similarity: 0.8498202562332153
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the methods of class.* 匹配到的元操作或API：
query: Get the methods of class.
most similar API: get class of method
cosine Similarity: 0.8241114616394043
*Get the method named `get_best_team`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method has @Test annotation.* 匹配到的元操作或API：
query: Check whether the method has @Test annotation.
most similar API: Check whether the method is annotation present
cosine Similarity: 0.8498202562332153
*Get the name of method `get_best_team`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the methods of class.* 匹配到的元操作或API：
query: Get the methods of class.
most similar API: get class of method
cosine Similarity: 0.8241114616394043
*Get the method named `getBestTeam`.* 匹配到的元操作或API：
query: Get the method named `getBestTeam`.
most similar API: get name of method
cosine Similarity: 0.80115807056427
*Check whether the method has @Test annotation.* 匹配到的元操作或API：
query: Check whether the method has @Test annotation.
most similar API: Check whether the method is annotation present
cosine Similarity: 0.8498202562332153
*Get the name of method `getBestTeam`.* 匹配到的元操作或API：
logic: Get the name of method `getBestTeam`.
most similar meta operation: Get the name of method
cosine Similarity: 0.8701591491699219
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.Class<Class<?> getClass()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration getEnclosingType()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnnotationPresent(java.lang.Class), //Returns true if an annotation with the given type is applied to this node.
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (isJUnit4TestMethod(node) && !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean isJUnit4TestMethod(ASTMethodDeclaration node) {
        return node.isAnnotationPresent(ASTAnnotation.class) && node.hasAnnotation("org.junit.Test");
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method has x annotation (Test).
3. Check whether the method is a JUnit method.
4. Get the name of called method (from the annotation import).
5. Check whether the name of called method is Test.
6. Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
7. If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.

Let's apply these checks to the provided test case:

1. Get the name of method (get_best_team).
2. Check whether the method has x annotation (Test). -> True
3. Check whether the method is a JUnit method. -> True (since it has the @Test annotation)
4. Get the name of called method (from the annotation import). -> Test
5. Check whether the name of called method is Test. -> True
6. Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*". -> False (because it contains an underscore)
7. If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.

1. Get the name of method (getBestTeam).
2. Check whether the method has x annotation (Test). -> True
3. Check whether the method is a JUnit method. -> True (since it has the @Test annotation)
4. Get the name of called method (from the annotation import). -> Test
5. Check whether the name of called method is Test. -> True
6. Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*". -> True
7. If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.

Based on these checks, the method `get_best_team` violates the rule because its name does not match the regex pattern for JUnit 4 test method names, while `getBestTeam` does not violate the rule.
['Get the name of method.', 'Check whether the method has x annotation (Test).', 'Check whether the method is a JUnit method.', 'Get the name of called method (from the annotation import).', 'Check whether the name of called method is Test.', 'Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".', 'If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.', 'Get the name of method (get_best_team).', 'Check whether the method has x annotation (Test). -> True', 'Check whether the method is a JUnit method. -> True (since it has the @Test annotation)', 'Get the name of called method (from the annotation import). -> Test', 'Check whether the name of called method is Test. -> True', 'Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*". -> False (because it contains an underscore)', 'If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.', 'Get the name of method (getBestTeam).', 'Check whether the method has x annotation (Test). -> True', 'Check whether the method is a JUnit method. -> True (since it has the @Test annotation)', 'Get the name of called method (from the annotation import). -> Test', 'Check whether the name of called method is Test. -> True', 'Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*". -> True', 'If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.']
['ASTAnnotation', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTImportDeclaration', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method has x annotation (Test).* 匹配到的元操作或API：
logic: Check whether the method has x annotation (Test).
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9577510356903076
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Get the name of called method (from the annotation import).* 匹配到的元操作或API：
logic: Get the name of called method (from the annotation import).
most similar meta operation: Get the name of called method
cosine Similarity: 0.894713819026947
*Check whether the name of called method is Test.* 匹配到的元操作或API：
query: Check whether the name of called method is Test.
most similar API: Check whether is test method
cosine Similarity: 0.8788920640945435
*Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8056954741477966
*If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method (get_best_team).* 匹配到的元操作或API：
query: Get the name of method (get_best_team).
most similar API: get name of method
cosine Similarity: 0.809440553188324
*Check whether the method has x annotation (Test). -> True* 匹配到的元操作或API：
logic: Check whether the method has x annotation (Test). -> True
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9505442380905151
*Check whether the method is a JUnit method. -> True (since it has the @Test annotation)* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method. -> True (since it has the @Test annotation)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9303842782974243
*Get the name of called method (from the annotation import). -> Test* 匹配到的元操作或API：
logic: Get the name of called method (from the annotation import). -> Test
most similar meta operation: Get the name of called method
cosine Similarity: 0.864339292049408
*Check whether the name of called method is Test. -> True* 匹配到的元操作或API：
query: Check whether the name of called method is Test. -> True
most similar API: Check whether is test method
cosine Similarity: 0.8689260482788086
*Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*". -> False (because it contains an underscore)* 匹配到的元操作或API：
未匹配成功元操作或API
*If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method (getBestTeam).* 匹配到的元操作或API：
logic: Get the name of method (getBestTeam).
most similar meta operation: Get the name of method
cosine Similarity: 0.9083284735679626
*Check whether the method has x annotation (Test). -> True* 匹配到的元操作或API：
logic: Check whether the method has x annotation (Test). -> True
most similar meta operation: Check whether the method has x annotation
cosine Similarity: 0.9505442380905151
*Check whether the method is a JUnit method. -> True (since it has the @Test annotation)* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method. -> True (since it has the @Test annotation)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9303842782974243
*Get the name of called method (from the annotation import). -> Test* 匹配到的元操作或API：
logic: Get the name of called method (from the annotation import). -> Test
most similar meta operation: Get the name of called method
cosine Similarity: 0.864339292049408
*Check whether the name of called method is Test. -> True* 匹配到的元操作或API：
query: Check whether the name of called method is Test. -> True
most similar API: Check whether is test method
cosine Similarity: 0.8689260482788086
*Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*". -> True* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*". -> True
most similar API: Check whether is junit4 method
cosine Similarity: 0.8003191351890564
*If the method name does not match the regex for JUnit 4 test method names, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// JUnit 4 test detection without proper auxclasspath
import org.junit.Test; // note: test case uses "useAuxClasspath=false"!!

public class TournamentTest {

    // wrong test name pattern
    @Test
    public void get_best_team() {
    }

    // this is ok
    @Test
    public void getBestTeam() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'TournamentTest')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'get_best_team')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'getBestTeam')
      ——ASTModifierList
        ——ASTAnnotation
          ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAnyAnnotationPresent(java.util.Collection)
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public java.lang.String getMethodName()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName(), //Returns the simple name of the method.



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 6
[ERROR]   "bad 7" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the signature of method.
3. Check whether the method is abstract.
4. Check whether the method is static.
5. Check whether the method is constructor.
6. Check whether the method is native.
7. Check whether the method is a junit method.
8. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

Perform checks for each method in the test case:

For `fooBar`:
1. Get the name of method. // fooBar
2. Get the signature of method. // fooBar()
3. Check whether the method is abstract. // false
4. Check whether the method is static. // false
5. Check whether the method is constructor. // false
6. Check whether the method is native. // false
7. Check whether the method is a junit method. // false
8. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // true (since it matches the camel case convention)

For `m_fooBar`:
1. Get the name of method. // m_fooBar
2. Get the signature of method. // m_fooBar()
3. Check whether the method is abstract. // false
4. Check whether the method is static. // false
5. Check whether the method is constructor. // false
6. Check whether the method is native. // false
7. Check whether the method is a junit method. // false
8. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false (since it starts with 'm_')

The number of methods violating the rule in this test case is: 1 (i.e., `m_fooBar`)
['Get the name of method.', 'Get the signature of method.', 'Check whether the method is abstract.', 'Check whether the method is static.', 'Check whether the method is constructor.', 'Check whether the method is native.', 'Check whether the method is a junit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method. // fooBar', 'Get the signature of method. // fooBar()', 'Check whether the method is abstract. // false', 'Check whether the method is static. // false', 'Check whether the method is constructor. // false', 'Check whether the method is native. // false', 'Check whether the method is a junit method. // false', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // true (since it matches the camel case convention)', 'Get the name of method. // m_fooBar', 'Get the signature of method. // m_fooBar()', 'Check whether the method is abstract. // false', 'Check whether the method is static. // false', 'Check whether the method is constructor. // false', 'Check whether the method is native. // false', 'Check whether the method is a junit method. // false', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false (since it starts with \'m_\')']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method is abstract.* 匹配到的元操作或API：
logic: Check whether the method is abstract.
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9833381175994873
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is constructor.* 匹配到的元操作或API：
query: Check whether the method is constructor.
most similar API: Check whether is test method
cosine Similarity: 0.8231310844421387
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // fooBar* 匹配到的元操作或API：
logic: Get the name of method. // fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8769241571426392
*Get the signature of method. // fooBar()* 匹配到的元操作或API：
logic: Get the signature of method. // fooBar()
most similar meta operation: Get the signature of method
cosine Similarity: 0.9111099243164062
*Check whether the method is abstract. // false* 匹配到的元操作或API：
logic: Check whether the method is abstract. // false
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9525656700134277
*Check whether the method is static. // false* 匹配到的元操作或API：
logic: Check whether the method is static. // false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9482631087303162
*Check whether the method is constructor. // false* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is native. // false* 匹配到的元操作或API：
logic: Check whether the method is native. // false
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9598884582519531
*Check whether the method is a junit method. // false* 匹配到的元操作或API：
logic: Check whether the method is a junit method. // false
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9505062699317932
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // true (since it matches the camel case convention)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method. // m_fooBar* 匹配到的元操作或API：
logic: Get the name of method. // m_fooBar
most similar meta operation: Get the name of method
cosine Similarity: 0.8656754493713379
*Get the signature of method. // m_fooBar()* 匹配到的元操作或API：
logic: Get the signature of method. // m_fooBar()
most similar meta operation: Get the signature of method
cosine Similarity: 0.8952671885490417
*Check whether the method is abstract. // false* 匹配到的元操作或API：
logic: Check whether the method is abstract. // false
most similar meta operation: Check whether the method is abstract
cosine Similarity: 0.9525656700134277
*Check whether the method is static. // false* 匹配到的元操作或API：
logic: Check whether the method is static. // false
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9482631087303162
*Check whether the method is constructor. // false* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method is native. // false* 匹配到的元操作或API：
logic: Check whether the method is native. // false
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9598884582519531
*Check whether the method is a junit method. // false* 匹配到的元操作或API：
logic: Check whether the method is a junit method. // false
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9505062699317932
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*". // false (since it starts with 'm_')* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isAbstract()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
5. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT45_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches() && !JUNIT45_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        } else if (!INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To analyze the adherence of the provided test case to the rule, let's perform granular checks on each method:

1. Get the name of method.
   - For `fooBar`: Get the name of method.
   - For `m_fooBar`: Get the name of method.

2. Check whether the method is a junit method.
   - For `fooBar`: Check whether the method is a junit method.
   - For `m_fooBar`: Check whether the method is a junit method.

3. Check whether the method is static.
   - For `fooBar`: Check whether the method is static.
   - For `m_fooBar`: Check whether the method is static.

4. Check whether the method is native.
   - For `fooBar`: Check whether the method is native.
   - For `m_fooBar`: Check whether the method is native.

5. Get the signature of method.
   - For `fooBar`: Get the signature of method.
   - For `m_fooBar`: Get the signature of method.

6. Check whether the method name matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".
   - For `fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - For `m_fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

7. Check whether the method name matches the regex for native method names "[a-z][a-zA-Z0-9]*".
   - For `fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - For `m_fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

8. Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".
   - For `fooBar`: Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".
   - For `m_fooBar`: Check whether the method name matches the regex "test[A-Z0-9][a-zA-Z0-9]*".

9. Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
   - For `fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
   - For `m_fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

10. Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".
    - For `fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".
    - For `m_fooBar`: Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

Let's apply these checks:

- For `fooBar`:
  1. Method name is `fooBar`.
  2. Method is not a JUnit method.
  3. Method is not static.
  4. Method is not native.
  5. Method signature is `public void fooBar()`.
  6. Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for instance methods.
  7. Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for native methods.
  8. Method name `fooBar` does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test methods.
  9. Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.
  10. Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 5 test methods.

- For `m_fooBar`:
  1. Method name is `m_fooBar`.
  2. Method is not a JUnit method.
  3. Method is not static.
  4. Method is not native.
  5. Method signature is `public void m_fooBar()`.
  6. Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for instance methods.
  7. Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for native methods.
  8. Method name `m_fooBar` does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test methods.
  9. Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.
  10. Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for JUnit 5 test methods.

Based on the checks, the method `m_fooBar` does not match the regex for instance methods "[a-z][a-zA-Z0-9]*", which indicates a violation of the rule. The method `fooBar` matches the regex and does not violate the rule.

Therefore, the number of violations in this test case is indeed 1, specifically for the method `m_fooBar`.
['Get the name of method.', 'Check whether the method is a junit method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Get the signature of method.', 'Check whether the method name matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for native method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".', 'Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".', 'Method name is `fooBar`.', 'Method is not a JUnit method.', 'Method is not static.', 'Method is not native.', 'Method signature is `public void fooBar()`.', 'Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for instance methods.', 'Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for native methods.', 'Method name `fooBar` does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test methods.', 'Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.', 'Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 5 test methods.', 'Method name is `m_fooBar`.', 'Method is not a JUnit method.', 'Method is not static.', 'Method is not native.', 'Method signature is `public void m_fooBar()`.', 'Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for instance methods.', 'Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for native methods.', 'Method name `m_fooBar` does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test methods.', 'Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.', 'Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for JUnit 5 test methods.']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is a junit method.* 匹配到的元操作或API：
logic: Check whether the method is a junit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Get the signature of method.* 匹配到的元操作或API：
logic: Get the signature of method.
most similar meta operation: Get the signature of method
cosine Similarity: 0.9827434420585632
*Check whether the method name matches the regex for instance/static method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for native method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 3 test method names "test[A-Z0-9][a-zA-Z0-9]*".
most similar API: Check whether is junit3 method
cosine Similarity: 0.8107518553733826
*Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 4 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit4 method
cosine Similarity: 0.8056954741477966
*Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
query: Check whether the method name matches the regex for JUnit 5 test method names "[a-z][a-zA-Z0-9]*".
most similar API: Check whether is junit5 method
cosine Similarity: 0.8117830753326416
*Method name is `fooBar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method is not a JUnit method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method is not static.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method is not native.* 匹配到的元操作或API：
query: Method is not native.
most similar API: Check whether the method is native
cosine Similarity: 0.8091999292373657
*Method signature is `public void fooBar()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for instance methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for native methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `fooBar` does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `fooBar` matches the regex "[a-z][a-zA-Z0-9]*" for JUnit 5 test methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name is `m_fooBar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method is not a JUnit method.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method is not static.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method is not native.* 匹配到的元操作或API：
query: Method is not native.
most similar API: Check whether the method is native
cosine Similarity: 0.8091999292373657
*Method signature is `public void m_fooBar()`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for instance methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for native methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `m_fooBar` does not match the regex "test[A-Z0-9][a-zA-Z0-9]*" for JUnit 3 test methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for JUnit 4 test methods.* 匹配到的元操作或API：
未匹配成功元操作或API
*Method name `m_fooBar` does not match the regex "[a-z][a-zA-Z0-9]*" for JUnit 5 test methods.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
6. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit3Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
7. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit4Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)
8. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnit5Method(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnit3Method(node) && !JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit4Method(node) && !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (TestFrameworksUtil.isJUnit5Method(node) && !JUNIT5_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For `fooBar` method:
6. Get the name of method.
7. Check whether the method is static.
8. Check whether the method is native.
9. Check whether the method is a JUnit method.
10. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

For `m_fooBar` method:
11. Get the name of method.
12. Check whether the method is static.
13. Check whether the method is native.
14. Check whether the method is a JUnit method.
15. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

In this test case:
- The `fooBar` method does not violate the rule because its name matches the regex "[a-z][a-zA-Z0-9]*" (it starts with a lowercase letter).
- The `m_fooBar` method violates the rule because its name does not match the regex "[a-z][a-zA-Z0-9]*" (it starts with a lowercase letter followed by an underscore).

The number of violations in this test case is: 1.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT3_TEST_METHOD_PATTERN = Pattern.compile("test[A-Z0-9][a-zA-Z0-9]*");
    private static final Pattern JUNIT4_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern JUNIT5_TEST_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            if (!JUNIT3_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT4_TEST_METHOD_PATTERN.matcher(node.getName()).matches() &&
                !JUNIT5_TEST_METHOD_PATTERN.matcher(node.getName()).matches()) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit method.
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".

Let's perform these checks on each method in the provided test case:

For method `fooBar`:
1. Get the name of method: `fooBar`
2. Check whether the method is static: `false`
3. Check whether the method is native: `false`
4. Check whether the method is a JUnit method: `false`
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": `true` (matches)

For method `m_fooBar`:
1. Get the name of method: `m_fooBar`
2. Check whether the method is static: `false`
3. Check whether the method is native: `false`
4. Check whether the method is a JUnit method: `false`
5. Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": `false` (does not match)

Based on the checks, `m_fooBar` does not match the regex for an instance method name, which is "[a-z][a-zA-Z0-9]*". Therefore, the number of methods violating the rule is 1, as stated in the test case.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".', 'Get the name of method: `fooBar`', 'Check whether the method is static: `false`', 'Check whether the method is native: `false`', 'Check whether the method is a JUnit method: `false`', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": `true` (matches)', 'Get the name of method: `m_fooBar`', 'Check whether the method is static: `false`', 'Check whether the method is native: `false`', 'Check whether the method is a JUnit method: `false`', 'Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": `false` (does not match)']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8852731585502625
*Check whether the method is static: `false`* 匹配到的元操作或API：
logic: Check whether the method is static: `false`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9453908801078796
*Check whether the method is native: `false`* 匹配到的元操作或API：
logic: Check whether the method is native: `false`
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9488310813903809
*Check whether the method is a JUnit method: `false`* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: `false`
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9452388286590576
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": `true` (matches)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method: `m_fooBar`* 匹配到的元操作或API：
logic: Get the name of method: `m_fooBar`
most similar meta operation: Get the name of method
cosine Similarity: 0.8571934103965759
*Check whether the method is static: `false`* 匹配到的元操作或API：
logic: Check whether the method is static: `false`
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9453908801078796
*Check whether the method is native: `false`* 匹配到的元操作或API：
logic: Check whether the method is native: `false`
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9488310813903809
*Check whether the method is a JUnit method: `false`* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method: `false`
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9452388286590576
*Check whether the method name matches the regex "[a-z][a-zA-Z0-9]*": `false` (does not match)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            // No additional JUnit specific pattern for JUnit 3, 4, and 5 in this rule description
        } else if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        } else if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Check whether the method is static.
3. Check whether the method is native.
4. Check whether the method is a JUnit method.
5. Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".

For the method `fooBar`:
6. Get the name of method `fooBar`.
7. Check whether the method `fooBar` is static. (False)
8. Check whether the method `fooBar` is native. (False)
9. Check whether the method `fooBar` is a JUnit method. (False)
10. Check whether the method name `fooBar` matches the regex for instance method names "[a-z][a-zA-Z0-9]*". (False)

For the method `m_fooBar`:
11. Get the name of method `m_fooBar`.
12. Check whether the method `m_fooBar` is static. (False)
13. Check whether the method `m_fooBar` is native. (False)
14. Check whether the method `m_fooBar` is a JUnit method. (False)
15. Check whether the method name `m_fooBar` matches the regex for instance method names "[a-z][a-zA-Z0-9]*". (False)

Based on the above checks, both `fooBar` and `m_fooBar` violate the rule, as their names do not match the specified regex for instance method names. Therefore, the number of violations in this test case is 2, not 1.
['Get the name of method.', 'Check whether the method is static.', 'Check whether the method is native.', 'Check whether the method is a JUnit method.', 'Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".', 'Get the name of method `fooBar`.', 'Check whether the method `fooBar` is static. (False)', 'Check whether the method `fooBar` is native. (False)', 'Check whether the method `fooBar` is a JUnit method. (False)', 'Check whether the method name `fooBar` matches the regex for instance method names "[a-z][a-zA-Z0-9]*". (False)', 'Get the name of method `m_fooBar`.', 'Check whether the method `m_fooBar` is static. (False)', 'Check whether the method `m_fooBar` is native. (False)', 'Check whether the method `m_fooBar` is a JUnit method. (False)', 'Check whether the method name `m_fooBar` matches the regex for instance method names "[a-z][a-zA-Z0-9]*". (False)']
['JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the method is static.* 匹配到的元操作或API：
logic: Check whether the method is static.
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9812488555908203
*Check whether the method is native.* 匹配到的元操作或API：
logic: Check whether the method is native.
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9861124753952026
*Check whether the method is a JUnit method.* 匹配到的元操作或API：
logic: Check whether the method is a JUnit method.
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9799772500991821
*Check whether the method name matches the regex for instance method names "[a-z][a-zA-Z0-9]*".* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method `fooBar`.* 匹配到的元操作或API：
logic: Get the name of method `fooBar`.
most similar meta operation: Get the name of method
cosine Similarity: 0.8763085007667542
*Check whether the method `fooBar` is static. (False)* 匹配到的元操作或API：
logic: Check whether the method `fooBar` is static. (False)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.9071542024612427
*Check whether the method `fooBar` is native. (False)* 匹配到的元操作或API：
logic: Check whether the method `fooBar` is native. (False)
most similar meta operation: Check whether the method is native
cosine Similarity: 0.9084636569023132
*Check whether the method `fooBar` is a JUnit method. (False)* 匹配到的元操作或API：
logic: Check whether the method `fooBar` is a JUnit method. (False)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.9001530408859253
*Check whether the method name `fooBar` matches the regex for instance method names "[a-z][a-zA-Z0-9]*". (False)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of method `m_fooBar`.* 匹配到的元操作或API：
logic: Get the name of method `m_fooBar`.
most similar meta operation: Get the name of method
cosine Similarity: 0.8506425619125366
*Check whether the method `m_fooBar` is static. (False)* 匹配到的元操作或API：
logic: Check whether the method `m_fooBar` is static. (False)
most similar meta operation: Check whether the method is static
cosine Similarity: 0.8883253931999207
*Check whether the method `m_fooBar` is native. (False)* 匹配到的元操作或API：
logic: Check whether the method `m_fooBar` is native. (False)
most similar meta operation: Check whether the method is native
cosine Similarity: 0.8951383829116821
*Check whether the method `m_fooBar` is a JUnit method. (False)* 匹配到的元操作或API：
logic: Check whether the method `m_fooBar` is a JUnit method. (False)
most similar meta operation: Check whether the method is a junit method
cosine Similarity: 0.8757282495498657
*Check whether the method name `m_fooBar` matches the regex for instance method names "[a-z][a-zA-Z0-9]*". (False)* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: This rule reports method declarations which do not match the regex that applies to their specific kind (e.g. JUnit test or native method). By default this rule uses the standard Java naming convention (Camel case). Regex which applies to instance method names is "[a-z][a-zA-Z0-9]*". Regex which applies to static method names is "[a-z][a-zA-Z0-9]*". Regex which applies to native method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 3 test method names is "test[A-Z0-9][a-zA-Z0-9]*". Regex which applies to JUnit 4 test method names is "[a-z][a-zA-Z0-9]*". Regex which applies to JUnit 5 test method names is "[a-z][a-zA-Z0-9]*".;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
```

This checker has passed this negative testcase:
class Foo {
    static void foo() {
    }

    static void st_whatever() {
    }

    // not reported
    void bar() {
    }
}
This checker has passed this negative testcase:
class Foo {
    native void foo() {
    }

    native void nt_whatever() {
    }

    // not reported
    void bar() {
    }
}


This checker is failed(false negative) on this negative test case:
```
// Instance method custom convention
public class Foo {

    public void fooBar() {
    }

    public void m_fooBar() {
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
    ——ASTMethodDeclaration (method name = 'm_fooBar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isStatic()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean isNative()
4. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJUnitMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration)



================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.regex.Pattern;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class MethodNamingConventionsRule extends AbstractJavaRulechainRule {

    private static final Pattern STATIC_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern NATIVE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");
    private static final Pattern INSTANCE_METHOD_PATTERN = Pattern.compile("[a-z][a-zA-Z0-9]*");

    public MethodNamingConventionsRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TestFrameworksUtil.isJUnitMethod(node)) {
            return super.visit(node, data);
        }
        if (node.isStatic() && !STATIC_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (node.isNative() && !NATIVE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        if (!node.isStatic() && !node.isNative() && !INSTANCE_METHOD_PATTERN.matcher(node.getName()).matches()) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
bad 7
测试用例全部通过
最终通过 7 个测试用例
正例 5 个
反例 2 个
输入token：497615
输出token：299591
结束

规则执行完毕，时间总花销： 3053.4514853954315 秒
