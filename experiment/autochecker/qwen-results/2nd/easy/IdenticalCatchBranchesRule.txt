开始

========================================== Rule IdenticalCatchBranchesRule ===========================================
一共 7 个测试用例
正例 5 个
反例 2 个
1684
1319
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branch of try statement.
2. Get the exception type of catch parameter.
3. Get the catch branch of try statement.
4. Get the exception type of catch parameter.
5. Get the catch branch of try statement.
6. Get the catch branch of try statement.
7. Check whether the catch branches have the same body.
8. If the catch branches have the same body, check whether they can be collapsed into a single multi-catch branch.

Let's perform these checks step-by-step:

1. Get the catch branch of try statement.
   - Catch branch 1: `catch (IllegalArgumentException e) { throw e; }`
   - Catch branch 2: `catch (IllegalStateException e) { throw e; }`

2. Get the exception type of catch parameter.
   - For catch branch 1: The exception type is `IllegalArgumentException`.
   - For catch branch 2: The exception type is `IllegalStateException`.

3. Get the catch branch of try statement.
   - Repeat from step 1.

4. Get the exception type of catch parameter.
   - Repeat from step 2.

5. Get the catch branch of try statement.
   - Repeat from step 1.

6. Get the catch branch of try statement.
   - Repeat from step 1.

7. Check whether the catch branches have the same body.
   - Both catch branches have the same body: `throw e;`

8. If the catch branches have the same body, check whether they can be collapsed into a single multi-catch branch.
   - The catch branches can be collapsed into a single multi-catch branch: `catch (IllegalArgumentException | IllegalStateException e) { throw e; }`

Based on these checks, the test case violates the rule because the two catch branches have identical bodies and can be collapsed into a single multi-catch branch. The number of violations is 1.
['Get the catch branch of try statement.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement.', 'Get the catch branch of try statement.', 'Check whether the catch branches have the same body.', 'If the catch branches have the same body, check whether they can be collapsed into a single multi-catch branch.', 'Get the catch branch of try statement.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement.', 'Get the exception type of catch parameter.', 'Get the catch branch of try statement.', 'Get the catch branch of try statement.', 'Check whether the catch branches have the same body.', 'If the catch branches have the same body, check whether they can be collapsed into a single multi-catch branch.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Check whether the catch branches have the same body.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the catch branches have the same body, check whether they can be collapsed into a single multi-catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the exception type of catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9756684899330139
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Get the catch branch of try statement.* 匹配到的元操作或API：
logic: Get the catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9813414812088013
*Check whether the catch branches have the same body.* 匹配到的元操作或API：
未匹配成功元操作或API
*If the catch branches have the same body, check whether they can be collapsed into a single multi-catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {

    public IdenticalCatchBranchesRule() {
        super(ASTCatchClause.class);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTCatchClause previousCatchClause = (ASTCatchClause) node.getPreviousSibling();
        if (previousCatchClause != null) {
            ASTCatchParameter currentCatchParam = node.getFirstChildOfType(ASTCatchParameter.class);
            ASTCatchParameter previousCatchParam = previousCatchClause.getFirstChildOfType(ASTCatchParameter.class);

            ASTBlock currentBlock = node.getFirstChildOfType(ASTBlock.class);
            ASTBlock previousBlock = previousCatchClause.getFirstChildOfType(ASTBlock.class);

            if (currentBlock.getNumChildren() == previousBlock.getNumChildren() && currentBlock.getNumChildren() == 1) {
                ASTThrowStatement currentThrow = currentBlock.getFirstChildOfType(ASTThrowStatement.class);
                ASTThrowStatement previousThrow = previousBlock.getFirstChildOfType(ASTThrowStatement.class);

                if (currentThrow != null && previousThrow != null) {
                    ASTVariableAccess currentVarAccess = currentThrow.getFirstChildOfType(ASTVariableAccess.class);
                    ASTVariableAccess previousVarAccess = previousThrow.getFirstChildOfType(ASTVariableAccess.class);

                    if (currentVarAccess != null && previousVarAccess != null && currentVarAccess.getName().equals(previousVarAccess.getName())) {
                        NodeStream<JClassType> currentExceptions = currentCatchParam.getAllExceptionTypes().map(ASTClassOrInterfaceType::getType);
                        NodeStream<JClassType> previousExceptions = previousCatchParam.getAllExceptionTypes().map(ASTClassOrInterfaceType::getType);

                        if (currentExceptions.allMatch(previousExceptions::contains) && previousExceptions.allMatch(currentExceptions::contains)) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of try statement.
2. Get the first catch branch.
3. Get the exception type of first catch parameter.
4. Get the catch branch body of the first catch branch.
5. Get the second catch branch.
6. Get the exception type of second catch parameter.
7. Get the catch branch body of the second catch branch.
8. Check whether the catch branch bodies of the first and second catch branches are identical.
9. Check whether the method in the catch branch body is throw.
10. Get the parameter of the throw statement in the first catch branch.
11. Check whether the type of the parameter in the throw statement of the first catch branch is the same as the type of the first catch parameter.
12. Get the parameter of the throw statement in the second catch branch.
13. Check whether the type of the parameter in the throw statement of the second catch branch is the same as the type of the second catch parameter.
14. Check whether the catch parameter types from the first and second catch branches are different.
15. Check whether both throw statements rethrow the catch parameters.

If the catch branch bodies are identical, both throw statements rethrow their respective catch parameters, and the catch parameter types are different, then this test case violates the rule.
['Get the catch branches of try statement.', 'Get the first catch branch.', 'Get the exception type of first catch parameter.', 'Get the catch branch body of the first catch branch.', 'Get the second catch branch.', 'Get the exception type of second catch parameter.', 'Get the catch branch body of the second catch branch.', 'Check whether the catch branch bodies of the first and second catch branches are identical.', 'Check whether the method in the catch branch body is throw.', 'Get the parameter of the throw statement in the first catch branch.', 'Check whether the type of the parameter in the throw statement of the first catch branch is the same as the type of the first catch parameter.', 'Get the parameter of the throw statement in the second catch branch.', 'Check whether the type of the parameter in the throw statement of the second catch branch is the same as the type of the second catch parameter.', 'Check whether the catch parameter types from the first and second catch branches are different.', 'Check whether both throw statements rethrow the catch parameters.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch branches of try statement.* 匹配到的元操作或API：
logic: Get the catch branches of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9418878555297852
*Get the first catch branch.* 匹配到的元操作或API：
query: Get the first catch branch.
most similar API: get first descendant of type of catch clause
cosine Similarity: 0.8019823431968689
*Get the exception type of first catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9258952140808105
*Get the catch branch body of the first catch branch.* 匹配到的元操作或API：
query: Get the catch branch body of the first catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8672946691513062
*Get the second catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the exception type of second catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9243422150611877
*Get the catch branch body of the second catch branch.* 匹配到的元操作或API：
query: Get the catch branch body of the second catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8488980531692505
*Check whether the catch branch bodies of the first and second catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the method in the catch branch body is throw.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the parameter of the throw statement in the first catch branch.* 匹配到的元操作或API：
logic: Get the parameter of the throw statement in the first catch branch.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8604896664619446
*Check whether the type of the parameter in the throw statement of the first catch branch is the same as the type of the first catch parameter.* 匹配到的元操作或API：
query: Check whether the type of the parameter in the throw statement of the first catch branch is the same as the type of the first catch parameter.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.841720461845398
*Get the parameter of the throw statement in the second catch branch.* 匹配到的元操作或API：
logic: Get the parameter of the throw statement in the second catch branch.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.8595189452171326
*Check whether the type of the parameter in the throw statement of the second catch branch is the same as the type of the second catch parameter.* 匹配到的元操作或API：
query: Check whether the type of the parameter in the throw statement of the second catch branch is the same as the type of the second catch parameter.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8396880626678467
*Check whether the catch parameter types from the first and second catch branches are different.* 匹配到的元操作或API：
query: Check whether the catch parameter types from the first and second catch branches are different.
most similar API: Check whether the catch parameter equals
cosine Similarity: 0.8261309266090393
*Check whether both throw statements rethrow the catch parameters.* 匹配到的元操作或API：
query: Check whether both throw statements rethrow the catch parameters.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8545565605163574
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public T getFirstDescendantOfType(java.lang.Class)
3. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
5. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
6. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)
7. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        NodeStream<ASTCatchClause> catchClauses = node.getCatchClauses();
        ASTCatchClause previousCatchClause = null;

        for (ASTCatchClause catchClause : catchClauses) {
            if (previousCatchClause != null) {
                ASTCatchParameter currentParam = catchClause.getParameter();
                ASTCatchParameter previousParam = previousCatchClause.getParameter();

                ASTThrowStatement currentThrow = catchClause.getFirstDescendantOfType(ASTThrowStatement.class);
                ASTThrowStatement previousThrow = previousCatchClause.getFirstDescendantOfType(ASTThrowStatement.class);

                if (currentParam != null && previousParam != null && currentThrow != null && previousThrow != null) {
                    if (currentParam.getImage().equals(previousParam.getImage()) && 
                        currentThrow.getImage().equals(previousThrow.getImage())) {
                        addViolation(data, catchClause);
                    }
                }
            }
            previousCatchClause = catchClause;
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of try statement.
2. Get the first catch branch of try statement.
3. Get the exception type of first catch parameter.
4. Get the catch branch of the first catch parameter.
5. Get the second catch branch of try statement.
6. Get the exception type of second catch parameter.
7. Get the catch branch of the second catch parameter.
8. Check whether the catch branches of the first and second catch parameters are identical.
9. If the catch branches are identical, then check whether they can be collapsed into a single multi-catch branch.

In this specific test case:

1. Get the catch branches of try statement.
   - There are two catch branches.
2. Get the first catch branch of try statement.
   - The first catch branch is for `IllegalArgumentException`.
3. Get the exception type of first catch parameter.
   - The exception type is `IllegalArgumentException`.
4. Get the catch branch of the first catch parameter.
   - The catch branch body is `throw e;`.
5. Get the second catch branch of try statement.
   - The second catch branch is for `IllegalStateException`.
6. Get the exception type of second catch parameter.
   - The exception type is `IllegalStateException`.
7. Get the catch branch of the second catch parameter.
   - The catch branch body is `throw e;`.
8. Check whether the catch branches of the first and second catch parameters are identical.
   - Both catch branches have the same body: `throw e;`.
9. If the catch branches are identical, then check whether they can be collapsed into a single multi-catch branch.
   - Yes, these branches can be collapsed into a single multi-catch branch like `catch (IllegalArgumentException | IllegalStateException e) { throw e; }`.

Thus, the test case violates the rule and can be collapsed into a single multi-catch branch.
['Get the catch branches of try statement.', 'Get the first catch branch of try statement.', 'Get the exception type of first catch parameter.', 'Get the catch branch of the first catch parameter.', 'Get the second catch branch of try statement.', 'Get the exception type of second catch parameter.', 'Get the catch branch of the second catch parameter.', 'Check whether the catch branches of the first and second catch parameters are identical.', 'If the catch branches are identical, then check whether they can be collapsed into a single multi-catch branch.', 'Get the catch branches of try statement.', 'Get the first catch branch of try statement.', 'Get the exception type of first catch parameter.', 'Get the catch branch of the first catch parameter.', 'Get the second catch branch of try statement.', 'Get the exception type of second catch parameter.', 'Get the catch branch of the second catch parameter.', 'Check whether the catch branches of the first and second catch parameters are identical.', 'If the catch branches are identical, then check whether they can be collapsed into a single multi-catch branch.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch branches of try statement.* 匹配到的元操作或API：
logic: Get the catch branches of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9418878555297852
*Get the first catch branch of try statement.* 匹配到的元操作或API：
logic: Get the first catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9411410093307495
*Get the exception type of first catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9258952140808105
*Get the catch branch of the first catch parameter.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch parameter.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8532068729400635
*Get the second catch branch of try statement.* 匹配到的元操作或API：
logic: Get the second catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9295694828033447
*Get the exception type of second catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9243422150611877
*Get the catch branch of the second catch parameter.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch parameter.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8500760197639465
*Check whether the catch branches of the first and second catch parameters are identical.* 匹配到的元操作或API：
query: Check whether the catch branches of the first and second catch parameters are identical.
most similar API: Check whether the catch parameter equals
cosine Similarity: 0.8439624309539795
*If the catch branches are identical, then check whether they can be collapsed into a single multi-catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the catch branches of try statement.* 匹配到的元操作或API：
logic: Get the catch branches of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9418878555297852
*Get the first catch branch of try statement.* 匹配到的元操作或API：
logic: Get the first catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9411410093307495
*Get the exception type of first catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9258952140808105
*Get the catch branch of the first catch parameter.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch parameter.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8532068729400635
*Get the second catch branch of try statement.* 匹配到的元操作或API：
logic: Get the second catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9295694828033447
*Get the exception type of second catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9243422150611877
*Get the catch branch of the second catch parameter.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch parameter.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8500760197639465
*Check whether the catch branches of the first and second catch parameters are identical.* 匹配到的元操作或API：
query: Check whether the catch branches of the first and second catch parameters are identical.
most similar API: Check whether the catch parameter equals
cosine Similarity: 0.8439624309539795
*If the catch branches are identical, then check whether they can be collapsed into a single multi-catch branch.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        Iterator<ASTCatchClause> iterator = node.getCatchClauses().iterator();
        ASTCatchClause previousCatchClause = null;

        while (iterator.hasNext()) {
            ASTCatchClause currentCatchClause = iterator.next();
            if (previousCatchClause != null && areCatchClausesIdentical(previousCatchClause, currentCatchClause)) {
                addViolation(data, currentCatchClause);
            }
            previousCatchClause = currentCatchClause;
        }
        return super.visit(node, data);
    }

    private boolean areCatchClausesIdentical(ASTCatchClause first, ASTCatchClause second) {
        ASTCatchParameter firstParam = first.getFirstChildOfType(ASTCatchParameter.class);
        ASTCatchParameter secondParam = second.getFirstChildOfType(ASTCatchParameter.class);

        if (!firstParam.getType().equals(secondParam.getType())) {
            return false;
        }

        NodeStream<ASTThrowStatement> firstThrows = first.descendants(ASTThrowStatement.class);
        NodeStream<ASTThrowStatement> secondThrows = second.descendants(ASTThrowStatement.class);

        if (firstThrows.size() != secondThrows.size()) {
            return false;
        }

        Iterator<ASTThrowStatement> firstIterator = firstThrows.iterator();
        Iterator<ASTThrowStatement> secondIterator = secondThrows.iterator();

        while (firstIterator.hasNext() && secondIterator.hasNext()) {
            ASTVariableAccess firstAccess = firstIterator.next().getFirstChildOfType(ASTVariableAccess.class);
            ASTVariableAccess secondAccess = secondIterator.next().getFirstChildOfType(ASTVariableAccess.class);

            if (firstAccess != null && secondAccess != null && !firstAccess.getName().equals(secondAccess.getName())) {
                return false;
            }
        }

        return true;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of try statement.
2. Get the first catch branch of try statement.
3. Get the second catch branch of try statement.
4. Get the parameter of the first catch branch.
5. Get the type of the parameter in the first catch branch.
6. Get the parameter of the second catch branch.
7. Get the type of the parameter in the second catch branch.
8. Get the catch branch body of the first catch branch.
9. Get the catch branch body of the second catch branch.
10. Check whether the catch branch body of the first and second catch branches are identical.

If the catch branch bodies of the first and second catch branches are identical, then this test case violates the rule.
['Get the catch branches of try statement.', 'Get the first catch branch of try statement.', 'Get the second catch branch of try statement.', 'Get the parameter of the first catch branch.', 'Get the type of the parameter in the first catch branch.', 'Get the parameter of the second catch branch.', 'Get the type of the parameter in the second catch branch.', 'Get the catch branch body of the first catch branch.', 'Get the catch branch body of the second catch branch.', 'Check whether the catch branch body of the first and second catch branches are identical.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch branches of try statement.* 匹配到的元操作或API：
logic: Get the catch branches of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9418878555297852
*Get the first catch branch of try statement.* 匹配到的元操作或API：
logic: Get the first catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9411410093307495
*Get the second catch branch of try statement.* 匹配到的元操作或API：
logic: Get the second catch branch of try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9295694828033447
*Get the parameter of the first catch branch.* 匹配到的元操作或API：
query: Get the parameter of the first catch branch.
most similar API: get parameter of catch clause: Returns the catch parameter.
cosine Similarity: 0.8344780206680298
*Get the type of the parameter in the first catch branch.* 匹配到的元操作或API：
query: Get the type of the parameter in the first catch branch.
most similar API: get type node of catch parameter
cosine Similarity: 0.8445362448692322
*Get the parameter of the second catch branch.* 匹配到的元操作或API：
query: Get the parameter of the second catch branch.
most similar API: get parameter of catch clause: Returns the catch parameter.
cosine Similarity: 0.8357701301574707
*Get the type of the parameter in the second catch branch.* 匹配到的元操作或API：
query: Get the type of the parameter in the second catch branch.
most similar API: get type node of catch parameter
cosine Similarity: 0.8434450030326843
*Get the catch branch body of the first catch branch.* 匹配到的元操作或API：
query: Get the catch branch body of the first catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8672946691513062
*Get the catch branch body of the second catch branch.* 匹配到的元操作或API：
query: Get the catch branch body of the second catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8488980531692505
*Check whether the catch branch body of the first and second catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter(), //Returns the catch parameter.
3. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode(), //Returns the type node of this catch parameter. May be a {@link ASTUnionType UnionType}.
4. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {

    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        Set<String> seenThrowStatements = new HashSet<>();
        ASTCatchClause previousCatchClause = null;

        for (ASTCatchClause catchClause : node.getCatchClauses()) {
            ASTCatchParameter parameter = catchClause.getParameter();
            ASTBlock catchBody = catchClause.getBody();

            if (catchBody.getNumChildren() == 1 && catchBody.getChild(0) instanceof ASTThrowStatement) {
                ASTThrowStatement throwStatement = catchBody.getChild(0);
                if (throwStatement.getFirstChild() instanceof ASTVariableAccess) {
                    ASTVariableAccess variableAccess = throwStatement.getFirstChild();
                    String throwStatementStr = variableAccess.getImage();

                    if (seenThrowStatements.contains(throwStatementStr)) {
                        if (previousCatchClause != null) {
                            addViolation(data, previousCatchClause);
                        }
                    }

                    seenThrowStatements.add(throwStatementStr);
                    previousCatchClause = catchClause;
                } else {
                    seenThrowStatements.clear();
                }
            } else {
                seenThrowStatements.clear();
            }
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the number of catch clauses in the try statement.
2. Get the first catch clause in the try statement.
3. Get the exception type of the first catch clause.
4. Get the catch branch of the first catch clause.
5. Get the second catch clause in the try statement.
6. Get the exception type of the second catch clause.
7. Get the catch branch of the second catch clause.
8. Compare the catch branches of the first and second catch clauses.
9. Check whether the exception types of the first and second catch clauses are different.
10. Check whether the catch branches of the first and second catch clauses are identical.
If the try statement has more than one catch clause, the exception types of the catch clauses are different, and the catch branches of the first and second catch clauses are identical, then this test case violates the rule.
['Get the number of catch clauses in the try statement.', 'Get the first catch clause in the try statement.', 'Get the exception type of the first catch clause.', 'Get the catch branch of the first catch clause.', 'Get the second catch clause in the try statement.', 'Get the exception type of the second catch clause.', 'Get the catch branch of the second catch clause.', 'Compare the catch branches of the first and second catch clauses.', 'Check whether the exception types of the first and second catch clauses are different.', 'Check whether the catch branches of the first and second catch clauses are identical.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the number of catch clauses in the try statement.* 匹配到的元操作或API：
query: Get the number of catch clauses in the try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.8890749216079712
*Get the first catch clause in the try statement.* 匹配到的元操作或API：
query: Get the first catch clause in the try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.9096366167068481
*Get the exception type of the first catch clause.* 匹配到的元操作或API：
logic: Get the exception type of the first catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8797888159751892
*Get the catch branch of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8598181009292603
*Get the second catch clause in the try statement.* 匹配到的元操作或API：
query: Get the second catch clause in the try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.8994004726409912
*Get the exception type of the second catch clause.* 匹配到的元操作或API：
logic: Get the exception type of the second catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8797162175178528
*Get the catch branch of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8568049073219299
*Compare the catch branches of the first and second catch clauses.* 匹配到的元操作或API：
query: Compare the catch branches of the first and second catch clauses.
most similar API: compare location of catch clause
cosine Similarity: 0.8446922898292542
*Check whether the exception types of the first and second catch clauses are different.* 匹配到的元操作或API：
query: Check whether the exception types of the first and second catch clauses are different.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8246552348136902
*Check whether the catch branches of the first and second catch clauses are identical.* 匹配到的元操作或API：
query: Check whether the catch branches of the first and second catch clauses are identical.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8582203984260559
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Collapsible statement
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw e;
        } catch (IllegalStateException e) { // Can be collapsed into the previous block
            throw e;
        }
    }
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTVariableAccess (referenced variable name = 'e')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses(), //Returns the catch statement nodes of this try statement. If there are none, returns an empty list.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public int compareLocation(net.sourceforge.pmd.lang.ast.Node)
5. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.List;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTCatchClause.class);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTCatchClause previousSibling = node.getPreviousSibling();
        if (previousSibling != null && areCatchClausesIdentical(previousSibling, node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean areCatchClausesIdentical(ASTCatchClause clause1, ASTCatchClause clause2) {
        ASTCatchParameter param1 = clause1.getFirstChildOfType(ASTCatchParameter.class);
        ASTCatchParameter param2 = clause2.getFirstChildOfType(ASTCatchParameter.class);

        if (!param1.getAllExceptionTypes().map(ASTClassOrInterfaceType::getImage).collect(Collectors.toList())
                .equals(param2.getAllExceptionTypes().map(ASTClassOrInterfaceType::getImage).collect(Collectors.toList()))) {
            return false;
        }

        ASTThrowStatement throw1 = clause1.getFirstChildOfType(ASTThrowStatement.class);
        ASTThrowStatement throw2 = clause2.getFirstChildOfType(ASTThrowStatement.class);

        if (throw1 == null || throw2 == null) {
            return false;
        }

        ASTVariableAccess var1 = throw1.getFirstChildOfType(ASTVariableAccess.class);
        ASTVariableAccess var2 = throw2.getFirstChildOfType(ASTVariableAccess.class);

        return var1 != null && var2 != null && var1.getImage().equals(var2.getImage());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 1
1884
1488
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of the try statement.
2. Check whether the catch branches are identical.
3. Get the exception type of the first catch branch.
4. Get the exception type of the second catch branch.
5. Check whether the exception types are different.
6. Check whether both catch branches contain a throw statement with a new RuntimeException initialized with the catch parameter.
If the catch branches are identical and contain the same throw statement with different catch parameters, then this test case violates the rule.
            
['Get the catch branches of the try statement.', 'Check whether the catch branches are identical.', 'Get the exception type of the first catch branch.', 'Get the exception type of the second catch branch.', 'Check whether the exception types are different.', 'Check whether both catch branches contain a throw statement with a new RuntimeException initialized with the catch parameter.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch branches of the try statement.* 匹配到的元操作或API：
logic: Get the catch branches of the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9282875061035156
*Check whether the catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the exception type of the first catch branch.* 匹配到的元操作或API：
query: Get the exception type of the first catch branch.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8080925941467285
*Get the exception type of the second catch branch.* 匹配到的元操作或API：
query: Get the exception type of the second catch branch.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8079708218574524
*Check whether the exception types are different.* 匹配到的元操作或API：
query: Check whether the exception types are different.
most similar API: Check whether has exception list
cosine Similarity: 0.812656581401825
*Check whether both catch branches contain a throw statement with a new RuntimeException initialized with the catch parameter.* 匹配到的元操作或API：
query: Check whether both catch branches contain a throw statement with a new RuntimeException initialized with the catch parameter.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8155069947242737
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes(), //Returns a stream of all declared exception types (expanding a union type if present). <p>Note that this is the only reliable way to inspect multi-catch clauses, as the type mirror of a {@link ASTUnionType} is not itself a {@link JIntersectionType}, but the {@link TypeSystem#lub(Collection) LUB} of the components. Since exception types cannot be interfaces, the LUB always erases to a single class supertype (eg {@link RuntimeException}).
3. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasExceptionList(net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration, [Ljava.lang.Class;)
4. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        List<ASTCatchClause> catchClauses = node.getCatchClauses().toList();
        for (int i = 0; i < catchClauses.size() - 1; i++) {
            ASTCatchClause currentClause = catchClauses.get(i);
            ASTCatchClause nextClause = catchClauses.get(i + 1);
            if (areCatchBlocksIdentical(currentClause.getCatchBlock(), nextClause.getCatchBlock())) {
                addViolation(data, currentClause);
            }
        }
        return super.visit(node, data);
    }

    private boolean areCatchBlocksIdentical(ASTBlock currentBlock, ASTBlock nextBlock) {
        List<ASTStatement> currentStatements = currentBlock.getStatements();
        List<ASTStatement> nextStatements = nextBlock.getStatements();
        if (currentStatements.size() != nextStatements.size()) {
            return false;
        }
        for (int j = 0; j < currentStatements.size(); j++) {
            if (!currentStatements.get(j).isEquivalentTo(nextStatements.get(j))) {
                return false;
            }
        }
        return true;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch clauses of the try statement.
2. Get the number of catch clauses.
3. Get the catch parameter of the first catch clause.
4. Get the type of the catch parameter of the first catch clause.
5. Get the catch parameter of the second catch clause.
6. Get the type of the catch parameter of the second catch clause.
7. Get the catch branch of the first catch clause.
8. Get the catch branch of the second catch clause.
9. Compare the catch branches to check if they are identical.

If the number of catch clauses is greater than 1 and the catch branches are identical, then this test case violates the rule.
            
['Get the catch clauses of the try statement.', 'Get the number of catch clauses.', 'Get the catch parameter of the first catch clause.', 'Get the type of the catch parameter of the first catch clause.', 'Get the catch parameter of the second catch clause.', 'Get the type of the catch parameter of the second catch clause.', 'Get the catch branch of the first catch clause.', 'Get the catch branch of the second catch clause.', 'Compare the catch branches to check if they are identical.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch clauses of the try statement.* 匹配到的元操作或API：
query: Get the catch clauses of the try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.9775608777999878
*Get the number of catch clauses.* 匹配到的元操作或API：
query: Get the number of catch clauses.
most similar API: get num children of catch clause
cosine Similarity: 0.8711758852005005
*Get the catch parameter of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch parameter of the first catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.9285116791725159
*Get the type of the catch parameter of the first catch clause.* 匹配到的元操作或API：
logic: Get the type of the catch parameter of the first catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8718441724777222
*Get the catch parameter of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch parameter of the second catch clause.
most similar meta operation: Get a parameter of catch clause
cosine Similarity: 0.9295929670333862
*Get the type of the catch parameter of the second catch clause.* 匹配到的元操作或API：
logic: Get the type of the catch parameter of the second catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8672269582748413
*Get the catch branch of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8598181009292603
*Get the catch branch of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8568049073219299
*Compare the catch branches to check if they are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses(), //Returns the catch statement nodes of this try statement. If there are none, returns an empty list.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public int getNumChildren()
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTCatchParameter getParameter()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
5. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {

    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        NodeStream<ASTCatchClause> catchClauses = node.getCatchClauses();
        List<ASTCatchClause> identicalClauses = new ArrayList<>();
        Map<String, ASTCatchClause> clauseMap = new HashMap<>();

        for (ASTCatchClause clause : catchClauses) {
            ASTCatchParameter parameter = clause.getParameter();
            String exceptionTypes = parameter.getAllExceptionTypes().map(ASTClassOrInterfaceType::getImage).sorted().collect(Collectors.joining(","));

            ASTBlock catchBlock = (ASTBlock) clause.getChild(1);
            ASTThrowStatement throwStatement = catchBlock.getFirstChildOfType(ASTThrowStatement.class);
            ASTConstructorCall constructorCall = throwStatement.getFirstChildOfType(ASTConstructorCall.class);
            ASTArgumentList argumentList = constructorCall.getFirstChildOfType(ASTArgumentList.class);
            String argumentVariable = argumentList.getFirstChildOfType(ASTVariableAccess.class).getImage();

            String key = exceptionTypes + ":" + constructorCall.getType().getImage() + ":" + argumentVariable;

            if (clauseMap.containsKey(key)) {
                identicalClauses.add(clauseMap.get(key));
                identicalClauses.add(clause);
            } else {
                clauseMap.put(key, clause);
            }
        }

        for (ASTCatchClause clause : identicalClauses) {
            addViolation(data, clause);
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch branches of the try statement.
2. Check whether there are multiple catch branches.
3. Get the body of the first catch branch.
4. Get the body of the second catch branch.
5. Check whether the bodies of the two catch branches are identical.
6. Get the exception type of the first catch branch.
7. Get the exception type of the second catch branch.
8. Check whether the exception types are different.

If there are multiple catch branches (steps 2), and the bodies of at least two of them are identical (steps 3 and 5), and the exception types are different (steps 6 and 8), then this test case violates the rule.
['Get the catch branches of the try statement.', 'Check whether there are multiple catch branches.', 'Get the body of the first catch branch.', 'Get the body of the second catch branch.', 'Check whether the bodies of the two catch branches are identical.', 'Get the exception type of the first catch branch.', 'Get the exception type of the second catch branch.', 'Check whether the exception types are different.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch branches of the try statement.* 匹配到的元操作或API：
logic: Get the catch branches of the try statement.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.9282875061035156
*Check whether there are multiple catch branches.* 匹配到的元操作或API：
query: Check whether there are multiple catch branches.
most similar API: Check whether the catch parameter is multicatch
cosine Similarity: 0.8129746317863464
*Get the body of the first catch branch.* 匹配到的元操作或API：
query: Get the body of the first catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8800575137138367
*Get the body of the second catch branch.* 匹配到的元操作或API：
query: Get the body of the second catch branch.
most similar API: get body of catch clause: Returns the body of this catch branch.
cosine Similarity: 0.8797988295555115
*Check whether the bodies of the two catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the exception type of the first catch branch.* 匹配到的元操作或API：
query: Get the exception type of the first catch branch.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8080925941467285
*Get the exception type of the second catch branch.* 匹配到的元操作或API：
query: Get the exception type of the second catch branch.
most similar API: get all exception types of catch parameter
cosine Similarity: 0.8079708218574524
*Check whether the exception types are different.* 匹配到的元操作或API：
query: Check whether the exception types are different.
most similar API: Check whether has exception list
cosine Similarity: 0.812656581401825
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public boolean isMulticatch(), //Returns true if this is a multi-catch parameter, that is, it catches several unrelated exception types at the same time. For example: <pre>catch (IllegalStateException | IllegalArgumentException e) {}</pre>
3. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this catch branch.
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes(), //Returns a stream of all declared exception types (expanding a union type if present). <p>Note that this is the only reliable way to inspect multi-catch clauses, as the type mirror of a {@link ASTUnionType} is not itself a {@link JIntersectionType}, but the {@link TypeSystem#lub(Collection) LUB} of the components. Since exception types cannot be interfaces, the LUB always erases to a single class supertype (eg {@link RuntimeException}).
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasExceptionList(net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration, [Ljava.lang.Class;)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        NodeStream<ASTCatchClause> catchClauses = node.getCatchClauses();
        Map<String, List<ASTCatchClause>> catchBodies = new HashMap<>();

        for (ASTCatchClause clause : catchClauses) {
            ASTBlock body = clause.getBody();
            String bodyText = body.getImage().trim();
            catchBodies.computeIfAbsent(bodyText, k -> new ArrayList<>()).add(clause);
        }

        for (List<ASTCatchClause> clauses : catchBodies.values()) {
            if (clauses.size() > 1) {
                ASTThrowStatement throwStatement = clauses.get(0).getBody().getFirstChild(ASTThrowStatement.class);
                if (throwStatement != null) {
                    ASTConstructorCall constructorCall = throwStatement.getFirstChild(ASTConstructorCall.class);
                    if (constructorCall != null && constructorCall.getArgumentList().size() == 1) {
                        Set<String> exceptionNames = new HashSet<>();
                        for (ASTCatchClause clause : clauses) {
                            ASTCatchParameter catchParam = clause.getFirstChild(ASTCatchParameter.class);
                            if (catchParam != null) {
                                exceptionNames.addAll(catchParam.getAllExceptionTypes().map(ASTClassOrInterfaceType::getImage).collect(Collectors.toList()));
                            }
                        }
                        if (exceptionNames.size() > 1) {
                            addViolation(data, clauses.get(0));
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the catch clauses of the try statement.
2. Get the number of catch clauses.
3. Get the catch branch of the first catch clause.
4. Get the catch branch of the second catch clause.
5. Check whether the catch branches are identical.
6. Get the exception type of the first catch clause.
7. Get the exception type of the second catch clause.
8. Check whether the exception types are different.
9. If the catch branches are identical and the exception types are different, then this test case violates the rule.

In this specific test case:
1. The catch clauses of the try statement are `catch (IllegalArgumentException e) { throw new RuntimeException(e); }` and `catch (IllegalStateException ise) { throw new RuntimeException(ise); }`.
2. There are 2 catch clauses.
3. The catch branch of the first catch clause is `throw new RuntimeException(e);`.
4. The catch branch of the second catch clause is `throw new RuntimeException(ise);`.
5. The catch branches are considered identical because they both throw a new `RuntimeException` with the caught exception as a parameter.
6. The exception type of the first catch clause is `IllegalArgumentException`.
7. The exception type of the second catch clause is `IllegalStateException`.
8. The exception types are different.
9. Since the catch branches are identical and the exception types are different, this test case violates the rule.
['Get the catch clauses of the try statement.', 'Get the number of catch clauses.', 'Get the catch branch of the first catch clause.', 'Get the catch branch of the second catch clause.', 'Check whether the catch branches are identical.', 'Get the exception type of the first catch clause.', 'Get the exception type of the second catch clause.', 'Check whether the exception types are different.', 'If the catch branches are identical and the exception types are different, then this test case violates the rule.', 'The catch clauses of the try statement are `catch (IllegalArgumentException e) { throw new RuntimeException(e); }` and `catch (IllegalStateException ise) { throw new RuntimeException(ise); }`.', 'There are 2 catch clauses.', 'The catch branch of the first catch clause is `throw new RuntimeException(e);`.', 'The catch branch of the second catch clause is `throw new RuntimeException(ise);`.', 'The catch branches are considered identical because they both throw a new `RuntimeException` with the caught exception as a parameter.', 'The exception type of the first catch clause is `IllegalArgumentException`.', 'The exception type of the second catch clause is `IllegalStateException`.', 'The exception types are different.', 'Since the catch branches are identical and the exception types are different, this test case violates the rule.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the catch clauses of the try statement.* 匹配到的元操作或API：
query: Get the catch clauses of the try statement.
most similar API: get catch clauses of try statement
cosine Similarity: 0.9775608777999878
*Get the number of catch clauses.* 匹配到的元操作或API：
query: Get the number of catch clauses.
most similar API: get num children of catch clause
cosine Similarity: 0.8711758852005005
*Get the catch branch of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8598181009292603
*Get the catch branch of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8568049073219299
*Check whether the catch branches are identical.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the exception type of the first catch clause.* 匹配到的元操作或API：
logic: Get the exception type of the first catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8797888159751892
*Get the exception type of the second catch clause.* 匹配到的元操作或API：
logic: Get the exception type of the second catch clause.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.8797162175178528
*Check whether the exception types are different.* 匹配到的元操作或API：
query: Check whether the exception types are different.
most similar API: Check whether has exception list
cosine Similarity: 0.812656581401825
*If the catch branches are identical and the exception types are different, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*The catch clauses of the try statement are `catch (IllegalArgumentException e) { throw new RuntimeException(e); }` and `catch (IllegalStateException ise) { throw new RuntimeException(ise); }`.* 匹配到的元操作或API：
query: The catch clauses of the try statement are `catch (IllegalArgumentException e) { throw new RuntimeException(e); }` and `catch (IllegalStateException ise) { throw new RuntimeException(ise); }`.
most similar API: get catch clauses of try statement
cosine Similarity: 0.8498311042785645
*There are 2 catch clauses.* 匹配到的元操作或API：
未匹配成功元操作或API
*The catch branch of the first catch clause is `throw new RuntimeException(e);`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The catch branch of the second catch clause is `throw new RuntimeException(ise);`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The catch branches are considered identical because they both throw a new `RuntimeException` with the caught exception as a parameter.* 匹配到的元操作或API：
未匹配成功元操作或API
*The exception type of the first catch clause is `IllegalArgumentException`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The exception type of the second catch clause is `IllegalStateException`.* 匹配到的元操作或API：
未匹配成功元操作或API
*The exception types are different.* 匹配到的元操作或API：
未匹配成功元操作或API
*Since the catch branches are identical and the exception types are different, this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses(), //Returns the catch statement nodes of this try statement. If there are none, returns an empty list.
2. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public int getNumChildren()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
5. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasExceptionList(net.sourceforge.pmd.lang.java.ast.ASTMethodOrConstructorDeclaration, [Ljava.lang.Class;)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        Map<String, ASTCatchClause> catchBranches = new HashMap<>();
        List<ASTCatchClause> identicalBranches = new ArrayList<>();

        for (ASTCatchClause catchClause : node.getCatchClauses()) {
            ASTCatchParameter catchParam = catchClause.getFirstChildOfType(ASTCatchParameter.class);
            String branchKey = getBranchKey(catchClause);

            if (branchKey != null) {
                if (catchBranches.containsKey(branchKey)) {
                    identicalBranches.add(catchClause);
                } else {
                    catchBranches.put(branchKey, catchClause);
                }
            }
        }

        for (ASTCatchClause clause : identicalBranches) {
            addViolation(data, clause);
        }

        return super.visit(node, data);
    }

    private String getBranchKey(ASTCatchClause catchClause) {
        ASTCatchParameter catchParam = catchClause.getFirstChildOfType(ASTCatchParameter.class);
        ASTBlock catchBlock = catchClause.getFirstChildOfType(ASTBlock.class);

        if (catchBlock == null || catchBlock.getNumChildren() != 1) {
            return null;
        }

        ASTThrowStatement throwStatement = catchBlock.getFirstChildOfType(ASTThrowStatement.class);
        if (throwStatement == null) {
            return null;
        }

        ASTConstructorCall constructorCall = throwStatement.getFirstChildOfType(ASTConstructorCall.class);
        if (constructorCall == null || constructorCall.getNumChildren() != 1) {
            return null;
        }

        ASTArgumentList argumentList = constructorCall.getFirstChildOfType(ASTArgumentList.class);
        if (argumentList == null || argumentList.getNumChildren() != 1) {
            return null;
        }

        ASTVariableAccess variableAccess = argumentList.getFirstChildOfType(ASTVariableAccess.class);
        if (variableAccess == null) {
            return null;
        }

        StringBuilder keyBuilder = new StringBuilder();
        for (ASTClassOrInterfaceType type : catchParam.getAllExceptionTypes()) {
            keyBuilder.append(type.getImage()).append(",");
        }
        keyBuilder.append(constructorCall.getFirstChildOfType(ASTClassOrInterfaceType.class).getImage());
        keyBuilder.append(variableAccess.getImage());

        return keyBuilder.toString();
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
False
==========================第5轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of the first catch parameter.
2. Get the exception type of the first catch parameter.
3. Get the catch branch of the first catch clause.
4. Get the name of the second catch parameter.
5. Get the exception type of the second catch parameter.
6. Get the catch branch of the second catch clause.
7. Check whether the catch branches of both catch clauses are identical.
8. If the catch branches are identical, check whether they are single catch clauses.
9. If both catch clauses are single catch clauses, then this test case violates the rule.

Let's apply the checks to the provided test case:

1. Get the name of the first catch parameter.
   - The name of the first catch parameter is `e`.
2. Get the exception type of the first catch parameter.
   - The exception type of the first catch parameter is `IllegalArgumentException`.
3. Get the catch branch of the first catch clause.
   - The catch branch of the first catch clause is `throw new RuntimeException(e);`.
4. Get the name of the second catch parameter.
   - The name of the second catch parameter is `ise`.
5. Get the exception type of the second catch parameter.
   - The exception type of the second catch parameter is `IllegalStateException`.
6. Get the catch branch of the second catch clause.
   - The catch branch of the second catch clause is `throw new RuntimeException(ise);`.
7. Check whether the catch branches of both catch clauses are identical.
   - The catch branches are not identical due to the different exception parameters (`e` and `ise`).
8. If the catch branches are identical, check whether they are single catch clauses.
   - This step is not applicable as the catch branches are not identical.
9. If both catch clauses are single catch clauses, then this test case violates the rule.
   - This step is not applicable as the catch branches are not identical.

However, the rule violation here is subtle. The catch branches are identical in functionality, even though the variable names are different. To check for this, we need to perform an additional check:

10. Get the expression in throw statement of the first catch branch.
    - The expression in the throw statement of the first catch branch is `new RuntimeException(e)`.
11. Get the expression in throw statement of the second catch branch.
    - The expression in the throw statement of the second catch branch is `new RuntimeException(ise)`.
12. Check whether the throw statements of both catch branches are identical in functionality.
    - The throw statements are identical in functionality as they both throw a `RuntimeException` with the respective exception as a cause.

Since the catch branches are functionally identical, this test case violates the rule. The correct style would be to collapse them into a single multi-catch branch:

```java
try {
    // do something
} catch (IllegalArgumentException | IllegalStateException e) {
    throw new RuntimeException(e);
}
```
['Get the name of the first catch parameter.', 'Get the exception type of the first catch parameter.', 'Get the catch branch of the first catch clause.', 'Get the name of the second catch parameter.', 'Get the exception type of the second catch parameter.', 'Get the catch branch of the second catch clause.', 'Check whether the catch branches of both catch clauses are identical.', 'If the catch branches are identical, check whether they are single catch clauses.', 'If both catch clauses are single catch clauses, then this test case violates the rule.', 'Get the name of the first catch parameter.', 'Get the exception type of the first catch parameter.', 'Get the catch branch of the first catch clause.', 'Get the name of the second catch parameter.', 'Get the exception type of the second catch parameter.', 'Get the catch branch of the second catch clause.', 'Check whether the catch branches of both catch clauses are identical.', 'If the catch branches are identical, check whether they are single catch clauses.', 'If both catch clauses are single catch clauses, then this test case violates the rule.', 'Get the expression in throw statement of the first catch branch.', 'Get the expression in throw statement of the second catch branch.', 'Check whether the throw statements of both catch branches are identical in functionality.']
['ASTCatchParameter', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'ASTInitializer', 'ASTThrowStatement', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTTryStatement', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'ASTCatchClause', 'TypeTestUtil']
*Get the name of the first catch parameter.* 匹配到的元操作或API：
logic: Get the name of the first catch parameter.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.9253515005111694
*Get the exception type of the first catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.922197163105011
*Get the catch branch of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8598181009292603
*Get the name of the second catch parameter.* 匹配到的元操作或API：
logic: Get the name of the second catch parameter.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.9210655689239502
*Get the exception type of the second catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9218042492866516
*Get the catch branch of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8568049073219299
*Check whether the catch branches of both catch clauses are identical.* 匹配到的元操作或API：
query: Check whether the catch branches of both catch clauses are identical.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8661767840385437
*If the catch branches are identical, check whether they are single catch clauses.* 匹配到的元操作或API：
query: If the catch branches are identical, check whether they are single catch clauses.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.853539228439331
*If both catch clauses are single catch clauses, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of the first catch parameter.* 匹配到的元操作或API：
logic: Get the name of the first catch parameter.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.9253515005111694
*Get the exception type of the first catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the first catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.922197163105011
*Get the catch branch of the first catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the first catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8598181009292603
*Get the name of the second catch parameter.* 匹配到的元操作或API：
logic: Get the name of the second catch parameter.
most similar meta operation: Get the name of catch parameter
cosine Similarity: 0.9210655689239502
*Get the exception type of the second catch parameter.* 匹配到的元操作或API：
logic: Get the exception type of the second catch parameter.
most similar meta operation: Get an exception type of  catch parameter
cosine Similarity: 0.9218042492866516
*Get the catch branch of the second catch clause.* 匹配到的元操作或API：
logic: Get the catch branch of the second catch clause.
most similar meta operation: Get a catch branch of try statement
cosine Similarity: 0.8568049073219299
*Check whether the catch branches of both catch clauses are identical.* 匹配到的元操作或API：
query: Check whether the catch branches of both catch clauses are identical.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.8661767840385437
*If the catch branches are identical, check whether they are single catch clauses.* 匹配到的元操作或API：
query: If the catch branches are identical, check whether they are single catch clauses.
most similar API: Check whether the catch clause equals
cosine Similarity: 0.853539228439331
*If both catch clauses are single catch clauses, then this test case violates the rule.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the expression in throw statement of the first catch branch.* 匹配到的元操作或API：
logic: Get the expression in throw statement of the first catch branch.
most similar meta operation: Get the expression in throw statement
cosine Similarity: 0.9320236444473267
*Get the expression in throw statement of the second catch branch.* 匹配到的元操作或API：
logic: Get the expression in throw statement of the second catch branch.
most similar meta operation: Get the expression in throw statement
cosine Similarity: 0.929379403591156
*Check whether the throw statements of both catch branches are identical in functionality.* 匹配到的元操作或API：
query: Check whether the throw statements of both catch branches are identical in functionality.
most similar API: Check whether the throw statement equals
cosine Similarity: 0.8678104281425476
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Identical catch branches use up vertical space and increase the complexity of code without adding functionality. It’s better style to collapse identical branches into a single multi-catch branch.;
The test case corresponding to the rule:
```
// Identical statements, with different exception names
class Foo {
    {
        try {
            // do something
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalStateException ise) {
            throw new RuntimeException(ise);
        }
    }
}
The description of this test case is: bad 2
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTInitializer
      ——ASTBlock
        ——ASTTryStatement
          ——ASTBlock
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'e')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'e')
          ——ASTCatchClause
            ——ASTCatchParameter
              ——ASTModifierList
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTVariableDeclaratorId (declared variable name = 'ise')
            ——ASTBlock
              ——ASTThrowStatement
                ——ASTConstructorCall
                  ——ASTClassOrInterfaceType (this is a class type)
                  ——ASTArgumentList (size = 1)
                    ——ASTVariableAccess (referenced variable name = 'ise')

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTCatchParameter: public net.sourceforge.pmd.lang.ast.NodeStream<ASTClassOrInterfaceType> getAllExceptionTypes()
3. net.sourceforge.pmd.lang.java.ast.ASTTryStatement: public net.sourceforge.pmd.lang.ast.NodeStream<ASTCatchClause> getCatchClauses()
4. net.sourceforge.pmd.lang.java.ast.ASTCatchClause: public boolean equals(java.lang.Object)
5. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
6. net.sourceforge.pmd.lang.java.ast.ASTThrowStatement: public boolean equals(java.lang.Object)



Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class IdenticalCatchBranchesRule extends AbstractJavaRulechainRule {
    public IdenticalCatchBranchesRule() {
        super(ASTTryStatement.class);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        List<ASTCatchClause> catchClauses = node.getCatchClauses().toList();
        for (int i = 0; i < catchClauses.size() - 1; i++) {
            ASTCatchClause currentClause = catchClauses.get(i);
            ASTCatchClause nextClause = catchClauses.get(i + 1);
            if (areCatchClausesIdentical(currentClause, nextClause)) {
                addViolation(data, currentClause);
            }
        }
        return super.visit(node, data);
    }

    private boolean areCatchClausesIdentical(ASTCatchClause clause1, ASTCatchClause clause2) {
        List<ASTClassOrInterfaceType> types1 = clause1.getCatchParameter().getAllExceptionTypes().toList();
        List<ASTClassOrInterfaceType> types2 = clause2.getCatchParameter().getAllExceptionTypes().toList();
        if (types1.size() != 1 || types2.size() != 1) {
            return false;
        }
        ASTThrowStatement throwStmt1 = clause1.getFirstChildOfType(ASTThrowStatement.class);
        ASTThrowStatement throwStmt2 = clause2.getFirstChildOfType(ASTThrowStatement.class);
        if (throwStmt1 == null || throwStmt2 == null) {
            return false;
        }
        ASTExpression expr1 = throwStmt1.getExpr();
        ASTExpression expr2 = throwStmt2.getExpr();
        if (!(expr1 instanceof ASTConstructorCall) || !(expr2 instanceof ASTConstructorCall)) {
            return false;
        }
        ASTConstructorCall call1 = (ASTConstructorCall) expr1;
        ASTConstructorCall call2 = (ASTConstructorCall) expr2;
        if (!call1.getType().equals(call2.getType())) {
            return false;
        }
        ASTArgumentList args1 = call1.getArguments();
        ASTArgumentList args2 = call2.getArguments();
        if (args1.size() != args2.size()) {
            return false;
        }
        for (int i = 0; i < args1.size(); i++) {
            ASTExpression arg1 = args1.getArgument(i);
            ASTExpression arg2 = args2.getArgument(i);
            if (!(arg1 instanceof ASTVariableAccess) || !(arg2 instanceof ASTVariableAccess)) {
                return false;
            }
            ASTVariableAccess varAccess1 = (ASTVariableAccess) arg1;
            ASTVariableAccess varAccess2 = (ASTVariableAccess) arg2;
            if (!varAccess1.getName().equals(clause1.getCatchParameter().getName()) || !varAccess2.getName().equals(clause2.getCatchParameter().getName())) {
                return false;
            }
        }
        return true;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成的都没通过第一个测试用例，删除此测试用例，换一个生成first checker
删除此测试用例: bad 2


======================接下来开始迭代=====================
为反例生成first checker失败
结束

规则执行完毕，时间总花销： 1974.115157365799 秒
