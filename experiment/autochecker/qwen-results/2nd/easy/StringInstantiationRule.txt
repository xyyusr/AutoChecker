开始

========================================== Rule StringInstantiationRule ===========================================
一共 10 个测试用例
正例 5 个
反例 5 个
1574
1236
==========================第1轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of field.
        2. Check whether the field is string type.
        3. Check whether the field is initialized.
        4. Check whether the field is initialized using constructor call.
        5. Get the type of object created by constructor call.
        6. Check whether the type of object is String class type.
If the field is a String type, and it is initialized using a constructor call, and the type of the object created by the constructor call is String, then this test case violates the rule.

To perform the checks for both fields `bar` and `baz`:

1. Get the name of field (for `bar`).
2. Get the type of field `bar`.
3. Check whether the field `bar` is string type.
4. Check whether the field `bar` is initialized.
5. Check whether the field `bar` is initialized using constructor call.
6. Get the type of object created by constructor call (for `bar`).
7. Check whether the type of object created by the constructor call (for `bar`) is String class type.
8. Get the name of field (for `baz`).
9. Get the type of field `baz`.
10. Check whether the field `baz` is string type.
11. Check whether the field `baz` is initialized.
12. Check whether the field `baz` is initialized using constructor call.
13. Get the type of object created by constructor call (for `baz`).
14. Check whether the type of object created by the constructor call (for `baz`) is String class type.

In this case, both `bar` and `baz` fields are initialized using the constructor call of the String class, resulting in violations of the rule.
['Get the type of field.', 'Check whether the field is string type.', 'Check whether the field is initialized.', 'Check whether the field is initialized using constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the name of field (for `bar`).', 'Get the type of field `bar`.', 'Check whether the field `bar` is string type.', 'Check whether the field `bar` is initialized.', 'Check whether the field `bar` is initialized using constructor call.', 'Get the type of object created by constructor call (for `bar`).', 'Check whether the type of object created by the constructor call (for `bar`) is String class type.', 'Get the name of field (for `baz`).', 'Get the type of field `baz`.', 'Check whether the field `baz` is string type.', 'Check whether the field `baz` is initialized.', 'Check whether the field `baz` is initialized using constructor call.', 'Get the type of object created by constructor call (for `baz`).', 'Check whether the type of object created by the constructor call (for `baz`) is String class type.']
['ASTFieldDeclaration', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTStringLiteral', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.9832500219345093
*Check whether the field is string type.* 匹配到的元操作或API：
logic: Check whether the field is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.988373875617981
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized using constructor call.* 匹配到的元操作或API：
logic: Check whether the field is initialized using constructor call.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9429682493209839
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the name of field (for `bar`).* 匹配到的元操作或API：
logic: Get the name of field (for `bar`).
most similar meta operation: Get the name of field
cosine Similarity: 0.8878014087677002
*Get the type of field `bar`.* 匹配到的元操作或API：
logic: Get the type of field `bar`.
most similar meta operation: Get the type of field
cosine Similarity: 0.8754798173904419
*Check whether the field `bar` is string type.* 匹配到的元操作或API：
logic: Check whether the field `bar` is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9014554023742676
*Check whether the field `bar` is initialized.* 匹配到的元操作或API：
logic: Check whether the field `bar` is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9106351733207703
*Check whether the field `bar` is initialized using constructor call.* 匹配到的元操作或API：
logic: Check whether the field `bar` is initialized using constructor call.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8944234251976013
*Get the type of object created by constructor call (for `bar`).* 匹配到的元操作或API：
logic: Get the type of object created by constructor call (for `bar`).
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9320535063743591
*Check whether the type of object created by the constructor call (for `bar`) is String class type.* 匹配到的元操作或API：
query: Check whether the type of object created by the constructor call (for `bar`) is String class type.
most similar API: get type of constructor call
cosine Similarity: 0.810727596282959
*Get the name of field (for `baz`).* 匹配到的元操作或API：
logic: Get the name of field (for `baz`).
most similar meta operation: Get the name of field
cosine Similarity: 0.8674048781394958
*Get the type of field `baz`.* 匹配到的元操作或API：
query: Get the type of field `baz`.
most similar API: get type system of field
cosine Similarity: 0.8005542755126953
*Check whether the field `baz` is string type.* 匹配到的元操作或API：
logic: Check whether the field `baz` is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8944159150123596
*Check whether the field `baz` is initialized.* 匹配到的元操作或API：
logic: Check whether the field `baz` is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8971560001373291
*Check whether the field `baz` is initialized using constructor call.* 匹配到的元操作或API：
logic: Check whether the field `baz` is initialized using constructor call.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.8917839527130127
*Get the type of object created by constructor call (for `baz`).* 匹配到的元操作或API：
logic: Get the type of object created by constructor call (for `baz`).
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9251224398612976
*Check whether the type of object created by the constructor call (for `baz`) is String class type.* 匹配到的元操作或API：
query: Check whether the type of object created by the constructor call (for `baz`) is String class type.
most similar API: get type of constructor call
cosine Similarity: 0.8093460202217102
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public java.lang.Class<Class<?> getType()
4. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
2.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
3.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
4.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
            for (ASTVariableDeclaratorId varId : varIds) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if ("String".equals(constructorCall.getTypeNode().getImage())) {
                        addViolation(data, varId);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized
    public boolean isInitialized(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    return true;
                }
            }
        }
        return false;
    }

    // Check whether the type of object is x class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getType());
    }

    // Get the name of field
    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the name of field.
        2. Check whether the name is bar.
        3. Get the initialization expression of field bar.
        4. Check whether the initialization expression is a constructor call.
        5. Get the type of object created by constructor call.
        6. Check whether the type of object is String class type.
        7. Check whether the constructor call is for String class with arguments.
        8. Get the name of field.
        9. Check whether the name is baz.
        10. Get the initialization expression of field baz.
        11. Check whether the initialization expression is a constructor call.
        12. Get the type of object created by constructor call.
        13. Check whether the type of object is String class type.
        14. Check whether the constructor call is for String class without arguments.
        
If the initialization expression of field bar or baz is a constructor call for the String class, then this test case violates the rule. In this test case, both fields bar and baz are initialized using a constructor call for the String class, so the rule is violated twice.
['Get the name of field.', 'Check whether the name is bar.', 'Get the initialization expression of field bar.', 'Check whether the initialization expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call is for String class with arguments.', 'Get the name of field.', 'Check whether the name is baz.', 'Get the initialization expression of field baz.', 'Check whether the initialization expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call is for String class without arguments.']
['ASTFieldDeclaration', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTStringLiteral', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of field.* 匹配到的元操作或API：
logic: Get the name of field.
most similar meta operation: Get the name of field
cosine Similarity: 0.978217363357544
*Check whether the name is bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initialization expression of field bar.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initialization expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the initialization expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9157230854034424
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call is for String class with arguments.* 匹配到的元操作或API：
logic: Check whether the constructor call is for String class with arguments.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8549314737319946
*Get the name of field.* 匹配到的元操作或API：
logic: Get the name of field.
most similar meta operation: Get the name of field
cosine Similarity: 0.978217363357544
*Check whether the name is baz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initialization expression of field baz.* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initialization expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the initialization expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9157230854034424
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call is for String class without arguments.* 匹配到的元操作或API：
query: Check whether the constructor call is for String class without arguments.
most similar API: Check whether the constructor call is anonymous class
cosine Similarity: 0.8291844129562378
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isAnonymousClass(), //Returns true if this expression defines a body, which is compiled to an anonymous class. If this method returns false.

1.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```
2.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
3.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public StringInstantiationRule() {
        super(ASTClassOrInterfaceDeclaration.class, ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        node.children(ASTConstructorCall.class).forEach(constructorCall -> {
            ASTClassOrInterfaceType typeNode = constructorCall.getTypeNode();
            if (TypeTestUtil.isA(JClassSymbol.class, typeNode) && "java.lang.String".equals(typeNode.getType().getQualifiedName())) {
                // Check if the field name is "x" (or any other logic you want to apply)
                String fieldName = getFieldName(node);
                if (fieldName != null && fieldName.equals("x")) {
                    addViolation(data, constructorCall);
                }
            }
        });
        return super.visit(node, data);
    }

    // Get the name of field
    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    // Check whether the type of object is x class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(JClassSymbol.class, node.getTypeNode());
    }

    // Check whether the argument is string type
    public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
        ASTArgumentList astArgumentList = node.getArguments();
        // select which argument to judge
        ASTExpression expression = astArgumentList.get(0);
        return TypeTestUtil.isA(String.class, expression.getTypeMirror());
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of field.
2. Check whether the field is string type.
3. Check whether the field is initialized.
4. Check whether the field is initialized to literal value.
5. Get the initialization expression of the field.
6. Check whether the initialization expression is a constructor call.
7. Get the type of object created by constructor call.
8. Check whether the type of object is String class type.
9. Repeat steps 1-8 for each field in the class.

In this specific test case:

1. Get the type of field `bar`.
2. Check whether the field is string type. (True, `bar` is of type `String`)
3. Check whether the field is initialized. (True, `bar` is initialized)
4. Check whether the field is initialized to literal value. (True, `bar` is initialized to `"bar"`)
5. Get the initialization expression of the field `bar`. (`new String("bar")`)
6. Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)
7. Get the type of object created by constructor call for `bar`. (`String`)
8. Check whether the type of object is String class type. (True, it is a `String` class type)

This indicates a violation of the rule for the field `bar`.

9. Get the type of field `baz`.
10. Check whether the field is string type. (True, `baz` is of type `String`)
11. Check whether the field is initialized. (True, `baz` is initialized)
12. Check whether the field is initialized to literal value. (False, `baz` is initialized with `new String()`)
13. Get the initialization expression of the field `baz`. (`new String()`)
14. Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)
15. Get the type of object created by constructor call for `baz`. (`String`)
16. Check whether the type of object is String class type. (True, it is a `String` class type)

This indicates a violation of the rule for the field `baz`.

Thus, the test case violates the rule twice, once for each field `bar` and `baz`.
['Get the type of field.', 'Check whether the field is string type.', 'Check whether the field is initialized.', 'Check whether the field is initialized to literal value.', 'Get the initialization expression of the field.', 'Check whether the initialization expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Repeat steps 1-8 for each field in the class.', 'Get the type of field `bar`.', 'Check whether the field is string type. (True, `bar` is of type `String`)', 'Check whether the field is initialized. (True, `bar` is initialized)', 'Check whether the field is initialized to literal value. (True, `bar` is initialized to `"bar"`)', 'Get the initialization expression of the field `bar`. (`new String("bar")`)', 'Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)', 'Get the type of object created by constructor call for `bar`. (`String`)', 'Check whether the type of object is String class type. (True, it is a `String` class type)', 'Get the type of field `baz`.', 'Check whether the field is string type. (True, `baz` is of type `String`)', 'Check whether the field is initialized. (True, `baz` is initialized)', 'Check whether the field is initialized to literal value. (False, `baz` is initialized with `new String()`)', 'Get the initialization expression of the field `baz`. (`new String()`)', 'Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)', 'Get the type of object created by constructor call for `baz`. (`String`)', 'Check whether the type of object is String class type. (True, it is a `String` class type)']
['ASTFieldDeclaration', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTStringLiteral', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.9832500219345093
*Check whether the field is string type.* 匹配到的元操作或API：
logic: Check whether the field is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.988373875617981
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized to literal value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to literal value.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9092312455177307
*Get the initialization expression of the field.* 匹配到的元操作或API：
logic: Get the initialization expression of the field.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.8814836144447327
*Check whether the initialization expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the initialization expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9157230854034424
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Repeat steps 1-8 for each field in the class.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of field `bar`.* 匹配到的元操作或API：
logic: Get the type of field `bar`.
most similar meta operation: Get the type of field
cosine Similarity: 0.8754798173904419
*Check whether the field is string type. (True, `bar` is of type `String`)* 匹配到的元操作或API：
logic: Check whether the field is string type. (True, `bar` is of type `String`)
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9197409152984619
*Check whether the field is initialized. (True, `bar` is initialized)* 匹配到的元操作或API：
logic: Check whether the field is initialized. (True, `bar` is initialized)
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9267722964286804
*Check whether the field is initialized to literal value. (True, `bar` is initialized to `"bar"`)* 匹配到的元操作或API：
logic: Check whether the field is initialized to literal value. (True, `bar` is initialized to `"bar"`)
most similar meta operation: Check whether the field is initialized to variable value
cosine Similarity: 0.8642592430114746
*Get the initialization expression of the field `bar`. (`new String("bar")`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)* 匹配到的元操作或API：
query: Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.894429087638855
*Get the type of object created by constructor call for `bar`. (`String`)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call for `bar`. (`String`)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9209440350532532
*Check whether the type of object is String class type. (True, it is a `String` class type)* 匹配到的元操作或API：
logic: Check whether the type of object is String class type. (True, it is a `String` class type)
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8581275939941406
*Get the type of field `baz`.* 匹配到的元操作或API：
query: Get the type of field `baz`.
most similar API: get type system of field
cosine Similarity: 0.8005542755126953
*Check whether the field is string type. (True, `baz` is of type `String`)* 匹配到的元操作或API：
logic: Check whether the field is string type. (True, `baz` is of type `String`)
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.9174233675003052
*Check whether the field is initialized. (True, `baz` is initialized)* 匹配到的元操作或API：
logic: Check whether the field is initialized. (True, `baz` is initialized)
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9197951555252075
*Check whether the field is initialized to literal value. (False, `baz` is initialized with `new String()`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the initialization expression of the field `baz`. (`new String()`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)* 匹配到的元操作或API：
query: Check whether the initialization expression is a constructor call. (True, it is a constructor call to `String`)
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.894429087638855
*Get the type of object created by constructor call for `baz`. (`String`)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call for `baz`. (`String`)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9034000039100647
*Check whether the type of object is String class type. (True, it is a `String` class type)* 匹配到的元操作或API：
logic: Check whether the type of object is String class type. (True, it is a `String` class type)
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8581275939941406
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.types.TypeSystem getTypeSystem()

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
2.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
3.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```
4.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
5.  //Check whether the field is initialized to variable value
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitializedToVariableValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
    }
    return false;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTConstructorCall.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
            for (ASTVariableDeclaratorId varId : varIds) {
                ASTExpression init = varId.getInitializer();
                if (init != null && init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (TypeTestUtil.isA(String.class, constructorCall.getTypeNode())) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorCall node, Object data) {
        if (TypeTestUtil.isA(String.class, node.getTypeNode())) {
            ASTFieldDeclaration fieldDeclaration = node.getNthParent(ASTFieldDeclaration.class, 1);
            if (fieldDeclaration != null) {
                addViolation(data, fieldDeclaration);
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized
    public boolean isInitialized(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
        return false;
    }

    // Get the literal value that the field is initialized to
    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            ASTExpression init = varId.getInitializer();
            if (init != null && init instanceof ASTLiteral) {
                return (ASTLiteral) init;
            }
        }
        return null;
    }

    // Check whether the type of object is x class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized to variable value
    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            ASTExpression init = varId.getInitializer();
            if (init != null && init instanceof ASTVariableAccess) {
                return true;
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮为第一个测试用例生成checker========================
=========================logics=========================
1. Get the type of field.
2. Check whether the field is string type.
3. Check whether the field is initialized.
4. Check whether the field is initialized to variable value.
5. Check whether the field is initialized to literal value.
6. Get the initialization expression of field.
7. Check whether the initialization expression is a constructor call.
8. Get the type of object created by constructor call.
9. Check whether the type of object is String class type.

For the field `bar`:
10. Get the name of field.
11. Check whether the name of field is 'bar'.
12. Repeat steps 6 to 9 for the field `bar`.

For the field `baz`:
13. Get the name of field.
14. Check whether the name of field is 'baz'.
15. Repeat steps 6 to 9 for the field `baz`.

If the field is of type String and is initialized using a constructor call, then the test case violates the rule. In this case, both `bar` and `baz` fields violate the rule, confirming the description "bad 1" and the number of violations as 2.
['Get the type of field.', 'Check whether the field is string type.', 'Check whether the field is initialized.', 'Check whether the field is initialized to variable value.', 'Check whether the field is initialized to literal value.', 'Get the initialization expression of field.', 'Check whether the initialization expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the name of field.', "Check whether the name of field is 'bar'.", 'Repeat steps 6 to 9 for the field `bar`.', 'Get the name of field.', "Check whether the name of field is 'baz'.", 'Repeat steps 6 to 9 for the field `baz`.']
['ASTFieldDeclaration', 'JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTStringLiteral', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of field.* 匹配到的元操作或API：
logic: Get the type of field.
most similar meta operation: Get the type of field
cosine Similarity: 0.9832500219345093
*Check whether the field is string type.* 匹配到的元操作或API：
logic: Check whether the field is string type.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.988373875617981
*Check whether the field is initialized.* 匹配到的元操作或API：
logic: Check whether the field is initialized.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9865798950195312
*Check whether the field is initialized to variable value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to variable value.
most similar meta operation: Check whether the field is initialized to variable value
cosine Similarity: 0.9891040325164795
*Check whether the field is initialized to literal value.* 匹配到的元操作或API：
logic: Check whether the field is initialized to literal value.
most similar meta operation: Check whether the field is initialized
cosine Similarity: 0.9092312455177307
*Get the initialization expression of field.* 匹配到的元操作或API：
logic: Get the initialization expression of field.
most similar meta operation: Get the literal value that the field is initialized to
cosine Similarity: 0.8837025165557861
*Check whether the initialization expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the initialization expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9157230854034424
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the name of field.* 匹配到的元操作或API：
logic: Get the name of field.
most similar meta operation: Get the name of field
cosine Similarity: 0.978217363357544
*Check whether the name of field is 'bar'.* 匹配到的元操作或API：
未匹配成功元操作或API
*Repeat steps 6 to 9 for the field `bar`.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of field.* 匹配到的元操作或API：
logic: Get the name of field.
most similar meta operation: Get the name of field
cosine Similarity: 0.978217363357544
*Check whether the name of field is 'baz'.* 匹配到的元操作或API：
query: Check whether the name of field is 'baz'.
most similar API: Check whether has field
cosine Similarity: 0.8024743795394897
*Repeat steps 6 to 9 for the field `baz`.* 匹配到的元操作或API：
未匹配成功元操作或API
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description, which may contain multiple violations. You just need to generate a checker that can check the violations of the given test case.

The following is a description of the rule and the corresponding counterexample test case and the AST of the counterexample test case:

Rule description: Avoid instantiating String objects.;
The test case corresponding to the rule:
```
// new 'new String's
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
The description of this test case is: bad 1
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case(nodes in checker code are better selected from this ast):
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'bar')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 1)
            ——ASTStringLiteral
    ——ASTFieldDeclaration
      ——ASTModifierList
      ——ASTClassOrInterfaceType (this is a class type)
      ——ASTVariableDeclarator
        ——ASTVariableDeclaratorId (declared variable name = 'baz')
        ——ASTConstructorCall
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTArgumentList (size = 0)

Note, when there are consecutive method calls, the last call is at the upper level of the syntax tree.

The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class StringInstantiationRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.

The rule checker could only visit nodes in test case's ast, and it would be better to select a most efficient and direct node to visit rather than visit the entry to the program if possible.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some APIs and code snippets consisting of existing APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean hasField(net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration, java.lang.String)

1.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```
2.  //Check whether the field is initialized
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitialized(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                return true;
            }
        }
    }
    return false;
}
```
3.  //Check whether the field is initialized to variable value
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
import net.sourceforge.pmd.lang.ast.NodeStream;
public boolean isInitializedToVariableValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
    }
    return false;
}
```
4.  //Get the literal value that the field is initialized to
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.ast.ASTLiteral;
import net.sourceforge.pmd.lang.ast.NodeStream;
public ASTLiteral getInitializedValue(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId varId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(varId.getName().equals("x")){
            ASTExpression init = varId.getInitializer();
            if (init != null) {
                if (init instanceof ASTLiteral) {
                    return (ASTLiteral)init;
                }
            }
        }
    }
    return null;
}
```
5.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
6.  //Get the name of field
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.ast.NodeStream;
public String getFieldName(ASTFieldDeclaration node){
    NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
    for(ASTVariableDeclaratorId variableDeclaratorId : varIds){
        // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
        if(variableDeclaratorId.getName().equals("x")){
            String variableName = variableDeclaratorId.getName();
            return variableName;
        }
    }
    return null;
}
```


Below are some edge-related APIs to help traverse abstract syntax tree, if you need, you can use them:

1. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children()
2. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> children(java.lang.Class)
3. public N getChild(int i)
4. public N getFirstChild()
5. public N getLastChild()
6. public N firstChild(java.lang.Class)
7. public int getNumChildren()
8. public int getIndexInParent()
9. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants()
10. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendants(java.lang.Class)
11. public net.sourceforge.pmd.lang.ast.NodeStream.DescendantNodeStream<JavaNode> descendantsOrSelf()
12. public N getParent()
13. public N getNthParent(int i)
14. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors()
15. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestors(java.lang.Class)
16. public net.sourceforge.pmd.lang.ast.NodeStream<JavaNode> ancestorsOrSelf()
17. public N getPreviousSibling()
18. public N getNextSibling()

Please do not use the following API:


==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized to variable value
    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Get the literal value that the field is initialized to
    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Get the name of field
    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
True
编译通过
测试用例是否通过：
True
此测试用例生成了first checker: bad 1


======================接下来开始迭代=====================
[ERROR]   "bad 2" resulted in wrong number of failures, ==> expected: <1> but was: <0>不通过
144
127
92
78
96
79
77
63
=========================error_testcase_logics=========================
1. Get the return expression in return statement.
2. Check whether the return expression is an object creation.
3. Get the type of object created by constructor call.
4. Check whether the type of object is String class type.
If the return expression is an object creation and the type of object created is String, then this test case violates the rule.
            
['Get the return expression in return statement.', 'Check whether the return expression is an object creation.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTStringLiteral', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'ASTReturnStatement', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is an object creation.* 匹配到的元操作或API：
query: Check whether the return expression is an object creation.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.8180634379386902
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized to variable value
    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Get the literal value that the field is initialized to
    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Get the name of field
    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}


This checker is failed(false negative) on this negative test case:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (TypeTestUtil.isA(String.class, node.getResultType())) {
            for (ASTReturnStatement returnStmt : node.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStmt.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the method declaration from method call.
        2. Get the body of the method.
        3. Check whether the method contains a return statement with a new String instantiation.
        If the method contains a return statement that creates a new String object, then this test case violates the rule.

To break down the specific checks for the provided test case:
1. Get the name of method.
        2. Check whether the name of method is foo.
        3. Get the return expression in return statement.
        4. Check whether the return expression is a constructor call.
        5. Get the type of object created by constructor call.
        6. Check whether the type of object is String class type.
        If the method named foo has a return statement that creates a new String object, then this test case violates the rule.
['Get the method declaration from method call.', 'Get the body of the method.', 'Check whether the method contains a return statement with a new String instantiation.', 'Get the name of method.', 'Check whether the name of method is foo.', 'Get the return expression in return statement.', 'Check whether the return expression is a constructor call.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTStringLiteral', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'ASTReturnStatement', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the method declaration from method call.* 匹配到的元操作或API：
logic: Get the method declaration from method call.
most similar meta operation: Get method declaration from method call
cosine Similarity: 0.9787436127662659
*Get the body of the method.* 匹配到的元操作或API：
query: Get the body of the method.
most similar API: get body of method
cosine Similarity: 0.9667365550994873
*Check whether the method contains a return statement with a new String instantiation.* 匹配到的元操作或API：
logic: Check whether the method contains a return statement with a new String instantiation.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.8591707944869995
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Check whether the name of method is foo.* 匹配到的元操作或API：
query: Check whether the name of method is foo.
most similar API: Check whether the method equals
cosine Similarity: 0.8457172513008118
*Get the return expression in return statement.* 匹配到的元操作或API：
logic: Get the return expression in return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9881546497344971
*Check whether the return expression is a constructor call.* 匹配到的元操作或API：
query: Check whether the return expression is a constructor call.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.9070413112640381
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized to variable value
    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Get the literal value that the field is initialized to
    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Get the name of field
    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}


This checker is failed(false negative) on this negative test case:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
3. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public boolean equals(java.lang.Object)
4. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
6. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Get method declaration from method call
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;
public ASTMethodDeclaration getMethodFromMethodCall(ASTMethodCall method){
    JMethodSymbol symbol = (JMethodSymbol)method.getMethodType().getSymbol();
    ASTMethodDeclaration declaration = symbol.tryGetNode();
    return declaration;
}
```
2.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
3.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStmt : body.getDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStmt.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isReturnValueStringType(node) && isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized to variable value
    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null && init instanceof ASTVariableAccess) {
                    return true;
                }
            }
        }
        return false;
    }

    // Get the literal value that the field is initialized to
    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null && init instanceof ASTLiteral) {
                    return (ASTLiteral) init;
                }
            }
        }
        return null;
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Get the name of field
    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                return variableDeclaratorId.getName();
            }
        }
        return null;
    }

    // Check whether the return type of method is string type
    public boolean isReturnValueStringType(ASTMethodDeclaration method) {
        return TypeTestUtil.isA(String.class, method.getResultTypeNode());
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the name of method.
2. Get the body of method.
3. Get the return statement in the method body.
4. Get the return expression in the return statement.
5. Check whether the return expression is an object creation expression.
6. Get the type of object created by constructor call.
7. Check whether the type of object is String class type.

If the return expression in the method body is an object creation expression and the type of object is String, then this test case violates the rule.
['Get the name of method.', 'Get the body of method.', 'Get the return statement in the method body.', 'Get the return expression in the return statement.', 'Check whether the return expression is an object creation expression.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTMethodDeclaration', 'ASTArgumentList', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTStringLiteral', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'ASTReturnStatement', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of method.* 匹配到的元操作或API：
logic: Get the name of method.
most similar meta operation: Get the name of method
cosine Similarity: 0.9766309261322021
*Get the body of method.* 匹配到的元操作或API：
query: Get the body of method.
most similar API: get body of method
cosine Similarity: 0.9752806425094604
*Get the return statement in the method body.* 匹配到的元操作或API：
logic: Get the return statement in the method body.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.8546717166900635
*Get the return expression in the return statement.* 匹配到的元操作或API：
logic: Get the return expression in the return statement.
most similar meta operation: Get the return expression in return statement
cosine Similarity: 0.9828119277954102
*Check whether the return expression is an object creation expression.* 匹配到的元操作或API：
query: Check whether the return expression is an object creation expression.
most similar API: Check whether the constructor call is expression
cosine Similarity: 0.8405905961990356
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    // Check whether the field is string type
    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Check whether the field is initialized to variable value
    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Get the literal value that the field is initialized to
    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    // Check whether the type of object is String class type
    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    // Get the name of field
    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            // a field declaration may have several variables, choose which one we want, here we use name to filter, you can also select other ways
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}


This checker is failed(false negative) on this negative test case:
```
// Method returning new String
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The number of violating the rule in this test case is: 1

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public java.lang.String getName()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
3. net.sourceforge.pmd.lang.java.ast.ASTReturnStatement: public net.sourceforge.pmd.lang.java.ast.ASTExpression getExpr()
4. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isExpression(), //Always returns true. This is to allow XPath queries to query like {@code /[@Expression=true()]} to match any expression, but is useless in Java code.
5. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "bad 4" resulted in wrong number of failures, ==> expected: <2> but was: <0>不通过
96
81
97
81
97
81
144
127
116
101
93
78
92
78
96
79
93
78
111
94
94
78
87
72
=========================error_testcase_logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the method caller in the constructor call.
4. Check whether the method caller is an array access.
5. Get the type of array being accessed.
6. Check whether the type of array being accessed is String array type.

Perform these checks for each instantiation of a String object in the test case:

For the first instantiation `String s = new String(arr[0]);`:

1. Get the type of object created by constructor call. (String)
2. Check whether the type of object is String class type. (True)
3. Get the method caller in the constructor call. (arr[0])
4. Check whether the method caller is an array access. (True)
5. Get the type of array being accessed. (String[])
6. Check whether the type of array being accessed is String array type. (True)

Since the type of object created is String and it is instantiated using an array access of a String array, this is a violation of the rule.

For the second instantiation `String s = new String(arr[0][0]);`:

1. Get the type of object created by constructor call. (String)
2. Check whether the type of object is String class type. (True)
3. Get the method caller in the constructor call. (arr[0][0])
4. Check whether the method caller is an array access. (True)
5. Get the type of array being accessed. (String[][])
6. Check whether the type of array being accessed is String array type. (False)
7. Get the method caller in the constructor call again. (arr[0])
8. Check whether the method caller is an array access. (True)
9. Get the type of array being accessed. (String[])
10. Check whether the type of array being accessed is String array type. (True)

Since the type of object created is String and it is instantiated using an array access of a String array (arr[0]), this is also a violation of the rule.

The number of violations is indeed 2.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the method caller in the constructor call.', 'Check whether the method caller is an array access.', 'Get the type of array being accessed.', 'Check whether the type of array being accessed is String array type.', 'Get the type of object created by constructor call. (String)', 'Check whether the type of object is String class type. (True)', 'Get the method caller in the constructor call. (arr[0])', 'Check whether the method caller is an array access. (True)', 'Get the type of array being accessed. (String[])', 'Check whether the type of array being accessed is String array type. (True)', 'Get the type of object created by constructor call. (String)', 'Check whether the type of object is String class type. (True)', 'Get the method caller in the constructor call. (arr[0][0])', 'Check whether the method caller is an array access. (True)', 'Get the type of array being accessed. (String[][])', 'Check whether the type of array being accessed is String array type. (False)', 'Get the method caller in the constructor call again. (arr[0])', 'Check whether the method caller is an array access. (True)', 'Get the type of array being accessed. (String[])', 'Check whether the type of array being accessed is String array type. (True)']
['ASTMethodCall', 'ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTVariableDeclarator', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'ASTArrayAccess', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the method caller in the constructor call.* 匹配到的元操作或API：
logic: Get the method caller in the constructor call.
most similar meta operation: Get the method caller
cosine Similarity: 0.925330638885498
*Check whether the method caller is an array access.* 匹配到的元操作或API：
logic: Check whether the method caller is an array access.
most similar meta operation: Check whether the return type of called method is array type
cosine Similarity: 0.886640191078186
*Get the type of array being accessed.* 匹配到的元操作或API：
logic: Get the type of array being accessed.
most similar meta operation: Get the type of accessed variable
cosine Similarity: 0.8667254447937012
*Check whether the type of array being accessed is String array type.* 匹配到的元操作或API：
logic: Check whether the type of array being accessed is String array type.
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.9400807619094849
*Get the type of object created by constructor call. (String)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. (String)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9796581864356995
*Check whether the type of object is String class type. (True)* 匹配到的元操作或API：
logic: Check whether the type of object is String class type. (True)
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8666315078735352
*Get the method caller in the constructor call. (arr[0])* 匹配到的元操作或API：
logic: Get the method caller in the constructor call. (arr[0])
most similar meta operation: Get the method caller
cosine Similarity: 0.8890544176101685
*Check whether the method caller is an array access. (True)* 匹配到的元操作或API：
logic: Check whether the method caller is an array access. (True)
most similar meta operation: Check whether the return type of called method is array type
cosine Similarity: 0.8903481960296631
*Get the type of array being accessed. (String[])* 匹配到的元操作或API：
logic: Get the type of array being accessed. (String[])
most similar meta operation: Check whether the accessed variable is array type
cosine Similarity: 0.8518955707550049
*Check whether the type of array being accessed is String array type. (True)* 匹配到的元操作或API：
logic: Check whether the type of array being accessed is String array type. (True)
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.9390586018562317
*Get the type of object created by constructor call. (String)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. (String)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9796581864356995
*Check whether the type of object is String class type. (True)* 匹配到的元操作或API：
logic: Check whether the type of object is String class type. (True)
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8666315078735352
*Get the method caller in the constructor call. (arr[0][0])* 匹配到的元操作或API：
logic: Get the method caller in the constructor call. (arr[0][0])
most similar meta operation: Get the method caller
cosine Similarity: 0.8837077021598816
*Check whether the method caller is an array access. (True)* 匹配到的元操作或API：
logic: Check whether the method caller is an array access. (True)
most similar meta operation: Check whether the return type of called method is array type
cosine Similarity: 0.8903481960296631
*Get the type of array being accessed. (String[][])* 匹配到的元操作或API：
query: Get the type of array being accessed. (String[][])
most similar API: get type of array access
cosine Similarity: 0.9245048761367798
*Check whether the type of array being accessed is String array type. (False)* 匹配到的元操作或API：
logic: Check whether the type of array being accessed is String array type. (False)
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.9313024282455444
*Get the method caller in the constructor call again. (arr[0])* 匹配到的元操作或API：
logic: Get the method caller in the constructor call again. (arr[0])
most similar meta operation: Get the method caller
cosine Similarity: 0.8708517551422119
*Check whether the method caller is an array access. (True)* 匹配到的元操作或API：
logic: Check whether the method caller is an array access. (True)
most similar meta operation: Check whether the return type of called method is array type
cosine Similarity: 0.8903481960296631
*Get the type of array being accessed. (String[])* 匹配到的元操作或API：
logic: Get the type of array being accessed. (String[])
most similar meta operation: Check whether the accessed variable is array type
cosine Similarity: 0.8518955707550049
*Check whether the type of array being accessed is String array type. (True)* 匹配到的元操作或API：
logic: Check whether the type of array being accessed is String array type. (True)
most similar meta operation: Check whether the array is string type
cosine Similarity: 0.9390586018562317
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }
}
```

This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}


This checker is failed(false negative) on this negative test case:
```
// #2141 [java] StringInstatiation: False negative with String-array access
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}
The number of violating the rule in this test case is: 2

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'bar')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'arr')
            ——ASTMethodCall (called method name = 'getArray')
              ——ASTArgumentList (size = 0)
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 's')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTArrayAccess
                  ——ASTVariableAccess (referenced variable name = 'arr')
                  ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 's2')
            ——ASTArrayAccess
              ——ASTVariableAccess (referenced variable name = 'arr')
              ——ASTNumericLiteral
    ——ASTMethodDeclaration (method name = 'bar2')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'arr')
            ——ASTMethodCall (called method name = 'getArray2')
              ——ASTArgumentList (size = 0)
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 's')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTArrayAccess
                  ——ASTArrayAccess
                    ——ASTVariableAccess (referenced variable name = 'arr')
                    ——ASTNumericLiteral
                  ——ASTNumericLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to check this negative test case as well as those passed test cases.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTExpression getQualifier()
3. net.sourceforge.pmd.lang.java.ast.ASTVariableAccess: public net.sourceforge.pmd.lang.java.types.JTypeMirror getTypeMirror()
4. net.sourceforge.pmd.lang.java.ast.ASTArrayAccess: public java.lang.Class<Class<?> getType()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Check whether the return type of called method is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.JMethodSig;
public boolean isReturnArrayType(ASTMethodCall call) {
    JMethodSig m = call.getMethodType();
    return m.getReturnType().isArray();
}
```
3.  //Check whether the array is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isArrayStringType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTClassOrInterfaceType){
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType)astType;
            return TypeTestUtil.isA(String.class, classOrInterfaceType);
        }
    }
    return false;
}
```
4.  //Check whether the accessed variable is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableAccess;
public boolean isVariableAccessArrayType(ASTVariableAccess var) {
    return var.getTypeMirror().isArray();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 2" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
97
81
97
81
144
127
116
101
92
78
96
79
94
79
93
78
88
73
111
94
94
78
87
72
99
82
95
78
=========================error_testcase_logics=========================
To ascertain whether the test case adheres to the rule "Avoid instantiating String objects," we need to check if any instances of `String` are created using the `new` keyword. In this case, the test case uses a multi-parameter constructor of the `String` class.

Let's perform the granular checks:

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Check whether the constructor call uses the new keyword.

If the type of object created by the constructor call is `String` and it uses the `new` keyword, then this test case violates the rule.

Let's apply these checks to the provided test case:

1. Get the type of object created by constructor call.
        - The type of object created by the constructor call is `String`.

2. Check whether the type of object is String class type.
        - Yes, the type of object is `String` class type.

3. Check whether the constructor call uses the new keyword.
        - Yes, the constructor call uses the `new` keyword.

Given these checks, the test case does violate the rule "Avoid instantiating String objects" because it creates a new `String` object using the `new` keyword with a multi-parameter constructor. Therefore, the number of violations in this test case is: 1.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call uses the new keyword.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call uses the new keyword.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTFieldAccess', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call uses the new keyword.* 匹配到的元操作或API：
query: Check whether the constructor call uses the new keyword.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8230788707733154
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call uses the new keyword.* 匹配到的元操作或API：
query: Check whether the constructor call uses the new keyword.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8230788707733154
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        ASTClassOrInterfaceType typeNode = constructorCall.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            NodeStream<ASTArgumentList> arguments = constructorCall.getArguments();
            return arguments.map(ASTArgumentList::size).allMatch(size -> size == 1 || size == 3);
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
Let's perform granular checks to ascertain the compliance of the test case with the rule "Avoid instantiating String objects."

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the number of arguments of called method.
4. Check whether the number of arguments is greater than 0.
5. Check whether the method call is a String constructor.

Here's the detailed check process for the provided test case:

1. Get the type of object created by constructor call.
        - In the test case, the object created is of type String.

2. Check whether the type of object is String class type.
        - The type of the object created is indeed String.

3. Get the number of arguments of called method.
        - The constructor call `new String(bytes, 0, bytes.length)` has three arguments.

4. Check whether the number of arguments is greater than 0.
        - The number of arguments is 3, which is greater than 0.

5. Check whether the method call is a String constructor.
        - The method call is indeed a String constructor.

Since the test case involves the instantiation of a String object using a constructor, the rule is violated. Therefore, the number of violations in this test case is 1, not 0.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is greater than 0.', 'Check whether the method call is a String constructor.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is greater than 0.', 'Check whether the method call is a String constructor.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTFieldAccess', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments is greater than 0.* 匹配到的元操作或API：
query: Check whether the number of arguments is greater than 0.
most similar API: Check whether the argument list is empty
cosine Similarity: 0.810643196105957
*Check whether the method call is a String constructor.* 匹配到的元操作或API：
logic: Check whether the method call is a String constructor.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9065110087394714
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments is greater than 0.* 匹配到的元操作或API：
query: Check whether the number of arguments is greater than 0.
most similar API: Check whether the argument list is empty
cosine Similarity: 0.810643196105957
*Check whether the method call is a String constructor.* 匹配到的元操作或API：
logic: Check whether the method call is a String constructor.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.9065110087394714
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTArgumentList: public boolean isEmpty()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall) && constructorCall.getArguments().size() == 1) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall) && constructorCall.getArguments().size() == 1) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall) && constructorCall.getArguments().size() == 1) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <2> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <2> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the signature of the called constructor.
4. Check whether the signature of the called constructor matches any of the String constructors that instantiate a String object (e.g., `new String(byte[])`, `new String(byte[], int, int)`).

If the type of object created is String and the constructor signature is one of the ones that instantiate a String object, then this test case violates the rule.

In this test case:

- The object created by the constructor call is of type String.
- The constructor signature matches `new String(byte[], int, int)` which instantiates a String object.

Therefore, the number of violations of the rule in this test case is: 1
['Get the object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called constructor.', 'Check whether the signature of the called constructor matches any of the String constructors that instantiate a String object (e.g., `new String(byte[])`, `new String(byte[], int, int)`).']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTFieldAccess', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the object created by constructor call.* 匹配到的元操作或API：
logic: Get the object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8863864541053772
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called constructor.* 匹配到的元操作或API：
logic: Get the signature of the called constructor.
most similar meta operation: Get the signature of constructor
cosine Similarity: 0.9390827417373657
*Check whether the signature of the called constructor matches any of the String constructors that instantiate a String object (e.g., `new String(byte[])`, `new String(byte[], int, int)`).* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall) && !isMultipleParameterStringConstructor(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall) && !isMultipleParameterStringConstructor(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall) && !isMultipleParameterStringConstructor(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isMultipleParameterStringConstructor(ASTConstructorCall constructorCall) {
        NodeStream<ASTExpression> arguments = constructorCall.getArguments();
        return arguments.size() != 1;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
Let's analyze the test case to determine if it adheres to the rule of avoiding instantiating String objects.

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Check whether the constructor call uses a multiple parameter constructor.
4. Check whether the constructor call has a single parameter of type String.

In the provided test case:
1. Get the type of object created by constructor call. (The object created is of type `String`)
2. Check whether the type of object is String class type. (Yes, it is `String`)
3. Check whether the constructor call uses a multiple parameter constructor. (Yes, it uses `new String(bytes, 0, bytes.length)`)
4. Check whether the constructor call has a single parameter of type String. (No, it does not use a single parameter of type `String`)

Since the test case creates a `String` object using a multiple parameter constructor (`new String(bytes, 0, bytes.length)`), it does indeed instantiate a `String` object, which violates the rule.

The number of violations in this test case is: 1
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call uses a multiple parameter constructor.', 'Check whether the constructor call has a single parameter of type String.', 'Get the type of object created by constructor call. (The object created is of type `String`)', 'Check whether the type of object is String class type. (Yes, it is `String`)', 'Check whether the constructor call uses a multiple parameter constructor. (Yes, it uses `new String(bytes, 0, bytes.length)`)', 'Check whether the constructor call has a single parameter of type String. (No, it does not use a single parameter of type `String`)']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTFieldAccess', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call uses a multiple parameter constructor.* 匹配到的元操作或API：
query: Check whether the constructor call uses a multiple parameter constructor.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8349509835243225
*Check whether the constructor call has a single parameter of type String.* 匹配到的元操作或API：
query: Check whether the constructor call has a single parameter of type String.
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8103663921356201
*Get the type of object created by constructor call. (The object created is of type `String`)* 匹配到的元操作或API：
logic: Get the type of object created by constructor call. (The object created is of type `String`)
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9673123955726624
*Check whether the type of object is String class type. (Yes, it is `String`)* 匹配到的元操作或API：
logic: Check whether the type of object is String class type. (Yes, it is `String`)
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.8607432842254639
*Check whether the constructor call uses a multiple parameter constructor. (Yes, it uses `new String(bytes, 0, bytes.length)`)* 匹配到的元操作或API：
未匹配成功元操作或API
*Check whether the constructor call has a single parameter of type String. (No, it does not use a single parameter of type `String`)* 匹配到的元操作或API：
query: Check whether the constructor call has a single parameter of type String. (No, it does not use a single parameter of type `String`)
most similar API: Check whether the constructor call equals
cosine Similarity: 0.8207531571388245
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean equals(java.lang.Object)

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringInstantiation(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringInstantiation(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringInstantiation(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringInstantiation(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        if (TypeTestUtil.isA(String.class, typeNode)) {
            ASTArgumentList argumentList = node.getArguments();
            return argumentList.getArgumentCount() == 1;
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To ascertain the adherence of the provided test case to the rule "Avoid instantiating String objects," we need to check for any instantiation of `String` using the `new` keyword. Here are the granular checks:

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the number of arguments of called method.

Let's apply these checks to the test case:

1. Get the type of object created by constructor call.
   - The constructor call is `new String(bytes, 0, bytes.length)`.
   - The type of object created is `String`.

2. Check whether the type of object is String class type.
   - The type of object is indeed `String`.

3. Get the number of arguments of called method.
   - The number of arguments in the constructor call `new String(bytes, 0, bytes.length)` is 3.

Since the test case contains an instantiation of a `String` object using the `new` keyword, it violates the rule. The number of violations in this test case is 1, not 0.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTFieldAccess', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using multiple parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 3)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall) && isSingleArgumentStringConstructor(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall) && isSingleArgumentStringConstructor(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall) && isSingleArgumentStringConstructor(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isSingleArgumentStringConstructor(ASTConstructorCall constructorCall) {
        ASTArgumentList arguments = constructorCall.getArguments();
        return arguments.size() == 1;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <2> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "bad 1" resulted in wrong number of failures, ==> expected: <2> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 2
[ERROR]   "ok 3" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
97
81
97
81
144
127
116
101
92
78
96
79
94
79
93
78
88
73
111
94
94
78
87
72
99
82
95
78
=========================error_testcase_logics=========================
Let's analyze the test case to check if it adheres to the rule:

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the signature of the called method.
4. Check whether the signature of the called method matches the String constructor with a specific signature (e.g., `new String(byte[] bytes, int offset, int length, String charsetName)`).

If the type of object created by the constructor call is `String` and the signature matches the specific constructor used for string instantiation, then the test case violates the rule.

Given the test case:
```java
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
```

Let's perform the checks:

1. Get the type of object created by constructor call.
   - The type of object created by the constructor call is `String`.

2. Check whether the type of object is String class type.
   - Yes, the type of object is `String`.

3. Get the signature of the called method.
   - The signature of the called method is `String(byte[] bytes, int offset, int length, String charsetName)`.

4. Check whether the signature of the called method matches the String constructor with a specific signature.
   - Yes, the signature matches the specific constructor used for string instantiation.

Since all checks indicate that the test case is instantiating a `String` object using a constructor call, the test case violates the rule. Therefore, the number of violations in this test case is: 1.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method.', 'Check whether the signature of the called method matches the String constructor with a specific signature (e.g., `new String(byte[] bytes, int offset, int length, String charsetName)`).', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method.', 'Check whether the signature of the called method matches the String constructor with a specific signature.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTStringLiteral', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTFieldAccess', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the signature of the called method matches the String constructor with a specific signature (e.g., `new String(byte[] bytes, int offset, int length, String charsetName)`).* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the signature of the called method matches the String constructor with a specific signature.* 匹配到的元操作或API：
query: Check whether the signature of the called method matches the String constructor with a specific signature.
most similar API: Check whether is junit3 method signature
cosine Similarity: 0.8183194398880005
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using 4 parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 4)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isJunit3MethodSignature(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Does not check the class (use {@link #isJUnit3Class(ASTAnyTypeDeclaration)}).

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall) && !isSpecialStringConstructor(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall) && !isSpecialStringConstructor(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall) && !isSpecialStringConstructor(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isSpecialStringConstructor(ASTConstructorCall constructorCall) {
        JConstructorSymbol constructorSymbol = constructorCall.getConstructorSymbol();
        if (constructorSymbol != null) {
            JTypeMirror[] parameterTypes = constructorSymbol.getParameterTypes();
            return parameterTypes.length != 1;
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the signature of the called method.
4. Check whether the called method is a constructor.
5. Get the number of arguments of called method.
6. Check whether the number of arguments is 4.
7. Get an argument of called method.
8. Check whether the argument is an array type.
9. Get the type of argument.
10. Check whether the type is byte class type.
11. Get an argument of called method.
12. Check whether the argument is int type.
13. Get an argument of called method.
14. Check whether the argument is int type.
15. Get an argument of called method.
16. Check whether the argument is a string type.

If the type of object created by the constructor call is String and the number of arguments is 4 and the arguments include a byte array, two int values, and a string, then this test case violates the rule.

In this specific test case:
- The type of object created by the constructor call is String (Check 2: True).
- The called method is a constructor (Check 3: True).
- The number of arguments is 4 (Check 5: True).
- The first argument is a byte array (Checks 7, 8, 9, 10: True).
- The second and third arguments are int types (Checks 11, 12, 13: True).
- The fourth argument is a string type (Checks 14, 15, 16: True).

Therefore, the test case does violate the rule.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method.', 'Check whether the called method is a constructor.', 'Get the number of arguments of called method.', 'Check whether the number of arguments is 4.', 'Get an argument of called method.', 'Check whether the argument is an array type.', 'Get the type of argument.', 'Check whether the type is byte class type.', 'Get an argument of called method.', 'Check whether the argument is int type.', 'Get an argument of called method.', 'Check whether the argument is int type.', 'Get an argument of called method.', 'Check whether the argument is a string type.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTStringLiteral', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTFieldAccess', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method.* 匹配到的元操作或API：
logic: Get the signature of the called method.
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.9828987717628479
*Check whether the called method is a constructor.* 匹配到的元操作或API：
query: Check whether the called method is a constructor.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8676870465278625
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments is 4.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is an array type.* 匹配到的元操作或API：
logic: Check whether the argument is an array type.
most similar meta operation: Check whether the argument is array type
cosine Similarity: 0.9832896590232849
*Get the type of argument.* 匹配到的元操作或API：
logic: Get the type of argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9841679334640503
*Check whether the type is byte class type.* 匹配到的元操作或API：
logic: Check whether the type is byte class type.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.8853492140769958
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is int type.* 匹配到的元操作或API：
logic: Check whether the argument is int type.
most similar meta operation: Check whether the argument is int type
cosine Similarity: 0.9880861043930054
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is int type.* 匹配到的元操作或API：
logic: Check whether the argument is int type.
most similar meta operation: Check whether the argument is int type
cosine Similarity: 0.9880861043930054
*Get an argument of called method.* 匹配到的元操作或API：
logic: Get an argument of called method.
most similar meta operation: Get an argument of called method
cosine Similarity: 0.9816714525222778
*Check whether the argument is a string type.* 匹配到的元操作或API：
logic: Check whether the argument is a string type.
most similar meta operation: Check whether the argument is string type
cosine Similarity: 0.9842549562454224
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isVariableAccessStringType(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isVariableAccessStringType(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// using 4 parameter constructor
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 4)
                ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTNumericLiteral
                ——ASTFieldAccess
                  ——ASTVariableAccess (referenced variable name = 'bytes')
                ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()
3. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the argument is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
public boolean isMethodCallArgumentArrayType(ASTMethodCall node) {
   ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isArray();
}
```
4.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
5.  //Check whether the argument is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentByteType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```
6.  //Check whether the argument is int type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentIntType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.INT);
}
```
7.  //Check whether the argument is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallArgumentStringType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return TypeTestUtil.isA(String.class, expression.getTypeMirror());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
True
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
97
81
97
81
144
127
116
101
92
78
96
79
94
79
93
78
88
73
111
94
94
78
87
72
99
82
=========================error_testcase_logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the number of formal parameters of called method.
4. Check whether the number of formal parameters is 1.
5. Get the type of formal parameter of constructor call.
6. Check whether the formal parameter is array type.
7. Check whether the array is byte type.
If the type of object created by constructor call is String and the number of formal parameters is 1 and the formal parameter is a byte array, then this instantiation is allowed by the rule.
8. Check whether the type of object created by constructor call is String class type.
9. Get the number of formal parameters of called method.
10. Check whether the number of formal parameters is 0.
If the type of object created by constructor call is String and the number of formal parameters is 0, then this instantiation violates the rule.
11. Check whether the type of object created by constructor call is String class type.
12. Get the number of formal parameters of called method.
13. Check whether the number of formal parameters is greater than 0.
14. Get the type of formal parameter of constructor call.
15. Check whether the formal parameter is not byte array.
If the type of object created by constructor call is String and the number of formal parameters is greater than 0 and the formal parameter is not a byte array, then this instantiation violates the rule.

In this test case:
8. The type of object created by constructor call is String class type.
9. The number of formal parameters of called method is 1.
10. The number of formal parameters is 1.
11. The type of formal parameter of constructor call is array type.
12. The array is byte type.

Since the instantiation uses a byte array as a parameter, it does not violate the rule. The number of violations in this test case is: 0.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of formal parameters of called method.', 'Check whether the number of formal parameters is 1.', 'Get the type of formal parameter of constructor call.', 'Check whether the formal parameter is array type.', 'Check whether the array is byte type.', 'Check whether the type of object created by constructor call is String class type.', 'Get the number of formal parameters of called method.', 'Check whether the number of formal parameters is 0.', 'Check whether the type of object created by constructor call is String class type.', 'Get the number of formal parameters of called method.', 'Check whether the number of formal parameters is greater than 0.', 'Get the type of formal parameter of constructor call.', 'Check whether the formal parameter is not byte array.', 'The type of object created by constructor call is String class type.', 'The number of formal parameters of called method is 1.', 'The number of formal parameters is 1.', 'The type of formal parameter of constructor call is array type.', 'The array is byte type.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of formal parameters of called method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of called method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.958634078502655
*Check whether the number of formal parameters is 1.* 匹配到的元操作或API：
query: Check whether the number of formal parameters is 1.
most similar API: Check whether the formal parameters equals
cosine Similarity: 0.8373568058013916
*Get the type of formal parameter of constructor call.* 匹配到的元操作或API：
logic: Get the type of formal parameter of constructor call.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9114800095558167
*Check whether the formal parameter is array type.* 匹配到的元操作或API：
logic: Check whether the formal parameter is array type.
most similar meta operation: Check whether the formal parameter is array type
cosine Similarity: 0.9873113036155701
*Check whether the array is byte type.* 匹配到的元操作或API：
logic: Check whether the array is byte type.
most similar meta operation: Check whether the array is byte type
cosine Similarity: 0.9893491268157959
*Check whether the type of object created by constructor call is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is String class type.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8867563009262085
*Get the number of formal parameters of called method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of called method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.958634078502655
*Check whether the number of formal parameters is 0.* 匹配到的元操作或API：
query: Check whether the number of formal parameters is 0.
most similar API: Check whether the formal parameters is empty
cosine Similarity: 0.8812506198883057
*Check whether the type of object created by constructor call is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is String class type.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8867563009262085
*Get the number of formal parameters of called method.* 匹配到的元操作或API：
logic: Get the number of formal parameters of called method.
most similar meta operation: Get the number of formal parameters of method
cosine Similarity: 0.958634078502655
*Check whether the number of formal parameters is greater than 0.* 匹配到的元操作或API：
query: Check whether the number of formal parameters is greater than 0.
most similar API: Check whether the formal parameters is empty
cosine Similarity: 0.8644096851348877
*Get the type of formal parameter of constructor call.* 匹配到的元操作或API：
logic: Get the type of formal parameter of constructor call.
most similar meta operation: Get the type of formal parameter
cosine Similarity: 0.9114800095558167
*Check whether the formal parameter is not byte array.* 匹配到的元操作或API：
logic: Check whether the formal parameter is not byte array.
most similar meta operation: Check whether the formal parameter is byte type
cosine Similarity: 0.9387964010238647
*The type of object created by constructor call is String class type.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of formal parameters of called method is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of formal parameters is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of formal parameter of constructor call is array type.* 匹配到的元操作或API：
未匹配成功元操作或API
*The array is byte type.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTFormalParameters: public boolean equals(java.lang.Object)
3. net.sourceforge.pmd.lang.java.ast.ASTFormalParameter: public net.sourceforge.pmd.lang.java.ast.ASTType getTypeNode()
4. net.sourceforge.pmd.lang.java.ast.ASTFormalParameters: public boolean isEmpty()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of formal parameters of method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getFormalParametersNumber(ASTMethodDeclaration node){
    ASTFormalParameters formalParameters = node.getFormalParameters();
    return formalParameters.size();
}
```
3.  //Check whether the formal parameter is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
public boolean isFormalParameterArrayType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    return type.getTypeMirror().isArray();
}
```
4.  //Check whether the array is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isArrayByteType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTPrimitiveType){
            ASTPrimitiveType primitiveType = (ASTPrimitiveType)astType;
            if(primitiveType.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)){
                return true;
            }
        }
    }
    return false;
}
```
5.  //Check whether the formal parameter is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isFormalParameterByteType(ASTFormalParameter node) {
    ASTType type = node.getTypeNode();
    JTypeMirror t = type.getTypeMirror();
    return t.isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the object created by the constructor call.
2. Check whether the type of the object is String class type.
3. Get the arguments of the constructor call.
4. Check the number of arguments of the constructor call.
5. Get the type of the first argument.
6. Check whether the type of the first argument is byte array type.

If the type of the object created by the constructor call is String and the number of arguments is 1 and the type of the first argument is byte array, then this test case does not violate the rule.

In this test case:
1. The object created by the constructor call is of type String.
2. The constructor call has 1 argument.
3. The type of the first argument is byte array.

Therefore, the number of violations of the rule in this test case is indeed 0.
['Get the object created by the constructor call.', 'Check whether the type of the object is String class type.', 'Get the arguments of the constructor call.', 'Check the number of arguments of the constructor call.', 'Get the type of the first argument.', 'Check whether the type of the first argument is byte array type.', 'The object created by the constructor call is of type String.', 'The constructor call has 1 argument.', 'The type of the first argument is byte array.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the object created by the constructor call.* 匹配到的元操作或API：
logic: Get the object created by the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8730127811431885
*Check whether the type of the object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of the object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8680888414382935
*Get the arguments of the constructor call.* 匹配到的元操作或API：
query: Get the arguments of the constructor call.
most similar API: get arguments of constructor call
cosine Similarity: 0.9658721089363098
*Check the number of arguments of the constructor call.* 匹配到的元操作或API：
query: Check the number of arguments of the constructor call.
most similar API: get arguments of constructor call
cosine Similarity: 0.8292137980461121
*Get the type of the first argument.* 匹配到的元操作或API：
logic: Get the type of the first argument.
most similar meta operation: Get the type of argument
cosine Similarity: 0.9078184962272644
*Check whether the type of the first argument is byte array type.* 匹配到的元操作或API：
logic: Check whether the type of the first argument is byte array type.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.9251225590705872
*The object created by the constructor call is of type String.* 匹配到的元操作或API：
未匹配成功元操作或API
*The constructor call has 1 argument.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of the first argument is byte array.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTArgumentList getArguments()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
3.  //Check whether the argument is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentByteType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount == 1) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return !firstArgument.getTypeMirror().isArray();
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the number of arguments of called method.
4. Check whether the number of arguments of called method is 1.
5. Get the type of the first argument in the constructor call.
6. Check whether the argument type is byte array type.

If the type of object created by the constructor call is String and the number of arguments is 1 and the argument type is byte array, then this test case does not violate the rule.

In this specific test case:
1. The type of object created by the constructor call is String.
2. The number of arguments of the called method is 1.
3. The type of the first argument in the constructor call is byte array.

Since the test case uses the byte array constructor, it does not violate the rule. Therefore, the number of violations in this test case is 0.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Check whether the number of arguments of called method is 1.', 'Get the type of the first argument in the constructor call.', 'Check whether the argument type is byte array type.', 'The type of object created by the constructor call is String.', 'The number of arguments of the called method is 1.', 'The type of the first argument in the constructor call is byte array.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Check whether the number of arguments of called method is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the type of the first argument in the constructor call.* 匹配到的元操作或API：
logic: Get the type of the first argument in the constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8835253715515137
*Check whether the argument type is byte array type.* 匹配到的元操作或API：
logic: Check whether the argument type is byte array type.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.9576107263565063
*The type of object created by the constructor call is String.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of arguments of the called method is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of the first argument in the constructor call is byte array.* 匹配到的元操作或API：
未匹配成功元操作或API
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Check whether the argument is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentByteType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount == 2) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        if (argumentCount == 3 || argumentCount == 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
=========================error_testcase_logics=========================
1. Get the object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the number of arguments of called method.
4. Get the type of argument at index 0.
5. Check whether the type of argument is array type.
6. Check whether the array type is byte type.

If the object created is of type String and the number of arguments is 1 and the argument type is a byte array, then this instantiation does not violate the rule.

In this test case:

1. The object created by the constructor call is of type String.
2. The number of arguments in the constructor call is 1.
3. The type of the argument is an array type.
4. The array type is a byte type.

Therefore, this test case does not violate the rule.
['Get the object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the number of arguments of called method.', 'Get the type of argument at index 0.', 'Check whether the type of argument is array type.', 'Check whether the array type is byte type.', 'The object created by the constructor call is of type String.', 'The number of arguments in the constructor call is 1.', 'The type of the argument is an array type.', 'The array type is a byte type.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the object created by constructor call.* 匹配到的元操作或API：
logic: Get the object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8863864541053772
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the number of arguments of called method.* 匹配到的元操作或API：
logic: Get the number of arguments of called method.
most similar meta operation: Get the number of arguments of called method
cosine Similarity: 0.9846129417419434
*Get the type of argument at index 0.* 匹配到的元操作或API：
logic: Get the type of argument at index 0.
most similar meta operation: Get the type of argument
cosine Similarity: 0.8764747381210327
*Check whether the type of argument is array type.* 匹配到的元操作或API：
logic: Check whether the type of argument is array type.
most similar meta operation: Check whether the argument is array type
cosine Similarity: 0.9811317920684814
*Check whether the array type is byte type.* 匹配到的元操作或API：
logic: Check whether the array type is byte type.
most similar meta operation: Check whether the array is byte type
cosine Similarity: 0.9825906753540039
*The object created by the constructor call is of type String.* 匹配到的元操作或API：
未匹配成功元操作或API
*The number of arguments in the constructor call is 1.* 匹配到的元操作或API：
未匹配成功元操作或API
*The type of the argument is an array type.* 匹配到的元操作或API：
logic: The type of the argument is an array type.
most similar meta operation: Check whether the argument is array type
cosine Similarity: 0.865432858467102
*The array type is a byte type.* 匹配到的元操作或API：
logic: The array type is a byte type.
most similar meta operation: Check whether the array is byte type
cosine Similarity: 0.8507770299911499
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Get the number of arguments of called method
```java
import net.sourceforge.pmd.lang.java.ast.*;
public int getArgumentNumber(ASTMethodCall node){
    ASTArgumentList arguments = node.getArguments();
    return arguments.size();
}
```
3.  //Get the type of argument
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JTypeMirror;
public JTypeMirror getMethodCallArgumentType(ASTMethodCall node) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror();
}
```
4.  //Check whether the argument is array type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
public boolean isMethodCallArgumentArrayType(ASTMethodCall node) {
   ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isArray();
}
```
5.  //Check whether the array is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;
import net.sourceforge.pmd.lang.java.ast.ASTArrayType;
import net.sourceforge.pmd.lang.java.ast.ASTType;
import net.sourceforge.pmd.lang.java.ast.ASTPrimitiveType;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isArrayByteType(ASTVariableDeclaratorId node) {
    if(node.getType().isArray()){
        ASTArrayType arrayType = (ASTArrayType)node.getTypeNode();
        ASTType astType = (ASTType) arrayType.getChild(0);
        if(astType instanceof ASTPrimitiveType){
            ASTPrimitiveType primitiveType = (ASTPrimitiveType)astType;
            if(primitiveType.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE)){
                return true;
            }
        }
    }
    return false;
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount == 1) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return !firstArgument.getTypeMirror().isArray() || !firstArgument.getTypeMirror().isArray() || !firstArgument.getTypeMirror().isArrayTypeOf(byte.class);
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To verify whether the test case adheres to the rule "Avoid instantiating String objects," we need to perform the following granular checks:

1. Get the object created by constructor call.
2. Check whether the type of object is String class type.
3. Get the signature of the called method (constructor).
4. Check whether the called method (constructor) is String constructor.
5. Check whether the argument list of the String constructor contains a byte array.

Based on these checks, we can ascertain if the instantiation of the String object is through a byte array constructor, which is allowed according to the rule description.

Let's perform these checks on the provided test case:

1. Get the object created by constructor call.
   - The object created by constructor call is `bar`.

2. Check whether the type of object is String class type.
   - The type of `bar` is String.

3. Get the signature of the called method (constructor).
   - The signature of the called method (constructor) is `String(byte[])`.

4. Check whether the called method (constructor) is String constructor.
   - The called method (constructor) is indeed the String constructor.

5. Check whether the argument list of the String constructor contains a byte array.
   - The argument list contains `bytes`, which is a byte array.

Since the String object is instantiated using the allowed byte array constructor, this test case does not violate the rule. The number of violations in this test case is indeed 0.
['Get the object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method (constructor).', 'Check whether the called method (constructor) is String constructor.', 'Check whether the argument list of the String constructor contains a byte array.', 'Get the object created by constructor call.', 'Check whether the type of object is String class type.', 'Get the signature of the called method (constructor).', 'Check whether the called method (constructor) is String constructor.', 'Check whether the argument list of the String constructor contains a byte array.']
['ASTArrayType', 'JavaAstUtils', 'ASTVoidType', 'ASTCompilationUnit', 'AstImplUtil', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTVariableDeclarator', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'ASTLocalVariableDeclaration', 'SymbolicValueHelper', 'CommentAssignmentPass', 'ASTVariableDeclaratorId', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTConstructorCall', 'ASTArrayAllocation', 'ASTVariableAccess', 'JavaSemanticErrors', 'ASTModifierList', 'ASTArrayDimExpr', 'ASTNumericLiteral', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ASTArrayDimensions', 'ASTArrayTypeDim', 'ASTPrimitiveType', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the object created by constructor call.* 匹配到的元操作或API：
logic: Get the object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8863864541053772
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method (constructor).* 匹配到的元操作或API：
logic: Get the signature of the called method (constructor).
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.933189332485199
*Check whether the called method (constructor) is String constructor.* 匹配到的元操作或API：
logic: Check whether the called method (constructor) is String constructor.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.8930263519287109
*Check whether the argument list of the String constructor contains a byte array.* 匹配到的元操作或API：
logic: Check whether the argument list of the String constructor contains a byte array.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.8625367879867554
*Get the object created by constructor call.* 匹配到的元操作或API：
logic: Get the object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8863864541053772
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Get the signature of the called method (constructor).* 匹配到的元操作或API：
logic: Get the signature of the called method (constructor).
most similar meta operation: Get the signature of the called method
cosine Similarity: 0.933189332485199
*Check whether the called method (constructor) is String constructor.* 匹配到的元操作或API：
logic: Check whether the called method (constructor) is String constructor.
most similar meta operation: Check whether the method caller is string type
cosine Similarity: 0.8930263519287109
*Check whether the argument list of the String constructor contains a byte array.* 匹配到的元操作或API：
logic: Check whether the argument list of the String constructor contains a byte array.
most similar meta operation: Check whether the argument is byte type
cosine Similarity: 0.8625367879867554
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// byte array constructor is ok
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes);
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTVoidType (method return type = 'void')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTArrayType (this is a primitive type)
            ——ASTPrimitiveType (this is a primitive type)
            ——ASTArrayDimensions
              ——ASTArrayTypeDim
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bytes')
            ——ASTArrayAllocation
              ——ASTArrayType (this is a primitive type)
                ——ASTPrimitiveType (this is a primitive type)
                ——ASTArrayDimensions
                  ——ASTArrayDimExpr
                    ——ASTNumericLiteral
        ——ASTLocalVariableDeclaration
          ——ASTModifierList
          ——ASTClassOrInterfaceType (this is a class type)
          ——ASTVariableDeclarator
            ——ASTVariableDeclaratorId (declared variable name = 'bar')
            ——ASTConstructorCall
              ——ASTClassOrInterfaceType (this is a class type)
              ——ASTArgumentList (size = 1)
                ——ASTVariableAccess (referenced variable name = 'bytes')


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTMethodCall: public net.sourceforge.pmd.lang.java.types.JMethodSig getMethodType()

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```
2.  //Check whether the method caller is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isMethodCallerStringType(ASTMethodCall node){
    return TypeTestUtil.isA(String.class, node.getQualifier());
}
```
3.  //Check whether the argument is byte type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;
import net.sourceforge.pmd.lang.java.ast.ASTArgumentList;
import net.sourceforge.pmd.lang.java.ast.ASTExpression;
import net.sourceforge.pmd.lang.java.types.JPrimitiveType;
public boolean isMethodCallArgumentByteType(ASTMethodCall call) {
    ASTArgumentList astArgumentList = node.getArguments();
    //select which argument to judge
    ASTExpression expression = astArgumentList.get(0);
    return expression.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount == 1) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return !firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
False
[{'error_rules_info': '[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>'}]
修复后有没通过的测试用例，不通过的是：
[ERROR]   "ok 4" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
==========5轮都没修复成功一个后面新加的一个测试用例，换一个测试用例进行修复
这个测试用例 5 round 没有修复成功：
ok 4
[ERROR]   "ok 5" resulted in wrong number of failures, ==> expected: <0> but was: <1>不通过
144
127
92
78
96
79
84
70
77
63
=========================error_testcase_logics=========================
Let's break down the test case to verify adherence to the rule "Avoid instantiating String objects."

1. Get the name of the package where the class is located.
2. Check whether the package is my.
3. Get the name of class.
4. Check whether the class has a method named foo.
5. Get the signature of method foo.
6. Get the return type of method foo.
7. Check whether the return type of method foo is String.
8. Get the body of method foo.
9. Get all method calls in the body of method foo.
10. Check whether there is a method call with the name new.
11. If there is a method call with the name new, get the type of object created by constructor call.
12. Check whether the type of object created is String.

Based on the provided test case:

1. Get the name of the package where the class is located.
   - The package is not explicitly shown, but it's not `java.lang` which is the default package for the `String` class.

2. Check whether the package is my.
   - The package is `my`, so this check passes.

3. Get the name of class.
   - The name of the class is `Foo`.

4. Check whether the class has a method named foo.
   - The class has a method named `foo`.

5. Get the signature of method foo.
   - The signature of method `foo` is `String foo()`.

6. Get the return type of method foo.
   - The return type of method `foo` is `String`.

7. Check whether the return type of method foo is String.
   - The return type is indeed `String`, so this check passes.

8. Get the body of method foo.
   - The body of method `foo` contains the statement `return new String("foo");`.

9. Get all method calls in the body of method foo.
   - The method call in the body is `new String("foo")`.

10. Check whether there is a method call with the name new.
    - There is a method call with the name `new`.

11. If there is a method call with the name new, get the type of object created by constructor call.
    - The constructor call creates an object of type `String`.

12. Check whether the type of object created is String.
    - The type of object created is indeed `String`.

Since there is a method call in the body of `foo` that instantiates a `String` object using `new String("foo")`, this test case violates the rule "Avoid instantiating String objects."

However, the test case description mentions "The number of violating the rule in this test case is: 0". This seems incorrect based on the analysis above. The test case does violate the rule.
['Get the name of the package where the class is located.', 'Check whether the package is my.', 'Get the name of class.', 'Check whether the class has a method named foo.', 'Get the signature of method foo.', 'Get the return type of method foo.', 'Check whether the return type of method foo is String.', 'Get the body of method foo.', 'Get all method calls in the body of method foo.', 'Check whether there is a method call with the name new.', 'If there is a method call with the name new, get the type of object created by constructor call.', 'Check whether the type of object created is String.', 'Get the name of the package where the class is located.', 'Check whether the package is my.', 'Get the name of class.', 'Check whether the class has a method named foo.', 'Get the signature of method foo.', 'Get the return type of method foo.', 'Check whether the return type of method foo is String.', 'Get the body of method foo.', 'Get all method calls in the body of method foo.', 'Check whether there is a method call with the name new.', 'If there is a method call with the name new, get the type of object created by constructor call.', 'Check whether the type of object created is String.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTStringLiteral', 'ASTImportDeclaration', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'ASTReturnStatement', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the package is my.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has a method named foo.* 匹配到的元操作或API：
query: Check whether the class has a method named foo.
most similar API: Check whether is test method
cosine Similarity: 0.8302556276321411
*Get the signature of method foo.* 匹配到的元操作或API：
logic: Get the signature of method foo.
most similar meta operation: Get the signature of method
cosine Similarity: 0.949309229850769
*Get the return type of method foo.* 匹配到的元操作或API：
logic: Get the return type of method foo.
most similar meta operation: Get the return type of method
cosine Similarity: 0.9501945376396179
*Check whether the return type of method foo is String.* 匹配到的元操作或API：
logic: Check whether the return type of method foo is String.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9659435153007507
*Get the body of method foo.* 匹配到的元操作或API：
query: Get the body of method foo.
most similar API: get body of method
cosine Similarity: 0.9337466955184937
*Get all method calls in the body of method foo.* 匹配到的元操作或API：
query: Get all method calls in the body of method foo.
most similar API: get body of method
cosine Similarity: 0.8291584253311157
*Check whether there is a method call with the name new.* 匹配到的元操作或API：
query: Check whether there is a method call with the name new.
most similar API: Check whether is call on this instance
cosine Similarity: 0.8015742301940918
*If there is a method call with the name new, get the type of object created by constructor call.* 匹配到的元操作或API：
logic: If there is a method call with the name new, get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9197604060173035
*Check whether the type of object created is String.* 匹配到的元操作或API：
logic: Check whether the type of object created is String.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8635118007659912
*Get the name of the package where the class is located.* 匹配到的元操作或API：
logic: Get the name of the package where the class is located.
most similar meta operation: Get the name of the package where the class is located
cosine Similarity: 0.9851533770561218
*Check whether the package is my.* 匹配到的元操作或API：
未匹配成功元操作或API
*Get the name of class.* 匹配到的元操作或API：
logic: Get the name of class.
most similar meta operation: Get the name of class
cosine Similarity: 0.9738673567771912
*Check whether the class has a method named foo.* 匹配到的元操作或API：
query: Check whether the class has a method named foo.
most similar API: Check whether is test method
cosine Similarity: 0.8302556276321411
*Get the signature of method foo.* 匹配到的元操作或API：
logic: Get the signature of method foo.
most similar meta operation: Get the signature of method
cosine Similarity: 0.949309229850769
*Get the return type of method foo.* 匹配到的元操作或API：
logic: Get the return type of method foo.
most similar meta operation: Get the return type of method
cosine Similarity: 0.9501945376396179
*Check whether the return type of method foo is String.* 匹配到的元操作或API：
logic: Check whether the return type of method foo is String.
most similar meta operation: Check whether the return type of method is string type
cosine Similarity: 0.9659435153007507
*Get the body of method foo.* 匹配到的元操作或API：
query: Get the body of method foo.
most similar API: get body of method
cosine Similarity: 0.9337466955184937
*Get all method calls in the body of method foo.* 匹配到的元操作或API：
query: Get all method calls in the body of method foo.
most similar API: get body of method
cosine Similarity: 0.8291584253311157
*Check whether there is a method call with the name new.* 匹配到的元操作或API：
query: Check whether there is a method call with the name new.
most similar API: Check whether is call on this instance
cosine Similarity: 0.8015742301940918
*If there is a method call with the name new, get the type of object created by constructor call.* 匹配到的元操作或API：
logic: If there is a method call with the name new, get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9197604060173035
*Check whether the type of object created is String.* 匹配到的元操作或API：
logic: Check whether the type of object created is String.
most similar meta operation: Check whether the field is string type
cosine Similarity: 0.8635118007659912
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// Not a new String
import my.String;
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getPackageName()
2. net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceDeclaration: public java.lang.String getSimpleName()
3. net.sourceforge.pmd.lang.java.rule.internal.TestFrameworksUtil: static public boolean isTestMethod(net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration), //Returns true if this is either a JUnit test or a TestNG test.
4. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.types.JMethodSig getGenericSignature()
5. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTType getResultTypeNode()
6. net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration: public net.sourceforge.pmd.lang.java.ast.ASTBlock getBody(), //Returns the body of this method or constructor. Returns null if this is the declaration of an abstract method.
7. net.sourceforge.pmd.lang.java.ast.internal.JavaAstUtils: static public boolean isCallOnThisInstance(net.sourceforge.pmd.lang.java.ast.ASTMethodCall)
8. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()

1.  //Check whether the return type of method is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isReturnValueStringType(ASTMethodDeclaration method) {
    return TypeTestUtil.isA(String.class, method.getResultTypeNode());
}
```
2.  //Check whether the field is string type
```java
import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isFieldStringType(ASTFieldDeclaration node) {
    return TypeTestUtil.isA(String.class, node.getTypeNode());
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        if (!isCustomStringClass(node)) {
                            addViolation(data, node);
                        }
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                if (!isCustomStringClass(node)) {
                                    addViolation(data, node);
                                }
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }

    private boolean isCustomStringClass(ASTMethodDeclaration method) {
        ASTClassOrInterfaceDeclaration classNode = JavaAstUtils.getFirstParentOfType(method, ASTClassOrInterfaceDeclaration.class);
        String packageName = classNode.getPackageName();
        String simpleName = classNode.getSimpleName();
        return packageName != null && simpleName != null && !packageName.equals("java.lang");
    }
}
编译是否通过？
False
编译错误不在预期范围内，重新生成
迭代测试用例时， 2轮内编译不通过，pass，重新来一轮编译修复生成修复测试用例后的checker
=========================error_testcase_logics=========================
To verify whether the test case adheres to the rule "Avoid instantiating String objects," let's perform granular checks:

1. Get the type of object created by constructor call.
2. Check whether the type of object is String class type.
3. Check whether the constructor call uses the `new` keyword.

Given the test case:

```java
// Not a new String
import my.String;
public class Foo {
    String foo() {
        return new String("foo");
    }
}
```

Let's execute these checks:

1. Get the type of object created by constructor call.
   - The object type created in the constructor call is `String`.

2. Check whether the type of object is String class type.
   - The type of object created is indeed a `String` class type.

3. Check whether the constructor call uses the `new` keyword.
   - The constructor call uses the `new` keyword: `new String("foo")`.

Based on these checks, it appears that the test case actually does instantiate a `String` object using the `new` keyword. Therefore, the number of violations of the rule in this test case is: 1.

However, there is an import statement that might be causing confusion. The test case imports `my.String`, which is not the standard Java `String` class. Therefore, the constructor call `new String("foo")` is actually instantiating an object of the `my.String` class, not the standard `java.lang.String` class.

Let's add an additional check to clarify this:

4. Check whether the type of object created by constructor call is `java.lang.String` class type.

Executing this additional check:

4. Check whether the type of object created by constructor call is `java.lang.String` class type.
   - The type of object created is `my.String`, not `java.lang.String`.

Since the constructor call is instantiating an object of `my.String`, not `java.lang.String`, the test case does not violate the rule "Avoid instantiating String objects" as per the standard `java.lang.String`.

Therefore, the number of violations of the rule in this test case is: 0.
['Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call uses the `new` keyword.', 'Get the type of object created by constructor call.', 'Check whether the type of object is String class type.', 'Check whether the constructor call uses the `new` keyword.', 'Check whether the type of object created by constructor call is `java.lang.String` class type.', 'Check whether the type of object created by constructor call is `java.lang.String` class type.']
['JavaAstUtils', 'AstImplUtil', 'ASTCompilationUnit', 'JavaRuleUtil', 'SymbolResolutionPass', 'TypesFromReflection', 'ASTArgumentList', 'ASTMethodDeclaration', 'TestFrameworksUtil', 'TypesFromAst', 'SymbolicValueHelper', 'CommentAssignmentPass', 'JavaPropertyUtil', 'ASTFormalParameters', 'ASTBlock', 'ASTStringLiteral', 'ASTImportDeclaration', 'ASTConstructorCall', 'JavaSemanticErrors', 'ASTModifierList', 'ASTReturnStatement', 'InternalApiBridge', 'TypeConversion', 'ASTClassOrInterfaceDeclaration', 'JavadocTag', 'ClassNamesUtil', 'TokenUtils', 'ASTClassOrInterfaceType', 'ASTClassOrInterfaceBody', 'TypeTestUtil']
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call uses the `new` keyword.* 匹配到的元操作或API：
query: Check whether the constructor call uses the `new` keyword.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8416945934295654
*Get the type of object created by constructor call.* 匹配到的元操作或API：
logic: Get the type of object created by constructor call.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.9878885746002197
*Check whether the type of object is String class type.* 匹配到的元操作或API：
logic: Check whether the type of object is String class type.
most similar meta operation: Check whether the type of object is x class type
cosine Similarity: 0.8719311952590942
*Check whether the constructor call uses the `new` keyword.* 匹配到的元操作或API：
query: Check whether the constructor call uses the `new` keyword.
most similar API: Check whether the constructor call is qualified instance creation
cosine Similarity: 0.8416945934295654
*Check whether the type of object created by constructor call is `java.lang.String` class type.* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is `java.lang.String` class type.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8884241580963135
*Check whether the type of object created by constructor call is `java.lang.String` class type.* 匹配到的元操作或API：
logic: Check whether the type of object created by constructor call is `java.lang.String` class type.
most similar meta operation: Get the type of object created by constructor call
cosine Similarity: 0.8884241580963135
===============================新加一个测试用例生成的checker repair_test_error_query_when_testing==========================
You are an expert in writing java rule checkers in PMD tool version 7.0.0. 
You have helped me write a checker for this rule:
Rule description: Avoid instantiating String objects.;
And the source code of the checker is as follows:
```
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode);
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return true;
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
```
This checker has passed these test case:
This checker has passed this negative testcase:
public class Foo {
    private String bar = new String("bar");
    private String baz = new String();
}
This checker has passed this positive testcase:
public class Foo {
    void foo() {
        byte[] bytes = new byte[50];
        String bar = new String(bytes, 0, bytes.length, "some-encoding");
    }
}
This checker has passed this negative testcase:
public class Foo {
    String foo() {
        return new String("foo");
    }
}
This checker has passed this negative testcase:
public class Foo {
    public void bar() {
        String[] arr = getArray();
        String s = new String(arr[0]);
        // better
        String s2 = arr[0];
    }
    public void bar2() {
        String[][] arr = getArray2();
        String s = new String(arr[0][0]);
    }
}


This checker is failed(false positive) on this positive test case:
```
// Not a new String
import my.String;
public class Foo {
    String foo() {
        return new String("foo");
    }
}
The number of violating the rule in this test case is: 0

```
The AST corresponding to this test case:
ASTCompilationUnit
——ASTImportDeclaration
——ASTClassOrInterfaceDeclaration (class name = 'Foo')
  ——ASTModifierList
  ——ASTClassOrInterfaceBody
    ——ASTMethodDeclaration (method name = 'foo')
      ——ASTModifierList
      ——ASTClassOrInterfaceType (method return type = 'String')
      ——ASTFormalParameters (size = 0)
      ——ASTBlock
        ——ASTReturnStatement
          ——ASTConstructorCall
            ——ASTClassOrInterfaceType (this is a class type)
            ——ASTArgumentList (size = 1)
              ——ASTStringLiteral


Please help me repair this checker according to rule description by adding or modifying some code logic to correctly check this positive test case.
Note that the initial code function should not be changed, to prevent previous test cases from failing.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

Below are some code snippets that maybe useful to you to repair this checker consisting of off-the-shelf APIs, they implement specific functionality, you can selectively use them directly without changing it if you need:

1. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType getTypeNode()
2. net.sourceforge.pmd.lang.java.ast.ASTConstructorCall: public boolean isQualifiedInstanceCreation(), //Returns true if this expression begins with a primary expression. Such an expression creates an instance of inner member classes and their anonymous subclasses. For example, {@code new Outer().new Inner()} evaluates to an instance of the Inner class, which is nested inside the new instance of Outer.

1.  //Check whether the type of object is x class type
```java
import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;
import net.sourceforge.pmd.lang.java.types.TypeTestUtil;
public boolean isVariableAccessStringType(ASTConstructorCall node){
    return TypeTestUtil.isA(x.class, node);
}
```


================修复新加测试用例后生成的checker===================
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class StringInstantiationRule extends AbstractJavaRulechainRule {

    public StringInstantiationRule() {
        super(ASTFieldDeclaration.class, ASTMethodDeclaration.class);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        if (isFieldStringType(node)) {
            for (ASTVariableDeclaratorId varId : node.getVarIds()) {
                ASTExpression init = varId.getInitializer();
                if (init instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        ASTBlock body = node.getBody();
        if (body != null) {
            for (ASTReturnStatement returnStatement : body.findDescendantsOfType(ASTReturnStatement.class)) {
                ASTExpression expr = returnStatement.getExpr();
                if (expr instanceof ASTConstructorCall) {
                    ASTConstructorCall constructorCall = (ASTConstructorCall) expr;
                    if (isStringConstructorCall(constructorCall)) {
                        addViolation(data, node);
                    }
                }
            }
            for (ASTLocalVariableDeclaration localVarDecl : body.findDescendantsOfType(ASTLocalVariableDeclaration.class)) {
                ASTType type = localVarDecl.getTypeNode();
                if (type instanceof ASTClassOrInterfaceType && TypeTestUtil.isA(String.class, type)) {
                    for (ASTVariableDeclaratorId varId : localVarDecl.getVarIds()) {
                        ASTExpression init = varId.getInitializer();
                        if (init instanceof ASTConstructorCall) {
                            ASTConstructorCall constructorCall = (ASTConstructorCall) init;
                            if (isStringConstructorCall(constructorCall)) {
                                addViolation(data, node);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    public boolean isFieldStringType(ASTFieldDeclaration node) {
        return TypeTestUtil.isA(String.class, node.getTypeNode());
    }

    public boolean isInitializedToVariableValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTVariableAccess) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    public ASTLiteral getInitializedValue(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId varId : varIds) {
            if (varId.getName().equals("x")) {
                ASTExpression init = varId.getInitializer();
                if (init != null) {
                    if (init instanceof ASTLiteral) {
                        return (ASTLiteral) init;
                    }
                }
            }
        }
        return null;
    }

    public boolean isVariableAccessStringType(ASTConstructorCall node) {
        ASTClassOrInterfaceType typeNode = node.getTypeNode();
        return TypeTestUtil.isA(String.class, typeNode.getTypeMirror());
    }

    public String getFieldName(ASTFieldDeclaration node) {
        NodeStream<ASTVariableDeclaratorId> varIds = node.getVarIds();
        for (ASTVariableDeclaratorId variableDeclaratorId : varIds) {
            if (variableDeclaratorId.getName().equals("x")) {
                String variableName = variableDeclaratorId.getName();
                return variableName;
            }
        }
        return null;
    }

    public boolean isVariableAccessArrayType(ASTVariableAccess var) {
        JTypeMirror typeMirror = var.getTypeMirror();
        return typeMirror.isArray();
    }

    private boolean isStringConstructorCall(ASTConstructorCall constructorCall) {
        int argumentCount = constructorCall.getArguments().size();
        if (argumentCount == 0 || argumentCount == 1) {
            return TypeTestUtil.isA(String.class, constructorCall.getTypeNode().getTypeMirror());
        }
        if (argumentCount >= 2 && argumentCount <= 4) {
            ASTExpression firstArgument = constructorCall.getArguments().get(0);
            return firstArgument.getTypeMirror().isPrimitive(JPrimitiveType.PrimitiveTypeKind.BYTE);
        }
        return false;
    }
}
编译是否通过？
True
测试是否通过
True
测试用例全部通过
最终通过 8 个测试用例
正例 3 个
反例 5 个
输入token：206376
输出token：128171
结束

规则执行完毕，时间总花销： 4456.822353839874 秒
