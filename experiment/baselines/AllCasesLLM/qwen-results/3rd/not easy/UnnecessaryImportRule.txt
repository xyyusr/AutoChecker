开始

========================================== Rule UnnecessaryImportRule ===========================================
一共 73 个测试用例
正例 50 个
反例 23 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.List;
import java.util.Set;
import java.util.HashSet;
import java.util.stream.Collectors;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {

    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class, ASTImportDeclaration.class, ASTStaticImportDeclaration.class, ASTReferenceType.class, ASTAnnotation.class, ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class, ASTVariableDeclaratorId.class, ASTFormalParameter.class, ASTCatchClause.class, ASTJavadocComment.class);
    }

    private Set<String> usedImports;
    private Set<String> wildcardImports;
    private String currentPackageName;

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        usedImports = new HashSet<>();
        wildcardImports = new HashSet<>();
        currentPackageName = node.getPackageName();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        ASTReferenceType referenceType = node.getFirstDescendantOfType(ASTReferenceType.class);
        if (referenceType != null) {
            String importName = referenceType.getTypeReference().getName();
            if (node.isStarImport()) {
                wildcardImports.add(importName);
            } else {
                usedImports.add(importName);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStaticImportDeclaration node, Object data) {
        String importName = node.getTypeReference().getName();
        if (node.isStarImport()) {
            wildcardImports.add(importName);
        } else {
            usedImports.add(importName);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTReferenceType node, Object data) {
        String typeName = node.getTypeReference().getName();
        usedImports.add(typeName);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAnnotation node, Object data) {
        String annotationName = node.getTypeReference().getName();
        usedImports.add(annotationName);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        usedImports.add(node.getName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        usedImports.add(node.getName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTVariableDeclaratorId node, Object data) {
        String variableName = node.getName();
        usedImports.add(variableName);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFormalParameter node, Object data) {
        ASTType type = node.getTypeNode();
        if (type != null) {
            String typeName = type.getTypeReference().getName();
            usedImports.add(typeName);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        ASTFormalParameter formalParameter = node.getParameter();
        if (formalParameter != null) {
            ASTType type = formalParameter.getTypeNode();
            if (type != null) {
                String typeName = type.getTypeReference().getName();
                usedImports.add(typeName);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTJavadocComment node, Object data) {
        List<ASTName> names = node.findDescendantsOfType(ASTName.class);
        for (ASTName name : names) {
            String nameText = name.getImage();
            if (nameText.contains(".")) {
                usedImports.add(nameText.substring(0, nameText.lastIndexOf('.')));
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        for (ASTImportDeclaration importDecl : node.findDescendantsOfType(ASTImportDeclaration.class)) {
            String importName = importDecl.getTypeReference().getName();
            if (!isImportUsed(importDecl) && !isImplicitlyInScope(importName)) {
                addViolation(data, importDecl);
            }
        }
        for (ASTStaticImportDeclaration staticImportDecl : node.findDescendantsOfType(ASTStaticImportDeclaration.class)) {
            String importName = staticImportDecl.getTypeReference().getName();
            if (!isStaticImportUsed(staticImportDecl) && !isImplicitlyInScope(importName)) {
                addViolation(data, staticImportDecl);
            }
        }
        return super.visit(node, data);
    }

    private boolean isImportUsed(ASTImportDeclaration importDecl) {
        String importName = importDecl.getTypeReference().getName();
        if (importDecl.isStarImport()) {
            return wildcardImports.contains(importName);
        } else {
            return usedImports.contains(importName);
        }
    }

    private boolean isStaticImportUsed(ASTStaticImportDeclaration staticImportDecl) {
        String importName = staticImportDecl.getTypeReference().getName();
        if (staticImportDecl.isStarImport()) {
            return wildcardImports.contains(importName);
        } else {
            return usedImports.contains(importName);
        }
    }

    private boolean isImplicitlyInScope(String importName) {
        return importName.startsWith(currentPackageName) || importName.startsWith("java.lang");
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    private Set<String> usedImports;
    private Set<String> wildcardImports;
    private String currentPackageName;

    public UnnecessaryImportRule() {
        super(ASTImportDeclaration.class, ASTClassOrInterfaceDeclaration.class, ASTAnnotationDeclaration.class, ASTMethodDeclaration.class, ASTFieldDeclaration.class, ASTTryStatement.class, ASTCatchClause.class, ASTForStatement.class, ASTJavadocComment.class, ASTPackageDeclaration.class);
    }

    @Override
    public Object visit(ASTPackageDeclaration node, Object data) {
        currentPackageName = node.getPackageName();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        if (node.isStarImport()) {
            String packageName = node.getPackageName();
            wildcardImports.add(packageName);
        } else {
            String importedClass = node.getImportedName();
            usedImports.add(importedClass);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        checkUnusedImports(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAnnotationDeclaration node, Object data) {
        checkUnusedImports(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        checkMethodReferences(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        checkFieldReferences(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        checkTryCatchReferences(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        checkCatchReferences(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        checkForReferences(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTJavadocComment node, Object data) {
        checkJavadocReferences(node);
        return super.visit(node, data);
    }

    private void checkUnusedImports(ASTCompilationUnit node) {
        Set<String> implicitlyInScope = new HashSet<>();
        implicitlyInScope.add("java.lang");
        implicitlyInScope.add(currentPackageName);

        for (ASTImportDeclaration importDecl : node.findDescendantsOfType(ASTImportDeclaration.class)) {
            String importName = importDecl.getPackageNameOrTypeName();
            String simpleTypeName = importDecl.getImportedName();

            if (importDecl.isStarImport()) {
                if (wildcardImports.stream().anyMatch(wildcard -> simpleTypeName.startsWith(wildcard))) {
                    continue;
                }
            } else if (usedImports.contains(simpleTypeName)) {
                continue;
            }

            if (implicitlyInScope.stream().anyMatch(scope -> importName.startsWith(scope))) {
                addViolation(importDecl);
            } else if (!node.findDescendantsOfType(ASTPrimaryExpression.class).stream().anyMatch(expr -> expr.getType() != null && expr.getType().getName().equals(simpleTypeName)) &&
                       !node.findDescendantsOfType(ASTClassOrInterfaceType.class).stream().anyMatch(type -> type.getName().equals(simpleTypeName)) &&
                       !node.findDescendantsOfType(ASTName.class).stream().anyMatch(name -> name.getImage().equals(simpleTypeName)) &&
                       !node.findDescendantsOfType(ASTPrimarySuffix.class).stream().anyMatch(suffix -> suffix.getImage().equals(simpleTypeName)) &&
                       !node.findDescendantsOfType(ASTMethodReference.class).stream().anyMatch(methodRef -> methodRef.getType() != null && methodRef.getType().getName().equals(simpleTypeName)) &&
                       !node.findDescendantsOfType(ASTJavadocComment.class).stream().anyMatch(javadoc -> javadoc.toString().contains(simpleTypeName))) {
                addViolation(importDecl);
            }
        }
    }

    private void checkMethodReferences(ASTMethodDeclaration node) {
        for (ASTName name : node.findDescendantsOfType(ASTName.class)) {
            usedImports.add(name.getImage());
        }
    }

    private void checkFieldReferences(ASTFieldDeclaration node) {
        for (ASTName name : node.findDescendantsOfType(ASTName.class)) {
            usedImports.add(name.getImage());
        }
    }

    private void checkTryCatchReferences(ASTTryStatement node) {
        for (ASTName name : node.findDescendantsOfType(ASTName.class)) {
            usedImports.add(name.getImage());
        }
    }

    private void checkCatchReferences(ASTCatchClause node) {
        for (ASTName name : node.findDescendantsOfType(ASTName.class)) {
            usedImports.add(name.getImage());
        }
    }

    private void checkForReferences(ASTForStatement node) {
        for (ASTName name : node.findDescendantsOfType(ASTName.class)) {
            usedImports.add(name.getImage());
        }
    }

    private void checkJavadocReferences(ASTJavadocComment node) {
        for (ASTName name : node.findDescendantsOfType(ASTName.class)) {
            String refName = name.getImage();
            if (refName.contains(".")) {
                String[] parts = refName.split("\\.");
                usedImports.add(parts[parts.length - 1]);
            } else {
                usedImports.add(refName);
            }
        }
    }

    private void checkUnusedImports(ASTNode node) {
        Set<String> allImports = new HashSet<>();
        allImports.addAll(usedImports);
        allImports.addAll(wildcardImports);

        for (String importName : allImports) {
            if (wildcardImports.stream().anyMatch(wildcard -> importName.startsWith(wildcard))) {
                continue;
            }
            if (!node.findDescendantsOfType(ASTPrimaryExpression.class).stream().anyMatch(expr -> expr.getType() != null && expr.getType().getName().equals(importName)) &&
                !node.findDescendantsOfType(ASTClassOrInterfaceType.class).stream().anyMatch(type -> type.getName().equals(importName)) &&
                !node.findDescendantsOfType(ASTName.class).stream().anyMatch(name -> name.getImage().equals(importName)) &&
                !node.findDescendantsOfType(ASTPrimarySuffix.class).stream().anyMatch(suffix -> suffix.getImage().equals(importName)) &&
                !node.findDescendantsOfType(ASTMethodReference.class).stream().anyMatch(methodRef -> methodRef.getType() != null && methodRef.getType().getName().equals(importName)) &&
                !node.findDescendantsOfType(ASTJavadocComment.class).stream().anyMatch(javadoc -> javadoc.toString().contains(importName))) {
                addViolation(node.getRoot().findFirstDescendantOfType(ASTImportDeclaration.class, decl -> decl.getImportedName().equals(importName)));
            }
        }
    }

    @Override
    public void start(ASTCompilationUnit acu) {
        usedImports = new HashSet<>();
        wildcardImports = new HashSet<>();
        currentPackageName = "";
        super.start(acu);
    }

    @Override
    public void end(ASTCompilationUnit acu) {
        checkUnusedImports(acu);
        super.end(acu);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {

    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class, ASTImportDeclaration.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        List<ASTImportDeclaration> imports = node.findDescendantsOfType(ASTImportDeclaration.class);
        Set<String> usedImports = new HashSet<>();
        Set<String> wildcardImports = new HashSet<>();
        JPackageSymbol currentPackage = node.getPackageName();

        for (ASTImportDeclaration imp : imports) {
            if (!imp.isOnDemand()) {
                usedImports.add(imp.getImportedName().getQualifiedName());
            } else {
                wildcardImports.add(imp.getImportedName().getQualifiedName());
            }
        }

        NodeStream.of(node)
                .filter(ASTReferenceType.class::isInstance)
                .map(ASTReferenceType.class::cast)
                .map(ASTReferenceType::getType)
                .map(ASTType::getTypeInSignature)
                .filter(JClassType.class::isInstance)
                .map(JClassType.class::cast)
                .map(JClassType::getSymbol)
                .filter(JClassSymbol.class::isInstance)
                .map(JClassSymbol.class::cast)
                .forEach(symbol -> {
                    if (symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove(symbol.getQualifiedName());
                    } else if (symbol.getPackageName().equals("java.lang")) {
                        usedImports.remove(symbol.getQualifiedName());
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .map(ASTName::getQualifier)
                .filter(Objects::nonNull)
                .map(JClassType::getSymbol)
                .filter(JClassSymbol.class::isInstance)
                .map(JClassSymbol.class::cast)
                .forEach(symbol -> {
                    if (symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove(symbol.getQualifiedName());
                    } else if (symbol.getPackageName().equals("java.lang")) {
                        usedImports.remove(symbol.getQualifiedName());
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(name -> name.getImage().equals("String"))
                .forEach(name -> {
                    JClassType type = name.getTypeInSignature();
                    JClassSymbol symbol = type.getSymbol();
                    if (!symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove("java.lang.String");
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(name -> name.getImage().equals("List"))
                .forEach(name -> {
                    JClassType type = name.getTypeInSignature();
                    JClassSymbol symbol = type.getSymbol();
                    if (!symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove("java.util.List");
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(name -> name.getImage().equals("ArrayList"))
                .forEach(name -> {
                    JClassType type = name.getTypeInSignature();
                    JClassSymbol symbol = type.getSymbol();
                    if (!symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove("java.util.ArrayList");
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::hasImageEqualTo)
                .forEach(name -> {
                    JTypeSymbol symbol = name.getTypeInSignature().getSymbol();
                    if (!symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove(symbol.getQualifiedName());
                    }
                });

        node.findDescendantsOfType(ASTAnnotation.class).stream()
                .map(ASTAnnotation::getType)
                .map(ASTType::getTypeInSignature)
                .filter(JClassType.class::isInstance)
                .map(JClassType.class::cast)
                .map(JClassType::getSymbol)
                .filter(JAnnotationSymbol.class::isInstance)
                .map(JAnnotationSymbol.class::cast)
                .forEach(symbol -> {
                    if (symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove(symbol.getQualifiedName());
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::isReference)
                .forEach(name -> {
                    JSymbol symbol = name.getQualifier().getSymbol();
                    if (symbol instanceof JClassSymbol) {
                        JClassSymbol classSymbol = (JClassSymbol) symbol;
                        if (classSymbol.getPackageName().equals(currentPackage)) {
                            usedImports.remove(classSymbol.getQualifiedName());
                        }
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .map(ASTName::getQualifier)
                .filter(Objects::nonNull)
                .map(ASTName::getTypeInSignature)
                .filter(JClassType.class::isInstance)
                .map(JClassType.class::cast)
                .map(JClassType::getSymbol)
                .filter(JClassSymbol.class::isInstance)
                .map(JClassSymbol.class::cast)
                .forEach(symbol -> {
                    if (symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove(symbol.getQualifiedName());
                    } else if (symbol.getPackageName().equals("java.lang")) {
                        usedImports.remove(symbol.getQualifiedName());
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::hasImageEqualTo)
                .forEach(name -> {
                    JTypeSymbol symbol = name.getTypeInSignature().getSymbol();
                    if (!symbol.getPackageName().equals(currentPackage)) {
                        usedImports.remove(symbol.getQualifiedName());
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::isReference)
                .forEach(name -> {
                    JSymbol symbol = name.getQualifier().getSymbol();
                    if (symbol instanceof JClassSymbol) {
                        JClassSymbol classSymbol = (JClassSymbol) symbol;
                        if (classSymbol.getPackageName().equals(currentPackage)) {
                            usedImports.remove(classSymbol.getQualifiedName());
                        }
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::isReference)
                .forEach(name -> {
                    JSymbol symbol = name.getTypeInSignature().getSymbol();
                    if (symbol instanceof JClassSymbol) {
                        JClassSymbol classSymbol = (JClassSymbol) symbol;
                        if (classSymbol.getPackageName().equals(currentPackage)) {
                            usedImports.remove(classSymbol.getQualifiedName());
                        }
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::isReference)
                .forEach(name -> {
                    JSymbol symbol = name.getTypeInSignature().getSymbol();
                    if (symbol instanceof JExecutableSymbol) {
                        JExecutableSymbol executableSymbol = (JExecutableSymbol) symbol;
                        JClassSymbol classSymbol = executableSymbol.getEnclosingClassSymbol();
                        if (classSymbol.getPackageName().equals(currentPackage)) {
                            usedImports.remove(classSymbol.getQualifiedName());
                        }
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::isReference)
                .forEach(name -> {
                    JSymbol symbol = name.getTypeInSignature().getSymbol();
                    if (symbol instanceof JVariableSymbol) {
                        JVariableSymbol variableSymbol = (JVariableSymbol) symbol;
                        JClassSymbol classSymbol = variableSymbol.getEnclosingClassSymbol();
                        if (classSymbol.getPackageName().equals(currentPackage)) {
                            usedImports.remove(classSymbol.getQualifiedName());
                        }
                    }
                });

        NodeStream.of(node)
                .filter(ASTName.class::isInstance)
                .map(ASTName.class::cast)
                .filter(ASTName::isReference)
                .forEach(name -> {
                    JSymbol symbol = name.getTypeInSignature().getSymbol();
                    if (symbol instanceof JExecutableSymbol) {
                        JExecutableSymbol executableSymbol = (JExecutableSymbol) symbol;
                        JClassSymbol classSymbol = executableSymbol.getEnclosingClassSymbol();
                        if (classSymbol.getPackageName().equals(currentPackage)) {
                            usedImports.remove(classSymbol.getQualifiedName());
                        }
                    }
                });

        node.findDescendantsOfType(ASTComment.class).stream()
                .map(ASTComment::getImage)
                .flatMap(comment -> {
                    return Arrays.stream(comment.split("[\\s\\n\\r]+"))
                            .filter(token -> token.matches("@link|@see|@value|@snippet|#"))
                            .map(token -> comment.substring(comment.indexOf(token) + token.length()))
                            .map(commentPart -> commentPart.split("[\\s\\n\\r]+|\\{|\\}")[0]);
                })
                .map(String::trim)
                .filter(qualifiedName -> !qualifiedName.isEmpty())
                .forEach(qualifiedName -> {
                    if (qualifiedName.contains(".")) {
                        String packageName = qualifiedName.substring(0, qualifiedName.lastIndexOf('.'));
                        if (!packageName.equals(currentPackage.getName()) && !packageName.equals("java.lang")) {
                            usedImports.add(qualifiedName);
                        }
                    }
                });

        for (ASTImportDeclaration imp : imports) {
            if (!imp.isOnDemand()) {
                String importName = imp.getImportedName().getQualifiedName();
                if (!usedImports.contains(importName)) {
                    addViolation(data, imp);
                }
            } else {
                String importName = imp.getImportedName().getQualifiedName();
                String packageName = importName.substring(0, importName.lastIndexOf('.'));
                if (!wildcardImports.stream().anyMatch(w -> w.startsWith(packageName + "."))) {
                    addViolation(data, imp);
                }
            }
        }

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.TreeMap;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class, ASTImportDeclaration.class, ASTStaticImportDeclaration.class, ASTReferenceType.class, ASTLiteral.class, ASTName.class, ASTMethodDeclaration.class);
    }

    private Map<String, Set<NameOccurrence>> importMap;
    private Set<String> usedImports;
    private Set<String> usedStaticImports;
    private String currentPackageName;

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        importMap = new HashMap<>();
        usedImports = new HashSet<>();
        usedStaticImports = new HashSet<>();
        currentPackageName = Optional.ofNullable(node.getPackageDeclaration()).map(ASTPackageDeclaration::getPackageName).orElse("");
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        String importName = node.getImportedName();
        importMap.computeIfAbsent(importName, k -> new HashSet<>()).addAll(node.getUsages());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStaticImportDeclaration node, Object data) {
        String importName = node.getImportedName();
        importMap.computeIfAbsent(importName, k -> new HashSet<>()).addAll(node.getUsages());
        usedStaticImports.add(node.getImports());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTReferenceType node, Object data) {
        String name = node.getTypeImage();
        if (!isJavaLangMember(name) && !isCurrentPackageMember(name)) {
            usedImports.add(node.getTypeImage());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLiteral node, Object data) {
        if (node.isStringLiteral()) {
            String literalValue = node.getImage();
            if (literalValue.contains(".")) {
                String[] parts = literalValue.split("\\.");
                if (parts.length > 1) {
                    String className = parts[parts.length - 2];
                    usedImports.add(className);
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTName node, Object data) {
        String name = node.getImage();
        if (!isJavaLangMember(name) && !isCurrentPackageMember(name)) {
            usedImports.add(name);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.getTypeParameters() != null) {
            node.getTypeParameters().forEach(tp -> {
                if (tp.getTypeBound() != null) {
                    tp.getTypeBound().forEach(tb -> usedImports.add(tb.getTypeImage()));
                }
            });
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTypeDeclaration node, Object data) {
        if (node instanceof ASTAnnotationTypeDeclaration || node instanceof ASTInterfaceDeclaration) {
            node.findDescendantsOfType(ASTAnnotation.class).forEach(a -> {
                String annotationName = a.getTypeImage();
                if (!isJavaLangMember(annotationName) && !isCurrentPackageMember(annotationName)) {
                    usedImports.add(annotationName);
                }
            });
        }
        return super.visit(node, data);
    }

    @Override
    public void end(ASTCompilationUnit node) {
        importMap.keySet().stream()
                .filter(imp -> !usedImports.contains(imp) && !usedStaticImports.contains(imp))
                .forEach(imp -> addViolation(node.findFirstChildOfType(ASTImportDeclaration.class, ASTStaticImportDeclaration.class, nd -> nd.getImports().equals(imp))));
    }

    private boolean isJavaLangMember(String name) {
        return TypeTestUtil.isJavaLangMember(name);
    }

    private boolean isCurrentPackageMember(String name) {
        return currentPackageName.isEmpty() || name.startsWith(currentPackageName + ".");
    }

    private void addViolation(NodeStream<? extends JavaNode> nodeStream) {
        nodeStream.forEach(node -> addViolation(node));
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<String> usedImports = new HashSet<>();
        Set<String> onDemandImports = new HashSet<>();
        JPackageSymbol currentPackage = node.getPackageDeclaration().map(ASTPackageDeclaration::getPackageName).orElse(null);

        node.getTypeDeclarations().forEach(typeDeclaration -> {
            typeDeclaration.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType));
            typeDeclaration.findDescendantsOfType(ASTJavadoc.class).forEach(javadoc -> addUsedImportFromJavadoc(usedImports, onDemandImports, javadoc));
            typeDeclaration.findDescendantsOfType(ASTFieldDeclaration.class).forEach(fieldDeclaration -> fieldDeclaration.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTFormalParameter.class).forEach(formalParameter -> formalParameter.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTResource.class).forEach(resource -> resource.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTMethodReference.class).forEach(methodReference -> methodReference.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTConstructorDeclaration.class).forEach(constructorDeclaration -> constructorDeclaration.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTMethodDeclaration.class).forEach(methodDeclaration -> methodDeclaration.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTCatchClause.class).forEach(catchClause -> catchClause.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTForStatement.class).forEach(forStatement -> forStatement.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTForeachStatement.class).forEach(foreachStatement -> foreachStatement.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTDoStatement.class).forEach(doStatement -> doStatement.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTWhileStatement.class).forEach(whileStatement -> whileStatement.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
            typeDeclaration.findDescendantsOfType(ASTTryStatement.class).forEach(tryStatement -> tryStatement.findDescendantsOfType(ASTClassOrInterfaceType.class).forEach(classOrInterfaceType -> addUsedImport(usedImports, onDemandImports, classOrInterfaceType)));
        });

        node.getImports().forEach(importDeclaration -> {
            if (importDeclaration.isStatic()) {
                return;
            }
            if (importDeclaration.isStarImport()) {
                onDemandImports.add(importDeclaration.getPackageName());
            } else {
                String importName = importDeclaration.getQualifiedReference().getAbsolutePath();
                if (isImplicitlyImported(importName, currentPackage) || usedImports.contains(importName)) {
                    return;
                }
                addViolation(data, importDeclaration);
            }
        });

        checkOnDemandImports(node, onDemandImports, usedImports);
        checkDuplicateImports(node);
        return data;
    }

    private void addUsedImport(Set<String> usedImports, Set<String> onDemandImports, ASTClassOrInterfaceType classOrInterfaceType) {
        String className = classOrInterfaceType.getName();
        String packageName = classOrInterfaceType.getType() instanceof JClassSymbol classSymbol ? classSymbol.getPackageName() : null;
        if (packageName != null && !classOrInterfaceType.isFullyQualified()) {
            usedImports.add(packageName + "." + className);
        }
        onDemandImports.stream().filter(packageName::startsWith).forEach(usedImports::add);
    }

    private void addUsedImportFromJavadoc(Set<String> usedImports, Set<String> onDemandImports, ASTJavadoc javadoc) {
        javadoc.findDescendantsOfType(ASTJavadocComment.class).stream()
               .map(ASTJavadocComment::getText)
               .flatMap(text -> Arrays.stream(text.split("\\s+")))
               .filter(comment -> comment.startsWith("{@linkplain") || comment.startsWith("{@link") || comment.startsWith("{@value") || comment.startsWith("@see") || comment.startsWith("@throws") || comment.startsWith("@exception"))
               .map(comment -> comment.replaceAll("[{}@#()]", "").trim())
               .filter(comment -> comment.contains("."))
               .flatMap(comment -> {
                   if (comment.contains("#")) {
                       String[] parts = comment.split("#");
                       return Arrays.stream(parts).limit(1);
                   }
                   return Stream.of(comment);
               })
               .forEach(importName -> {
                   if (!isImplicitlyImported(importName, null)) {
                       usedImports.add(importName);
                   }
                   onDemandImports.stream().filter(importName::startsWith).forEach(usedImports::add);
               });
    }

    private boolean isImplicitlyImported(String importName, JPackageSymbol currentPackage) {
        return importName.startsWith("java.lang") || (currentPackage != null && importName.startsWith(currentPackage.getQualifiedName()));
    }

    private void checkOnDemandImports(ASTCompilationUnit node, Set<String> onDemandImports, Set<String> usedImports) {
        Map<String, Integer> importCounts = new HashMap<>();
        node.getImports().forEach(importDeclaration -> {
            if (importDeclaration.isStarImport()) {
                String packageName = importDeclaration.getPackageName();
                importCounts.put(packageName, importCounts.getOrDefault(packageName, 0) + 1);
            }
        });

        onDemandImports.forEach(packageName -> {
            if (importCounts.getOrDefault(packageName, 0) > 1) {
                return;
            }
            if (usedImports.stream().noneMatch(className -> className.startsWith(packageName + "."))) {
                node.getImports().stream()
                    .filter(importDeclaration -> importDeclaration.isStarImport() && importDeclaration.getPackageName().equals(packageName))
                    .forEach(importDeclaration -> addViolation(importDeclaration));
            }
        });
    }

    private void checkDuplicateImports(ASTCompilationUnit node) {
        Map<String, List<ASTImportDeclaration>> importMap = new HashMap<>();
        node.getImports().forEach(importDeclaration -> {
            String importName = importDeclaration.getQualifiedReference().getAbsolutePath();
            importMap.computeIfAbsent(importName, k -> new ArrayList<>()).add(importDeclaration);
        });

        importMap.values().stream()
                 .filter(importDeclarations -> importDeclarations.size() > 1)
                 .forEach(importDeclarations -> importDeclarations.subList(1, importDeclarations.size()).forEach(importDeclaration -> addViolation(importDeclaration)));
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 302.27245259284973 秒
