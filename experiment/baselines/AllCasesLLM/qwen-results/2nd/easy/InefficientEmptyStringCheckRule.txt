开始

========================================== Rule InefficientEmptyStringCheckRule ===========================================
一共 18 个测试用例
正例 8 个
反例 10 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: String.trim().length() == 0 and String.trim().isEmpty() are inefficient ways to check if a String is really blank. Prevent it.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// test is ok, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.length() == 0) {
            // this is bad
        }
    }
}
```
2. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().length() == 0) {
            // this is bad
        }
    }
}
```
3. This is a positive test case
```java
// String.trim.length not is called, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().equals("")) {
        }
    }
}
```
4. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        while (foo.trim().length() == 0) {
        }
    }
}
```
5. This is a positive test case
```java
// String.trim.length is called, assigned to int, ok
public class Foo {
    void bar() {
        String foo = "foo";
        int i = foo.trim().length();
    }
}
```
6. This is a negative test case
```java
// String.trim.length is called, assigned to boolean, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 0;
    }
}
```
7. This is a positive test case
```java
// Using trim.length to find the length and compare to 1, OK
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 1;
    }
}
```
8. This is a positive test case
```java
// Passes trim().length() and 0 to another method
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length(), 0);
    }
}
```
9. This is a positive test case
```java
// Compares the length against a mathematical function
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length() == (2 - 1));
    }
}
```
10. This is a negative test case
```java
// String.trim().isEmpty() is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().isEmpty();
    }
}
```
11. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        int i = 2;
        b =  String.valueOf(i).trim().isEmpty();
    }
}
```
12. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed twice
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        b =  String.valueOf(2).trim().isEmpty();
    }
}
```
13. This is a positive test case
```java
// Verify no NPE is thrown
public class Foo extends SomeUnresolvedClass {
    void bar(String[] logLevels, String[] guardMethods) {
        if (super.guardStmtByLogLevel.isEmpty() && logLevels.length > 0 && guardMethods.length > 0) {
            configureGuards(logLevels, guardMethods);
        }
    }
}
```
14. This is a positive test case
```java
// Avoid NPE for pattern matching instanceof
public class PatternMatchingInstanceof {
    private String s = "other string";

    public void test() {
        Object obj = "abc";
        if (obj instanceof String s) {
            System.out.println("a) obj == s: " + (obj == s)); // true
        }
    }
}
```
15. This is a negative test case
```java
// [java] InefficientEmptyStringCheck false negative in anonymous class #1224
import javax.swing.*;
            import java.awt.event.KeyEvent;
            import java.awt.event.KeyListener;

            public class Main {
                public static void main(String[] args) {
                    final JPanel jPanel = new JPanel();
                    jPanel.addKeyListener(new KeyListener() {
                        @Override
                        public void keyTyped(KeyEvent e) {
                            final String val = "";
                            if (val.trim().length() > 0) {
                                System.out.println("Non-empty string.");
                            }
                        }

                        @Override
                        public void keyPressed(KeyEvent e) {
                        }

                        @Override
                        public void keyReleased(KeyEvent e) {
                        }
                    });
                }
            }
```
16. This is a negative test case
```java
// String.trim.isEmpty is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimIsEmpty {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().isEmpty()) {
            // violation
        }
        if (this.get().trim().isEmpty()) {
            // violation
        }

        String bar = get();
        if (bar.trim().isEmpty()) {
            // violation
        }
        if (bar.toString().trim().isEmpty()) {
            // violation
        }
    }
}
```
17. This is a negative test case
```java
// String.trim.length is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimLength {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().length() == 0) {
            // violation missing
        }
        if (this.get().trim().length() == 0) {
            // violation missing
        }

        String bar = get();
        if (bar.trim().length() == 0) {
            // violation already detected
        }
        if (bar.toString().trim().length() == 0) {
            // violation missing
        }
    }
}
```
18. This is a negative test case
```java
// String.trim.isEmpty and length called in method argument
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimMethodArgument {
    public String get() {
        return "foo";
    }
    public void bar() {
        String bar = "foo";
        System.out.println(bar.trim().isEmpty()); // violation missing
        System.out.println(bar.trim().length() == 0);
        System.out.println(get().trim().isEmpty()); // violation missing
        System.out.println(get().trim().length() == 0); // violation missing
        System.out.println(this.get().trim().isEmpty()); // violation missing
        System.out.println(this.get().trim().length() == 0); // violating missing
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: String.trim().length() == 0 and String.trim().isEmpty() are inefficient ways to check if a String is really blank. Prevent it.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// test is ok, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.length() == 0) {
            // this is bad
        }
    }
}
```
2. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().length() == 0) {
            // this is bad
        }
    }
}
```
3. This is a positive test case
```java
// String.trim.length not is called, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().equals("")) {
        }
    }
}
```
4. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        while (foo.trim().length() == 0) {
        }
    }
}
```
5. This is a positive test case
```java
// String.trim.length is called, assigned to int, ok
public class Foo {
    void bar() {
        String foo = "foo";
        int i = foo.trim().length();
    }
}
```
6. This is a negative test case
```java
// String.trim.length is called, assigned to boolean, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 0;
    }
}
```
7. This is a positive test case
```java
// Using trim.length to find the length and compare to 1, OK
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 1;
    }
}
```
8. This is a positive test case
```java
// Passes trim().length() and 0 to another method
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length(), 0);
    }
}
```
9. This is a positive test case
```java
// Compares the length against a mathematical function
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length() == (2 - 1));
    }
}
```
10. This is a negative test case
```java
// String.trim().isEmpty() is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().isEmpty();
    }
}
```
11. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        int i = 2;
        b =  String.valueOf(i).trim().isEmpty();
    }
}
```
12. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed twice
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        b =  String.valueOf(2).trim().isEmpty();
    }
}
```
13. This is a positive test case
```java
// Verify no NPE is thrown
public class Foo extends SomeUnresolvedClass {
    void bar(String[] logLevels, String[] guardMethods) {
        if (super.guardStmtByLogLevel.isEmpty() && logLevels.length > 0 && guardMethods.length > 0) {
            configureGuards(logLevels, guardMethods);
        }
    }
}
```
14. This is a positive test case
```java
// Avoid NPE for pattern matching instanceof
public class PatternMatchingInstanceof {
    private String s = "other string";

    public void test() {
        Object obj = "abc";
        if (obj instanceof String s) {
            System.out.println("a) obj == s: " + (obj == s)); // true
        }
    }
}
```
15. This is a negative test case
```java
// [java] InefficientEmptyStringCheck false negative in anonymous class #1224
import javax.swing.*;
            import java.awt.event.KeyEvent;
            import java.awt.event.KeyListener;

            public class Main {
                public static void main(String[] args) {
                    final JPanel jPanel = new JPanel();
                    jPanel.addKeyListener(new KeyListener() {
                        @Override
                        public void keyTyped(KeyEvent e) {
                            final String val = "";
                            if (val.trim().length() > 0) {
                                System.out.println("Non-empty string.");
                            }
                        }

                        @Override
                        public void keyPressed(KeyEvent e) {
                        }

                        @Override
                        public void keyReleased(KeyEvent e) {
                        }
                    });
                }
            }
```
16. This is a negative test case
```java
// String.trim.isEmpty is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimIsEmpty {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().isEmpty()) {
            // violation
        }
        if (this.get().trim().isEmpty()) {
            // violation
        }

        String bar = get();
        if (bar.trim().isEmpty()) {
            // violation
        }
        if (bar.toString().trim().isEmpty()) {
            // violation
        }
    }
}
```
17. This is a negative test case
```java
// String.trim.length is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimLength {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().length() == 0) {
            // violation missing
        }
        if (this.get().trim().length() == 0) {
            // violation missing
        }

        String bar = get();
        if (bar.trim().length() == 0) {
            // violation already detected
        }
        if (bar.toString().trim().length() == 0) {
            // violation missing
        }
    }
}
```
18. This is a negative test case
```java
// String.trim.isEmpty and length called in method argument
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimMethodArgument {
    public String get() {
        return "foo";
    }
    public void bar() {
        String bar = "foo";
        System.out.println(bar.trim().isEmpty()); // violation missing
        System.out.println(bar.trim().length() == 0);
        System.out.println(get().trim().isEmpty()); // violation missing
        System.out.println(get().trim().length() == 0); // violation missing
        System.out.println(this.get().trim().isEmpty()); // violation missing
        System.out.println(this.get().trim().length() == 0); // violating missing
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public InefficientEmptyStringCheckRule() {
        super(ASTEqualityExpression.class, ASTMethodCall.class, ASTAssignmentExpression.class, ASTConditionalExpression.class, ASTConditionalAndExpression.class, ASTConditionalOrExpression.class);
    }

    @Override
    public Object visit(ASTEqualityExpression node, Object data) {
        if (node.getLeftOperand() instanceof ASTMethodCall && node.getRightOperand() instanceof ASTLiteral) {
            ASTMethodCall leftMethodCall = (ASTMethodCall) node.getLeftOperand();
            ASTLiteral rightLiteral = (ASTLiteral) node.getRightOperand();
            if (rightLiteral.getValue().equals(0) && isTrimLengthCall(leftMethodCall)) {
                addViolation(data, node);
            }
        }
        if (node.getRightOperand() instanceof ASTMethodCall && node.getLeftOperand() instanceof ASTLiteral) {
            ASTMethodCall rightMethodCall = (ASTMethodCall) node.getRightOperand();
            ASTLiteral leftLiteral = (ASTLiteral) node.getLeftOperand();
            if (leftLiteral.getValue().equals(0) && isTrimLengthCall(rightMethodCall)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        if (isTrimLengthCall(node)) {
            ASTExpression parent = node.getFirstParentOfType(ASTExpression.class);
            if (parent != null && !(parent.isChildOf(ASTAssignmentExpression.class) || parent.isChildOf(ASTConditionalExpression.class) || parent.isChildOf(ASTConditionalAndExpression.class) || parent.isChildOf(ASTConditionalOrExpression.class))) {
                addViolation(data, node);
            }
        }
        if (isTrimIsEmptyCall(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAssignmentExpression node, Object data) {
        if (node.getRightOperand() instanceof ASTMethodCall && isTrimLengthCall((ASTMethodCall) node.getRightOperand())) {
            return data;
        }
        if (node.getRightOperand() instanceof ASTMethodCall && isTrimIsEmptyCall((ASTMethodCall) node.getRightOperand())) {
            return data;
        }
        return super.visit(node, data);
    }

    private boolean isTrimLengthCall(ASTMethodCall methodCall) {
        ASTPrimaryPrefix primaryPrefix = methodCall.getFirstParentOfType(ASTPrimaryPrefix.class);
        if (primaryPrefix != null) {
            ASTPrimaryExpression primaryExpression = primaryPrefix.getFirstParentOfType(ASTPrimaryExpression.class);
            if (primaryExpression != null) {
                ASTPrimarySuffix primarySuffix = primaryExpression.getFirstParentOfType(ASTPrimarySuffix.class);
                if (primarySuffix != null && "trim".equals(primarySuffix.getImage())) {
                    ASTMethodCall nextMethodCall = primarySuffix.getFirstParentOfType(ASTMethodCall.class);
                    if (nextMethodCall != null) {
                        ASTPrimarySuffix lengthSuffix = nextMethodCall.getFirstParentOfType(ASTPrimarySuffix.class);
                        return "length".equals(lengthSuffix.getImage());
                    }
                }
            }
        }
        return false;
    }

    private boolean isTrimIsEmptyCall(ASTMethodCall methodCall) {
        ASTPrimaryPrefix primaryPrefix = methodCall.getFirstParentOfType(ASTPrimaryPrefix.class);
        if (primaryPrefix != null) {
            ASTPrimaryExpression primaryExpression = primaryPrefix.getFirstParentOfType(ASTPrimaryExpression.class);
            if (primaryExpression != null) {
                ASTPrimarySuffix primarySuffix = primaryExpression.getFirstParentOfType(ASTPrimarySuffix.class);
                if (primarySuffix != null && "trim".equals(primarySuffix.getImage())) {
                    ASTPrimarySuffix isEmptySuffix = methodCall.getFirstChildOfType(ASTPrimarySuffix.class);
                    return "isEmpty".equals(isEmptySuffix.getImage());
                }
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: String.trim().length() == 0 and String.trim().isEmpty() are inefficient ways to check if a String is really blank. Prevent it.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// test is ok, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.length() == 0) {
            // this is bad
        }
    }
}
```
2. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().length() == 0) {
            // this is bad
        }
    }
}
```
3. This is a positive test case
```java
// String.trim.length not is called, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().equals("")) {
        }
    }
}
```
4. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        while (foo.trim().length() == 0) {
        }
    }
}
```
5. This is a positive test case
```java
// String.trim.length is called, assigned to int, ok
public class Foo {
    void bar() {
        String foo = "foo";
        int i = foo.trim().length();
    }
}
```
6. This is a negative test case
```java
// String.trim.length is called, assigned to boolean, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 0;
    }
}
```
7. This is a positive test case
```java
// Using trim.length to find the length and compare to 1, OK
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 1;
    }
}
```
8. This is a positive test case
```java
// Passes trim().length() and 0 to another method
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length(), 0);
    }
}
```
9. This is a positive test case
```java
// Compares the length against a mathematical function
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length() == (2 - 1));
    }
}
```
10. This is a negative test case
```java
// String.trim().isEmpty() is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().isEmpty();
    }
}
```
11. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        int i = 2;
        b =  String.valueOf(i).trim().isEmpty();
    }
}
```
12. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed twice
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        b =  String.valueOf(2).trim().isEmpty();
    }
}
```
13. This is a positive test case
```java
// Verify no NPE is thrown
public class Foo extends SomeUnresolvedClass {
    void bar(String[] logLevels, String[] guardMethods) {
        if (super.guardStmtByLogLevel.isEmpty() && logLevels.length > 0 && guardMethods.length > 0) {
            configureGuards(logLevels, guardMethods);
        }
    }
}
```
14. This is a positive test case
```java
// Avoid NPE for pattern matching instanceof
public class PatternMatchingInstanceof {
    private String s = "other string";

    public void test() {
        Object obj = "abc";
        if (obj instanceof String s) {
            System.out.println("a) obj == s: " + (obj == s)); // true
        }
    }
}
```
15. This is a negative test case
```java
// [java] InefficientEmptyStringCheck false negative in anonymous class #1224
import javax.swing.*;
            import java.awt.event.KeyEvent;
            import java.awt.event.KeyListener;

            public class Main {
                public static void main(String[] args) {
                    final JPanel jPanel = new JPanel();
                    jPanel.addKeyListener(new KeyListener() {
                        @Override
                        public void keyTyped(KeyEvent e) {
                            final String val = "";
                            if (val.trim().length() > 0) {
                                System.out.println("Non-empty string.");
                            }
                        }

                        @Override
                        public void keyPressed(KeyEvent e) {
                        }

                        @Override
                        public void keyReleased(KeyEvent e) {
                        }
                    });
                }
            }
```
16. This is a negative test case
```java
// String.trim.isEmpty is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimIsEmpty {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().isEmpty()) {
            // violation
        }
        if (this.get().trim().isEmpty()) {
            // violation
        }

        String bar = get();
        if (bar.trim().isEmpty()) {
            // violation
        }
        if (bar.toString().trim().isEmpty()) {
            // violation
        }
    }
}
```
17. This is a negative test case
```java
// String.trim.length is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimLength {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().length() == 0) {
            // violation missing
        }
        if (this.get().trim().length() == 0) {
            // violation missing
        }

        String bar = get();
        if (bar.trim().length() == 0) {
            // violation already detected
        }
        if (bar.toString().trim().length() == 0) {
            // violation missing
        }
    }
}
```
18. This is a negative test case
```java
// String.trim.isEmpty and length called in method argument
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimMethodArgument {
    public String get() {
        return "foo";
    }
    public void bar() {
        String bar = "foo";
        System.out.println(bar.trim().isEmpty()); // violation missing
        System.out.println(bar.trim().length() == 0);
        System.out.println(get().trim().isEmpty()); // violation missing
        System.out.println(get().trim().length() == 0); // violation missing
        System.out.println(this.get().trim().isEmpty()); // violation missing
        System.out.println(this.get().trim().length() == 0); // violating missing
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;
import java.util.Optional;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public InefficientEmptyStringCheckRule() {
        super(ASTExpression.class);
    }

    @Override
    public Object visit(ASTExpression node, Object data) {
        Optional<ASTMethodCall> methodCall = node.getFirstDescendantOfType(ASTMethodCall.class);
        if (methodCall.isPresent()) {
            JMethodSymbol methodSymbol = methodCall.get().getMethodNameDeclaration();
            if (methodSymbol != null && methodSymbol.getName().equals("trim")) {
                TypeSystem typeSystem = node.getTypeSystem();
                if (methodCall.get().getNextSiblingOfType(ASTPrimaryExpression.class) != null) {
                    ASTPrimaryExpression primaryExpression = methodCall.get().getNextSiblingOfType(ASTPrimaryExpression.class);
                    ASTPrimaryPrefix primaryPrefix = primaryExpression.getFirstDescendantOfType(ASTPrimaryPrefix.class);
                    if (primaryPrefix != null) {
                        Optional<ASTMethodCall> nextMethodCall = primaryPrefix.getFirstDescendantOfType(ASTMethodCall.class);
                        if (nextMethodCall.isPresent()) {
                            JMethodSymbol nextMethodSymbol = nextMethodCall.get().getMethodNameDeclaration();
                            if (nextMethodSymbol != null && nextMethodSymbol.getName().equals("isEmpty")) {
                                addViolation(data, node);
                            } else if (nextMethodSymbol != null && nextMethodSymbol.getName().equals("length")) {
                                if (node.getNextSiblingOfType(ASTPrimaryExpression.class) != null) {
                                    ASTPrimaryExpression nextPrimaryExpression = node.getNextSiblingOfType(ASTPrimaryExpression.class);
                                    if (nextPrimaryExpression.getFirstDescendantOfType(ASTPrimaryPrefix.class) != null) {
                                        ASTPrimaryPrefix nextPrimaryPrefix = nextPrimaryExpression.getFirstDescendantOfType(ASTPrimaryPrefix.class);
                                        if (nextPrimaryPrefix.getImage().equals("==") || nextPrimaryPrefix.getImage().equals("!=")) {
                                            addViolation(data, node);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: String.trim().length() == 0 and String.trim().isEmpty() are inefficient ways to check if a String is really blank. Prevent it.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// test is ok, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.length() == 0) {
            // this is bad
        }
    }
}
```
2. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().length() == 0) {
            // this is bad
        }
    }
}
```
3. This is a positive test case
```java
// String.trim.length not is called, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().equals("")) {
        }
    }
}
```
4. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        while (foo.trim().length() == 0) {
        }
    }
}
```
5. This is a positive test case
```java
// String.trim.length is called, assigned to int, ok
public class Foo {
    void bar() {
        String foo = "foo";
        int i = foo.trim().length();
    }
}
```
6. This is a negative test case
```java
// String.trim.length is called, assigned to boolean, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 0;
    }
}
```
7. This is a positive test case
```java
// Using trim.length to find the length and compare to 1, OK
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 1;
    }
}
```
8. This is a positive test case
```java
// Passes trim().length() and 0 to another method
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length(), 0);
    }
}
```
9. This is a positive test case
```java
// Compares the length against a mathematical function
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length() == (2 - 1));
    }
}
```
10. This is a negative test case
```java
// String.trim().isEmpty() is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().isEmpty();
    }
}
```
11. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        int i = 2;
        b =  String.valueOf(i).trim().isEmpty();
    }
}
```
12. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed twice
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        b =  String.valueOf(2).trim().isEmpty();
    }
}
```
13. This is a positive test case
```java
// Verify no NPE is thrown
public class Foo extends SomeUnresolvedClass {
    void bar(String[] logLevels, String[] guardMethods) {
        if (super.guardStmtByLogLevel.isEmpty() && logLevels.length > 0 && guardMethods.length > 0) {
            configureGuards(logLevels, guardMethods);
        }
    }
}
```
14. This is a positive test case
```java
// Avoid NPE for pattern matching instanceof
public class PatternMatchingInstanceof {
    private String s = "other string";

    public void test() {
        Object obj = "abc";
        if (obj instanceof String s) {
            System.out.println("a) obj == s: " + (obj == s)); // true
        }
    }
}
```
15. This is a negative test case
```java
// [java] InefficientEmptyStringCheck false negative in anonymous class #1224
import javax.swing.*;
            import java.awt.event.KeyEvent;
            import java.awt.event.KeyListener;

            public class Main {
                public static void main(String[] args) {
                    final JPanel jPanel = new JPanel();
                    jPanel.addKeyListener(new KeyListener() {
                        @Override
                        public void keyTyped(KeyEvent e) {
                            final String val = "";
                            if (val.trim().length() > 0) {
                                System.out.println("Non-empty string.");
                            }
                        }

                        @Override
                        public void keyPressed(KeyEvent e) {
                        }

                        @Override
                        public void keyReleased(KeyEvent e) {
                        }
                    });
                }
            }
```
16. This is a negative test case
```java
// String.trim.isEmpty is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimIsEmpty {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().isEmpty()) {
            // violation
        }
        if (this.get().trim().isEmpty()) {
            // violation
        }

        String bar = get();
        if (bar.trim().isEmpty()) {
            // violation
        }
        if (bar.toString().trim().isEmpty()) {
            // violation
        }
    }
}
```
17. This is a negative test case
```java
// String.trim.length is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimLength {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().length() == 0) {
            // violation missing
        }
        if (this.get().trim().length() == 0) {
            // violation missing
        }

        String bar = get();
        if (bar.trim().length() == 0) {
            // violation already detected
        }
        if (bar.toString().trim().length() == 0) {
            // violation missing
        }
    }
}
```
18. This is a negative test case
```java
// String.trim.isEmpty and length called in method argument
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimMethodArgument {
    public String get() {
        return "foo";
    }
    public void bar() {
        String bar = "foo";
        System.out.println(bar.trim().isEmpty()); // violation missing
        System.out.println(bar.trim().length() == 0);
        System.out.println(get().trim().isEmpty()); // violation missing
        System.out.println(get().trim().length() == 0); // violation missing
        System.out.println(this.get().trim().isEmpty()); // violation missing
        System.out.println(this.get().trim().length() == 0); // violating missing
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public InefficientEmptyStringCheckRule() {
        super(ASTExpression.class, ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTExpression node, Object data) {
        if (node instanceof ASTPrimaryExpression) {
            ASTPrimaryExpression primaryExpression = (ASTPrimaryExpression) node;
            if (primaryExpression.getFirstChildOfType(ASTPrimarySuffix.class) != null) {
                ASTPrimarySuffix suffix = primaryExpression.getFirstChildOfType(ASTPrimarySuffix.class);
                if (suffix.isArguments()) {
                    ASTMethodCall methodCall = suffix.getFirstChildOfType(ASTMethodCall.class);
                    if (methodCall != null && isTrimCall(methodCall)) {
                        NodeStream<ASTPrimarySuffix> suffixes = methodCall.getNextSiblings(ASTPrimarySuffix.class);
                        ASTPrimarySuffix nextSuffix = suffixes.first();
                        if (nextSuffix != null && nextSuffix.isArguments()) {
                            ASTMethodCall nextMethodCall = nextSuffix.getFirstChildOfType(ASTMethodCall.class);
                            if (nextMethodCall != null && isLengthOrIsEmptyCall(nextMethodCall)) {
                                addViolation(data, nextMethodCall);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        if (isTrimCall(node)) {
            NodeStream<ASTPrimarySuffix> suffixes = node.getNextSiblings(ASTPrimarySuffix.class);
            ASTPrimarySuffix nextSuffix = suffixes.first();
            if (nextSuffix != null && nextSuffix.isArguments()) {
                ASTMethodCall nextMethodCall = nextSuffix.getFirstChildOfType(ASTMethodCall.class);
                if (nextMethodCall != null && isLengthOrIsEmptyCall(nextMethodCall)) {
                    addViolation(data, nextMethodCall);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isTrimCall(ASTMethodCall methodCall) {
        ASTReceiver receiver = methodCall.getFirstChildOfType(ASTReceiver.class);
        if (receiver != null && receiver.getType() != null && receiver.getType().isSubtypeOf(JType.STRING_TYPE)) {
            JMethodSymbol symbol = methodCall.getMethodSymbol();
            return symbol != null && symbol.getName().equals("trim") && symbol.getParameterTypes().isEmpty();
        }
        return false;
    }

    private boolean isLengthOrIsEmptyCall(ASTMethodCall methodCall) {
        ASTReceiver receiver = methodCall.getFirstChildOfType(ASTReceiver.class);
        if (receiver != null && receiver.getType() != null && receiver.getType().isSubtypeOf(JType.STRING_TYPE)) {
            JMethodSymbol symbol = methodCall.getMethodSymbol();
            return symbol != null && (symbol.getName().equals("length") || symbol.getName().equals("isEmpty")) && symbol.getParameterTypes().isEmpty();
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: String.trim().length() == 0 and String.trim().isEmpty() are inefficient ways to check if a String is really blank. Prevent it.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// test is ok, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.length() == 0) {
            // this is bad
        }
    }
}
```
2. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().length() == 0) {
            // this is bad
        }
    }
}
```
3. This is a positive test case
```java
// String.trim.length not is called, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().equals("")) {
        }
    }
}
```
4. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        while (foo.trim().length() == 0) {
        }
    }
}
```
5. This is a positive test case
```java
// String.trim.length is called, assigned to int, ok
public class Foo {
    void bar() {
        String foo = "foo";
        int i = foo.trim().length();
    }
}
```
6. This is a negative test case
```java
// String.trim.length is called, assigned to boolean, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 0;
    }
}
```
7. This is a positive test case
```java
// Using trim.length to find the length and compare to 1, OK
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 1;
    }
}
```
8. This is a positive test case
```java
// Passes trim().length() and 0 to another method
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length(), 0);
    }
}
```
9. This is a positive test case
```java
// Compares the length against a mathematical function
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length() == (2 - 1));
    }
}
```
10. This is a negative test case
```java
// String.trim().isEmpty() is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().isEmpty();
    }
}
```
11. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        int i = 2;
        b =  String.valueOf(i).trim().isEmpty();
    }
}
```
12. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed twice
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        b =  String.valueOf(2).trim().isEmpty();
    }
}
```
13. This is a positive test case
```java
// Verify no NPE is thrown
public class Foo extends SomeUnresolvedClass {
    void bar(String[] logLevels, String[] guardMethods) {
        if (super.guardStmtByLogLevel.isEmpty() && logLevels.length > 0 && guardMethods.length > 0) {
            configureGuards(logLevels, guardMethods);
        }
    }
}
```
14. This is a positive test case
```java
// Avoid NPE for pattern matching instanceof
public class PatternMatchingInstanceof {
    private String s = "other string";

    public void test() {
        Object obj = "abc";
        if (obj instanceof String s) {
            System.out.println("a) obj == s: " + (obj == s)); // true
        }
    }
}
```
15. This is a negative test case
```java
// [java] InefficientEmptyStringCheck false negative in anonymous class #1224
import javax.swing.*;
            import java.awt.event.KeyEvent;
            import java.awt.event.KeyListener;

            public class Main {
                public static void main(String[] args) {
                    final JPanel jPanel = new JPanel();
                    jPanel.addKeyListener(new KeyListener() {
                        @Override
                        public void keyTyped(KeyEvent e) {
                            final String val = "";
                            if (val.trim().length() > 0) {
                                System.out.println("Non-empty string.");
                            }
                        }

                        @Override
                        public void keyPressed(KeyEvent e) {
                        }

                        @Override
                        public void keyReleased(KeyEvent e) {
                        }
                    });
                }
            }
```
16. This is a negative test case
```java
// String.trim.isEmpty is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimIsEmpty {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().isEmpty()) {
            // violation
        }
        if (this.get().trim().isEmpty()) {
            // violation
        }

        String bar = get();
        if (bar.trim().isEmpty()) {
            // violation
        }
        if (bar.toString().trim().isEmpty()) {
            // violation
        }
    }
}
```
17. This is a negative test case
```java
// String.trim.length is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimLength {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().length() == 0) {
            // violation missing
        }
        if (this.get().trim().length() == 0) {
            // violation missing
        }

        String bar = get();
        if (bar.trim().length() == 0) {
            // violation already detected
        }
        if (bar.toString().trim().length() == 0) {
            // violation missing
        }
    }
}
```
18. This is a negative test case
```java
// String.trim.isEmpty and length called in method argument
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimMethodArgument {
    public String get() {
        return "foo";
    }
    public void bar() {
        String bar = "foo";
        System.out.println(bar.trim().isEmpty()); // violation missing
        System.out.println(bar.trim().length() == 0);
        System.out.println(get().trim().isEmpty()); // violation missing
        System.out.println(get().trim().length() == 0); // violation missing
        System.out.println(this.get().trim().isEmpty()); // violation missing
        System.out.println(this.get().trim().length() == 0); // violating missing
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public InefficientEmptyStringCheckRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        if (isTrimLengthCheck(node) || isTrimIsEmptyCheck(node)) {
            addViolation(data, node);
        }
        return super.visit(node, data);
    }

    private boolean isTrimLengthCheck(ASTMethodCall node) {
        return isLengthCall(node) && isTrimCall(node.getParent().jjtGetParent());
    }

    private boolean isTrimIsEmptyCheck(ASTMethodCall node) {
        return isIsEmptyCall(node) && isTrimCall(node.getParent());
    }

    private boolean isLengthCall(ASTMethodCall node) {
        return "length".equals(node.getName()) && node.getType() == JavaType.INT;
    }

    private boolean isIsEmptyCall(ASTMethodCall node) {
        return "isEmpty".equals(node.getName()) && node.getType() == JavaType.BOOLEAN;
    }

    private boolean isTrimCall(ASTPrimaryExpression primaryExpression) {
        if (primaryExpression.jjtGetNumChildren() != 2) {
            return false;
        }
        ASTReference reference = (ASTReference) primaryExpression.jjtGetChild(0);
        ASTPrimarySuffix suffix = (ASTPrimarySuffix) primaryExpression.jjtGetChild(1);
        return suffix.getName().equals("trim") && reference.getType() == JavaType.STRING;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: String.trim().length() == 0 and String.trim().isEmpty() are inefficient ways to check if a String is really blank. Prevent it.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// test is ok, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.length() == 0) {
            // this is bad
        }
    }
}
```
2. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().length() == 0) {
            // this is bad
        }
    }
}
```
3. This is a positive test case
```java
// String.trim.length not is called, ok
public class Foo {
    void bar() {
        String foo = "foo";
        if (foo.trim().equals("")) {
        }
    }
}
```
4. This is a negative test case
```java
// String.trim.length is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        while (foo.trim().length() == 0) {
        }
    }
}
```
5. This is a positive test case
```java
// String.trim.length is called, assigned to int, ok
public class Foo {
    void bar() {
        String foo = "foo";
        int i = foo.trim().length();
    }
}
```
6. This is a negative test case
```java
// String.trim.length is called, assigned to boolean, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 0;
    }
}
```
7. This is a positive test case
```java
// Using trim.length to find the length and compare to 1, OK
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().length() == 1;
    }
}
```
8. This is a positive test case
```java
// Passes trim().length() and 0 to another method
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length(), 0);
    }
}
```
9. This is a positive test case
```java
// Compares the length against a mathematical function
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo(foo.trim().length() == (2 - 1));
    }
}
```
10. This is a negative test case
```java
// String.trim().isEmpty() is called, should have failed
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b = foo.trim().isEmpty();
    }
}
```
11. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        int i = 2;
        b =  String.valueOf(i).trim().isEmpty();
    }
}
```
12. This is a negative test case
```java
// String.trim().isEmpty() is called after a chain call, should have failed twice
import java.util.Arrays;
public class Foo {
    void bar() {
        String foo = "foo";
        boolean b =  Arrays.toString(foo.toCharArray()).trim().isEmpty();
        b =  String.valueOf(2).trim().isEmpty();
    }
}
```
13. This is a positive test case
```java
// Verify no NPE is thrown
public class Foo extends SomeUnresolvedClass {
    void bar(String[] logLevels, String[] guardMethods) {
        if (super.guardStmtByLogLevel.isEmpty() && logLevels.length > 0 && guardMethods.length > 0) {
            configureGuards(logLevels, guardMethods);
        }
    }
}
```
14. This is a positive test case
```java
// Avoid NPE for pattern matching instanceof
public class PatternMatchingInstanceof {
    private String s = "other string";

    public void test() {
        Object obj = "abc";
        if (obj instanceof String s) {
            System.out.println("a) obj == s: " + (obj == s)); // true
        }
    }
}
```
15. This is a negative test case
```java
// [java] InefficientEmptyStringCheck false negative in anonymous class #1224
import javax.swing.*;
            import java.awt.event.KeyEvent;
            import java.awt.event.KeyListener;

            public class Main {
                public static void main(String[] args) {
                    final JPanel jPanel = new JPanel();
                    jPanel.addKeyListener(new KeyListener() {
                        @Override
                        public void keyTyped(KeyEvent e) {
                            final String val = "";
                            if (val.trim().length() > 0) {
                                System.out.println("Non-empty string.");
                            }
                        }

                        @Override
                        public void keyPressed(KeyEvent e) {
                        }

                        @Override
                        public void keyReleased(KeyEvent e) {
                        }
                    });
                }
            }
```
16. This is a negative test case
```java
// String.trim.isEmpty is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimIsEmpty {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().isEmpty()) {
            // violation
        }
        if (this.get().trim().isEmpty()) {
            // violation
        }

        String bar = get();
        if (bar.trim().isEmpty()) {
            // violation
        }
        if (bar.toString().trim().isEmpty()) {
            // violation
        }
    }
}
```
17. This is a negative test case
```java
// String.trim.length is called on method result, should have failed
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimLength {
    String get() {
        return "foo";
    }
    void bar() {
        if (get().trim().length() == 0) {
            // violation missing
        }
        if (this.get().trim().length() == 0) {
            // violation missing
        }

        String bar = get();
        if (bar.trim().length() == 0) {
            // violation already detected
        }
        if (bar.toString().trim().length() == 0) {
            // violation missing
        }
    }
}
```
18. This is a negative test case
```java
// String.trim.isEmpty and length called in method argument
package net.sourceforge.pmd.lang.java.rule.performance.inefficientemptystringcheck;
public class StringTrimMethodArgument {
    public String get() {
        return "foo";
    }
    public void bar() {
        String bar = "foo";
        System.out.println(bar.trim().isEmpty()); // violation missing
        System.out.println(bar.trim().length() == 0);
        System.out.println(get().trim().isEmpty()); // violation missing
        System.out.println(get().trim().length() == 0); // violation missing
        System.out.println(this.get().trim().isEmpty()); // violation missing
        System.out.println(this.get().trim().length() == 0); // violating missing
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class InefficientEmptyStringCheckRule extends AbstractJavaRulechainRule {

    public InefficientEmptyStringCheckRule() {
        super(ASTMethodCall.class);
    }

    @Override
    public Object visit(ASTMethodCall node, Object data) {
        JMethodSymbol methodSymbol = node.getMethodSymbol();
        if (methodSymbol != null) {
            String methodName = methodSymbol.getName();
            if ("trim".equals(methodName)) {
                ASTPrimaryExpression primaryExpression = node.getFirstParentOfType(ASTPrimaryExpression.class);
                if (primaryExpression != null) {
                    NodeStream<ASTPrimarySuffix> suffixes = primaryExpression.stream(ASTPrimarySuffix.class);
                    suffixes.filter(ASTPrimarySuffix::isMethodCall)
                            .map(ASTPrimarySuffix::getMethodCall)
                            .filter(this::isInefficientLengthCheck)
                            .forEach(n -> addViolation(data, n));
                    suffixes.filter(ASTPrimarySuffix::isMethodCall)
                            .map(ASTPrimarySuffix::getMethodCall)
                            .filter(this::isInefficientIsEmptyCheck)
                            .forEach(n -> addViolation(data, n));
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isInefficientLengthCheck(ASTMethodCall methodCall) {
        JMethodSymbol methodSymbol = methodCall.getMethodSymbol();
        if (methodSymbol != null && "length".equals(methodSymbol.getName())) {
            ASTExpression parentExpression = methodCall.getFirstParentOfType(ASTExpression.class);
            if (parentExpression != null) {
                return parentExpression.stream(ASTExpression.class)
                        .filter(expr -> expr instanceof ASTPrimaryExpression)
                        .map(ASTPrimaryExpression.class::cast)
                        .stream(ASTPrimarySuffix.class)
                        .filter(ASTPrimarySuffix::isEqualityExpression)
                        .map(ASTPrimarySuffix.class::cast)
                        .filter(suffix -> suffix.getOperator() == ASTPrimarySuffix.EqualityExpressionType.EQUALS)
                        .map(suffix -> suffix.getExpression(1))
                        .anyMatch(expr -> expr instanceof ASTStringLiteral && "".equals(((ASTStringLiteral) expr).getValue()));
            }
        }
        return false;
    }

    private boolean isInefficientIsEmptyCheck(ASTMethodCall methodCall) {
        JMethodSymbol methodSymbol = methodCall.getMethodSymbol();
        if (methodSymbol != null && "isEmpty".equals(methodSymbol.getName())) {
            return true;
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 174.71155977249146 秒
