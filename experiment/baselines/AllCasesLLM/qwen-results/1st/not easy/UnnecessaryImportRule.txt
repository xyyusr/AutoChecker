开始

========================================== Rule UnnecessaryImportRule ===========================================
一共 73 个测试用例
正例 50 个
反例 23 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class, ASTImportDeclaration.class, ASTStaticImportDeclaration.class, ASTClassOrInterfaceDeclaration.class, ASTMethodDeclaration.class, ASTReferenceType.class, ASTName.class);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        Set<AppliedImport> allImports = new HashSet<>();
        node.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
        node.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));
        TypeSystem typeSystem = node.getTypeSystem();
        JPackageSymbol currentPackage = node.getPackageName() != null ? typeSystem.resolvePackage(node.getPackageName()) : typeSystem.resolvePackage("");

        node.getImports().forEach(importDecl -> {
            JClassSymbol importedSymbol = importDecl.getImportedSymbol();
            if (importedSymbol == null) return;
            if (currentPackage == importedSymbol.getPackage() || importedSymbol.getPackage() == typeSystem.resolvePackage("java.lang")) {
                addViolation(importDecl);
                return;
            }
            if (allImports.stream().noneMatch(appliedImport -> appliedImport.isUsed(importedSymbol))) {
                addViolation(importDecl);
            }
        });

        node.getStaticImports().forEach(staticImportDecl -> {
            JClassSymbol importedSymbol = staticImportDecl.getImportedSymbol();
            if (importedSymbol == null) return;
            if (allImports.stream().noneMatch(appliedImport -> appliedImport.isUsed(importedSymbol))) {
                addViolation(staticImportDecl);
            }
        });

        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTReferenceType node, Object data) {
        JType type = node.getType();
        if (type instanceof JClassSymbol) {
            ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
            Set<AppliedImport> allImports = new HashSet<>();
            compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
            compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

            JClassSymbol symbol = (JClassSymbol) type;
            allImports.forEach(appliedImport -> appliedImport.markUsed(symbol));
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTName node, Object data) {
        JClassSymbol currentClass = node.getFirstParentOfType(ASTCompilationUnit.class).getPrimaryDeclaration().getSymbol();
        if (currentClass == null) return data;
        TypeSystem typeSystem = currentClass.getTypeSystem();

        String name = node.getImage();
        if (typeSystem.resolveClass(name) != null) {
            ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
            Set<AppliedImport> allImports = new HashSet<>();
            compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
            compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

            JClassSymbol symbol = typeSystem.resolveClass(name);
            allImports.forEach(appliedImport -> appliedImport.markUsed(symbol));
        }

        if (node.getParent() instanceof ASTReferenceType) {
            JType type = ((ASTReferenceType) node.getParent()).getType();
            if (type instanceof JClassSymbol) {
                JClassSymbol symbol = (JClassSymbol) type;
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(symbol));
            }
        }

        if (node.getParent() instanceof ASTMethodReference) {
            ASTMethodReference methodRef = (ASTMethodReference) node.getParent();
            JMethodSymbol methodSymbol = methodRef.resolveMethod();
            if (methodSymbol != null) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(methodSymbol.getEnclosingClass()));
            }
        }

        if (node.getParent() instanceof ASTConstructorCall) {
            ASTConstructorCall constructorCall = (ASTConstructorCall) node.getParent();
            JClassSymbol classSymbol = constructorCall.getType().getSymbol();
            if (classSymbol != null) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
            }
        }

        if (node.getParent() instanceof ASTAnnotation) {
            ASTAnnotation annotation = (ASTAnnotation) node.getParent();
            JClassSymbol classSymbol = annotation.getType().getSymbol();
            if (classSymbol != null) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
            }
        }

        if (node.getParent() instanceof ASTThrowsClause) {
            ASTThrowsClause throwsClause = (ASTThrowsClause) node.getParent();
            JClassSymbol classSymbol = throwsClause.getExceptionType().getSymbol();
            if (classSymbol != null) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
            }
        }

        if (node.getParent() instanceof ASTMethodDeclaration) {
            ASTMethodDeclaration methodDecl = (ASTMethodDeclaration) node.getParent();
            methodDecl.getFormalParameters().forEach(param -> {
                JClassSymbol classSymbol = param.getType().getSymbol();
                if (classSymbol != null) {
                    ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                    Set<AppliedImport> allImports = new HashSet<>();
                    compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                    compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                    allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
                }
            });
        }

        if (node.getParent() instanceof ASTFieldDeclaration) {
            ASTFieldDeclaration fieldDecl = (ASTFieldDeclaration) node.getParent();
            JClassSymbol classSymbol = fieldDecl.getType().getSymbol();
            if (classSymbol != null) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
            }
        }

        if (node.getParent() instanceof ASTVariableDeclarator) {
            ASTVariableDeclarator varDecl = (ASTVariableDeclarator) node.getParent();
            JClassSymbol classSymbol = varDecl.getType().getSymbol();
            if (classSymbol != null) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
            }
        }

        if (node.getParent() instanceof ASTClassOrInterfaceType) {
            ASTClassOrInterfaceType classType = (ASTClassOrInterfaceType) node.getParent();
            JClassSymbol classSymbol = classType.getSymbol();
            if (classSymbol != null) {
                ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                Set<AppliedImport> allImports = new HashSet<>();
                compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
            }
        }

        if (node.getParent() instanceof ASTVariableDeclaratorId) {
            ASTVariableDeclaratorId varId = (ASTVariableDeclaratorId) node.getParent();
            ASTVariableDeclarator varDecl = varId.getFirstParentOfType(ASTVariableDeclarator.class);
            if (varDecl != null) {
                JClassSymbol classSymbol = varDecl.getType().getSymbol();
                if (classSymbol != null) {
                    ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                    Set<AppliedImport> allImports = new HashSet<>();
                    compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                    compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                    allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
                }
            }
        }

        if (node.getParent() instanceof ASTJavadoc) {
            ASTJavadoc javadoc = (ASTJavadoc) node.getParent();
            NodeStream<ASTJavadocTag> tags = javadoc.getTags();
            tags.forEach(tag -> {
                String tagName = tag.getName();
                if ("link".equals(tagName) || "linkplain".equals(tagName) || "see".equals(tagName) || "value".equals(tagName)) {
                    String reference = tag.getFirstChildOfType(ASTName.class).getImage();
                    if (reference.contains("#")) {
                        String className = reference.substring(0, reference.indexOf("#"));
                        JClassSymbol classSymbol = node.getTypeSystem().resolveClass(className);
                        if (classSymbol != null) {
                            ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                            Set<AppliedImport> allImports = new HashSet<>();
                            compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                            compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                            allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
                        }
                    } else {
                        JClassSymbol classSymbol = node.getTypeSystem().resolveClass(reference);
                        if (classSymbol != null) {
                            ASTCompilationUnit compilationUnit = node.getFirstParentOfType(ASTCompilationUnit.class);
                            Set<AppliedImport> allImports = new HashSet<>();
                            compilationUnit.getImports().forEach(importDecl -> allImports.addAll(importDecl.getAppliedImports()));
                            compilationUnit.getStaticImports().forEach(staticImportDecl -> allImports.addAll(staticImportDecl.getAppliedImports()));

                            allImports.forEach(appliedImport -> appliedImport.markUsed(classSymbol));
                        }
                    }
                }
            });
        }

        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;


import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class, ASTImportDeclaration.class, ASTVariableDeclaratorId.class, ASTClassOrInterfaceType.class, ASTMethodDeclaration.class, ASTMethodReference.class, ASTAnnotation.class, ASTThrowStatement.class, ASTTryStatement.class, ASTCatchClause.class, ASTForStatement.class, ASTEnhancedForStatement.class, ASTType.class, ASTGenericType.class, ASTJavadoc.class, ASTJavadocTag.class, ASTJavadocType.class, ASTJavadocLink.class, ASTJavadocSnippet.class);
    }

    private Set<ASTImportDeclaration> usedImports = new HashSet<>();
    private Set<ASTImportDeclaration> allImports = new HashSet<>();
    private Set<String> importNames = new HashSet<>();
    private Set<String> staticImportNames = new HashSet<>();
    private String currentPackageName;

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        usedImports.clear();
        allImports.clear();
        importNames.clear();
        staticImportNames.clear();
        currentPackageName = node.getPackageName();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        allImports.add(node);
        importNames.add(node.getImportedName());
        if (node.isStatic()) {
            staticImportNames.add(node.getImportedName());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTVariableDeclaratorId node, Object data) {
        checkUsage(node.getType().getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceType node, Object data) {
        checkUsage(node.getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        for (ASTClassOrInterfaceType type : node.findDescendantsOfType(ASTClassOrInterfaceType.class)) {
            checkUsage(type.getImage());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodReference node, Object data) {
        checkUsage(node.getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAnnotation node, Object data) {
        checkUsage(node.getType().getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTThrowStatement node, Object data) {
        for (ASTClassOrInterfaceType type : node.findDescendantsOfType(ASTClassOrInterfaceType.class)) {
            checkUsage(type.getImage());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTryStatement node, Object data) {
        for (ASTCatchClause clause : node.findDescendantsOfType(ASTCatchClause.class)) {
            for (ASTClassOrInterfaceType type : clause.findDescendantsOfType(ASTClassOrInterfaceType.class)) {
                checkUsage(type.getImage());
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        for (ASTClassOrInterfaceType type : node.findDescendantsOfType(ASTClassOrInterfaceType.class)) {
            checkUsage(type.getImage());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTEnhancedForStatement node, Object data) {
        for (ASTClassOrInterfaceType type : node.findDescendantsOfType(ASTClassOrInterfaceType.class)) {
            checkUsage(type.getImage());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTType node, Object data) {
        checkUsage(node.getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTGenericType node, Object data) {
        checkUsage(node.getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTJavadoc node, Object data) {
        for (ASTJavadocTag tag : node.findDescendantsOfType(ASTJavadocTag.class)) {
            for (ASTJavadocType javadocType : tag.findDescendantsOfType(ASTJavadocType.class)) {
                checkUsage(javadocType.getImage());
            }
            for (ASTJavadocLink javadocLink : tag.findDescendantsOfType(ASTJavadocLink.class)) {
                checkUsage(javadocLink.getReference().getImage());
            }
        }
        for (ASTJavadocSnippet snippet : node.findDescendantsOfType(ASTJavadocSnippet.class)) {
            for (ASTName name : snippet.findDescendantsOfType(ASTName.class)) {
                checkUsage(name.getImage());
            }
        }
        return super.visit(node, data);
    }

    private void checkUsage(String name) {
        if (name == null) return;
        if (name.contains("*")) return;

        String simpleName = getSimpleName(name);
        if (isInSamePackage(simpleName) || isInJavaLang(simpleName)) return;

        for (ASTImportDeclaration importDecl : allImports) {
            if (importDecl.getImportedName().endsWith(simpleName) && !importDecl.isStatic()) {
                usedImports.add(importDecl);
            }
        }
    }

    private String getSimpleName(String name) {
        String[] parts = name.split("\\.");
        return parts[parts.length - 1];
    }

    private boolean isInSamePackage(String simpleName) {
        if (currentPackageName == null || currentPackageName.isEmpty()) return false;
        try {
            JClassSymbol symbol = getSymbolForSimpleName(simpleName);
            if (symbol != null && currentPackageName.equals(symbol.getPackageName())) {
                return true;
            }
        } catch (Exception e) {
            // ignore
        }
        return false;
    }

    private boolean isInJavaLang(String simpleName) {
        try {
            JClassSymbol symbol = getSymbolForSimpleName(simpleName);
            if (symbol != null && "java.lang".equals(symbol.getPackageName())) {
                return true;
            }
        } catch (Exception e) {
            // ignore
        }
        return false;
    }

    private JClassSymbol getSymbolForSimpleName(String simpleName) {
        return getSymbols().findClass(simpleName);
    }

    private TypeSystem getSymbols() {
        return getCurrentScope().getTypeSystem();
    }

    @Override
    public void end(ASTCompilationUnit node) {
        Set<ASTImportDeclaration> toRemove = new HashSet<>(allImports);
        toRemove.removeAll(usedImports);

        for (ASTImportDeclaration importDecl : toRemove) {
            if (importDecl.isStatic()) {
                String staticName = importDecl.getImportedName();
                String[] parts = staticName.split("\\.");
                String memberName = parts[parts.length - 1];
                for (ASTImportDeclaration otherImportDecl : allImports) {
                    if (otherImportDecl.isStatic() && otherImportDecl.getImportedName().endsWith("." + memberName)) {
                        usedImports.add(otherImportDecl);
                        toRemove.remove(importDecl);
                        break;
                    }
                }
            }
        }

        for (ASTImportDeclaration importDecl : toRemove) {
            addViolation(data, importDecl);
        }
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

出现语法错误，这一轮舍弃，直接重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {

    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class, ASTImportDeclaration.class, ASTName.class, ASTType.class, ASTAnnotation.class, ASTLiteral.class, ASTMethodReference.class, ASTPrimaryExpression.class, ASTMethodDeclaration.class, ASTConstructorDeclaration.class, ASTFieldDeclaration.class, ASTFormalParameter.class, ASTClassOrInterfaceBodyDeclaration.class, ASTThrowsClause.class, ASTForStatement.class, ASTGenericType.class, ASTTypeParameter.class, ASTBlockComment.class, ASTJavadocComment.class);
    }

    private Set<String> usedImports = new HashSet<>();
    private Set<String> wildcardImports = new HashSet<>();
    private Set<String> staticImports = new HashSet<>();
    private SymbolTable symbolTable;

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        usedImports.clear();
        wildcardImports.clear();
        staticImports.clear();
        symbolTable = new SymbolTableImpl(node);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        if (node.isWildcard()) {
            wildcardImports.add(node.getPackageName());
        }
        if (node.isStatic()) {
            staticImports.add(node.getImportedName());
        } else {
            usedImports.add(node.getImportedName());
        }
        return super.visit(node, data);
    }

    private void checkUsage(String name) {
        if (TypeTestUtil.isImplicit(name) || usedImports.contains(name) || wildcardImports.stream().anyMatch(name::startsWith)) {
            usedImports.add(name);
        }
    }

    @Override
    public Object visit(ASTName node, Object data) {
        checkUsage(node.getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTType node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTAnnotation node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLiteral node, Object data) {
        if (node.isEnumLiteral()) {
            String[] parts = node.getTypeMirror().getSymbol().getQualifiedName().split("\\.");
            checkUsage(parts[parts.length - 1]);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodReference node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTPrimaryExpression node, Object data) {
        if (node.getFirstChildOfType(ASTName.class) != null) {
            checkUsage(node.getFirstChildOfType(ASTName.class).getImage());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorDeclaration node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldDeclaration node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFormalParameter node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBodyDeclaration node, Object data) {
        if (node instanceof ASTThrowsClause) {
            node.descendants(ASTClassOrInterfaceType.class).forEach(type -> checkUsage(type.getTypeMirror().getSymbol().getQualifiedName()));
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTForStatement node, Object data) {
        node.descendants(ASTGenericType.class).forEach(type -> checkUsage(type.getTypeMirror().getSymbol().getQualifiedName()));
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTGenericType node, Object data) {
        checkUsage(node.getTypeMirror().getSymbol().getQualifiedName());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTypeParameter node, Object data) {
        node.descendants(ASTClassOrInterfaceType.class).forEach(type -> checkUsage(type.getTypeMirror().getSymbol().getQualifiedName()));
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBlockComment node, Object data) {
        checkJavadoc(node.getImage());
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTJavadocComment node, Object data) {
        checkJavadoc(node.getImage());
        return super.visit(node, data);
    }

    private void checkJavadoc(String javadoc) {
        String[] parts = javadoc.split("[\\s\\n]+");
        for (String part : parts) {
            if (part.contains("{@link") || part.contains("{@linkplain") || part.contains("{@value") || part.contains("{@see") || part.contains("{@snippet")) {
                part = part.replaceAll("[{}@linkplain\\s]+", "");
                if (part.contains("#")) {
                    part = part.substring(0, part.indexOf("#"));
                }
                if (part.contains(".")) {
                    checkUsage(part);
                }
            }
        }
    }

    @Override
    public void end(ASTCompilationUnit node, Object data) {
        Set<String> allImports = new HashSet<>();
        node.descendants(ASTImportDeclaration.class).forEach(importDecl -> {
            String importName = importDecl.getImportedName();
            if (!importDecl.isStatic()) {
                allImports.add(importName);
            }
        });

        allImports.forEach(importName -> {
            if (usedImports.stream().noneMatch(importName::startsWith) && !TypeTestUtil.isImplicit(importName)) {
                addViolation(importName, importDecl);
            }
        });

        Set<String> allStaticImports = new HashSet<>();
        node.descendants(ASTImportDeclaration.class).forEach(importDecl -> {
            if (importDecl.isStatic()) {
                allStaticImports.add(importDecl.getImportedName());
            }
        });

        allStaticImports.forEach(importName -> {
            if (!staticImports.contains(importName)) {
                addViolation(importName, importDecl);
            }
        });
    }

    private void addViolation(String importName, ASTImportDeclaration importDecl) {
        if (importDecl.isOnDemand()) {
            importName = importName.substring(0, importName.lastIndexOf("."));
        }
        addViolation(importDecl, "Unused import: " + importName);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.HashSet;
import java.util.Set;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public UnnecessaryImportRule() {
        super(ASTCompilationUnit.class, ASTImportDeclaration.class, ASTClassOrInterfaceBody.class, ASTAnnotation.class, ASTMethodDeclaration.class);
    }

    private Set<String> usedTypes;
    private Set<String> usedStaticMembers;
    private List<String> imports;
    private Map<String, Integer> importCount;

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        usedTypes = new HashSet<>();
        usedStaticMembers = new HashSet<>();
        imports = new ArrayList<>();
        importCount = new HashMap<>();
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        if (node.isStatic()) {
            String symbolName = node.getImportedName().getFullyQualifiedName();
            usedStaticMembers.add(symbolName);
        } else {
            String symbolName = node.getImportedName().getFullyQualifiedName();
            imports.add(symbolName);
            importCount.put(symbolName, importCount.getOrDefault(symbolName, 0) + 1);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        processClassOrInterfaceBody(node);
        return super.visit(node, data);
    }

    private void processClassOrInterfaceBody(ASTClassOrInterfaceBody node) {
        for (ASTReferenceType type : node.findDescendantsOfType(ASTReferenceType.class)) {
            JClassType classType = type.getType();
            if (classType != null) {
                usedTypes.add(classType.getName());
            }
        }
        for (ASTFormalParameter param : node.findDescendantsOfType(ASTFormalParameter.class)) {
            usedTypes.add(param.getType().getType().getName());
        }
        for (ASTCatchClause catchClause : node.findDescendantsOfType(ASTCatchClause.class)) {
            usedTypes.add(catchClause.getParameter().getType().getType().getName());
        }
    }

    @Override
    public Object visit(ASTAnnotation node, Object data) {
        JClassType annotationType = node.getType();
        if (annotationType != null) {
            usedTypes.add(annotationType.getName());
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        processMethodDeclaration(node);
        return super.visit(node, data);
    }

    private void processMethodDeclaration(ASTMethodDeclaration node) {
        for (ASTReferenceType type : node.findDescendantsOfType(ASTReferenceType.class)) {
            JClassType classType = type.getType();
            if (classType != null) {
                usedTypes.add(classType.getName());
            }
        }
        for (ASTFormalParameter param : node.findDescendantsOfType(ASTFormalParameter.class)) {
            usedTypes.add(param.getType().getType().getName());
        }
        for (ASTCatchClause catchClause : node.findDescendantsOfType(ASTCatchClause.class)) {
            usedTypes.add(catchClause.getParameter().getType().getType().getName());
        }
        for (ASTName name : node.findDescendantsOfType(ASTName.class)) {
            JTypeSymbol sym = name.getType();
            if (sym instanceof JClassSymbol) {
                usedTypes.add(((JClassSymbol) sym).getQualifiedName());
            }
        }
    }

    @Override
    public void end(ASTCompilationUnit node, Object data) {
        Set<String> usedImports = new HashSet<>();
        for (String importStr : imports) {
            if (importStr.endsWith(".*")) {
                String packageName = importStr.substring(0, importStr.length() - 2);
                for (String usedType : usedTypes) {
                    if (isInPackage(usedType, packageName)) {
                        usedImports.add(importStr);
                    }
                }
            } else {
                if (usedTypes.contains(importStr.substring(importStr.lastIndexOf('.') + 1))) {
                    usedImports.add(importStr);
                }
            }
        }
        for (String importStr : imports) {
            if (!usedImports.contains(importStr) && importCount.get(importStr) == 1) {
                addViolation(data, findImportNode(importStr, node));
            }
        }
    }

    private boolean isInPackage(String className, String packageName) {
        SymbolResolver resolver = getSymbolResolver();
        JClassSymbol classSymbol = resolver.lookupClass(className);
        if (classSymbol != null) {
            JPackageSymbol packageSymbol = classSymbol.getEnclosingPackage();
            return packageSymbol != null && packageSymbol.getQualifiedName().equals(packageName);
        }
        return false;
    }

    private ASTImportDeclaration findImportNode(String importStr, ASTCompilationUnit cu) {
        for (ASTImportDeclaration importDec : cu.findDescendantsOfType(ASTImportDeclaration.class)) {
            if (importDec.getImportedName().getFullyQualifiedName().equals(importStr)) {
                return importDec;
            }
        }
        return null;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 272.7958548069 秒
