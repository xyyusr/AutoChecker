开始

========================================== Rule BrokenNullCheckRule ===========================================
一共 25 个测试用例
正例 15 个
反例 10 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
```
2. This is a positive test case
```java
// Ok, is &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null && !list.equals(buz)) {
            return list;
        }
    }
}
```
3. This is a negative test case
```java
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
```
4. This is a negative test case
```java
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
```
5. This is a positive test case
```java
// Ok, is ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null || list.equals(buz)) {
            return list;
        }
    }
}
```
6. This is a positive test case
```java
// Arrays are Ok
public class Foo {
    String[] books;
    void bar(int index) {
        if (index >= 0 && books[index] == null) { }
    }
}
```
7. This is a positive test case
```java
// Different method is Ok
public class Book {
    Book[] books;
    String getJane() { return null; }
    String getEyre() { return null; }
    void bar(int i) {
        if (books[i].getJane() == null &&
            books[i].getEyre() == null) { }
    }
}
```
8. This is a positive test case
```java
// Using a shorter expression with the same variable in the second check should not crash the test
public class Book {
    Book[] books;
    String getJane() { return null; }
    void bar(String eyre) {
        if (books.getJane() == null &&
            books == eyre) { }
    }
}
```
9. This is a negative test case
```java
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
```
10. This is a positive test case
```java
// 1633683, Arrays are Ok II
public class Foo {
    void bar(String[] p) {
        if (p.length > 1 && p[0] == null) { }
    }
}
```
11. This is a positive test case
```java
// Different literals in variables should not match
public class Foo {
    String getJane() { return null; }
    void bar(Foo[] p) {
        if (p[0] == null && p[1].getJane()) { }
    }
}
```
12. This is a positive test case
```java
// Assignments in checks are OK
public class Book {
    Book[] books;
    Book[] getBook(int i) {return books;}
    void bar(int janeEyre) {
        if (books == null &&
            (books = getBook(janeEyre)) == null) { }
    }
}
```
13. This is a positive test case
```java
// Useless code, but it will not throw a NullPointerException
public class Family {
    String plain, bold;
    void bar(Family family) {
        if (family.plain == null && family.bold == null &&
           family.plain == null && family.bold == null) { }
    }
}
```
14. This is a positive test case
```java
// Similar method calls with different arguments are OK
import my.Jane;
import my.Eyre;
public class Library {
    String[] getBook(Class<?> i) {return null;}
    void bar(Library library) {
        if (library.getBooks(Jane.class) != null ||
            library.getBooks(Eyre.class) != null) { }
    }
}
```
15. This is a positive test case
```java
// #3071 BrokenNullCheck FP
class Test{
                Object obj = new Object(), objectWithDifferentName = obj;

                public void testPMD(){
                    Object obj = new Object();
                    String str = "str";

                    //Case 1. : An Alarm is generated
                    if(obj == null && !(obj instanceof String));

                    //Case 3.
                    if(obj == null && this.obj == null); //An Alarm is generated
                    if(obj == null && this.objectWithDifferentName); //An Alarm isn't generated
                    if(obj == null && objectWithDifferentName); //An Alarm isn't generated
                }
            }
```
16. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
```
17. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null && boo != true;  // ok
                    result = boo != null && boo != false; // ok
                    result = boo != null && boo == true;  // ok
                    result = boo != null && boo == false; // ok

                }
            }
```
18. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null || boo != true;  // ok
                    result = boo == null || boo != false; // ok
                    result = boo == null || boo == true;  // ok
                    result = boo == null || boo == false; // ok

                }
            }
```
19. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null || boo != true;  // second expression will throw
                    result = boo != null || boo != false; // second expression will throw
                    result = boo != null || boo == true;  // second expression will throw
                    result = boo != null || boo == false; // second expression will throw

                }
            }
```
20. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null && boo;          // same
                }
            }
```
21. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){
                    Test boo = null;

                    boolean result;
                    result = boo == null && handle(boo::toString);           // method reference
                    result = boo == null && boo.toString();                  // method call
                    result = boo == null && boo.field.field.hashCode() == 0; // field access
                    result = boo == null && boo.new Inner().isEmpty();       // qualified ctor call

                }
            }
```
22. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){

                    boolean result;

                    int[] arr = null;

                    result = arr == null && arr[i] == 0;                     // array access
                }
            }
```
23. This is a positive test case
```java
// #3071 BrokenNullCheck FPs (2)
import java.util.*;

            class Test {

                Test foo = new Test(), another = new Test();
                Map<String, String> map;
                String field;
                int idx;
                String[] arr, anotherArr;

                Object foo(Object o) {}

                public void testPMD() {
                    //Case 1.
                    if ((foo == null) != (another == null) || foo != null && !foo.equals(another)) {
                        ;
                    }

                    //Case 2.
                    if (map.remove(null) != null || map.remove("") != null) {
                        ;
                    }
                    if (foo(foo) != null || foo(foo.field) != null) {
                        ;
                    }

                    //Case 3.
                    if (foo != null || foo == null && another != null && another.hashCode() == 0) {
                        ;
                    }

                    //Case 4.
                    if (null != arr[idx] || null == arr[idx] && !anotherArr[idx].isEmpty()) {
                        ;
                    }
                }
            }
```
24. This is a negative test case
```java
// BrokenNullCheck with unboxing, unboxing this operand will throw a NullPointerException
class Test {
                public void testPMD(Integer i){
                    boolean result;
                    result = i == null && i == 0;
                    result = i == null && i << 1;
                    result = i == null && i + 0;
                    result = i == null && i == 0.d;
                }
            }
```
25. This is a positive test case
```java
// Comparing two boxed things does not unbox
class Test {
                public void testPMD(Integer i, Integer d){
                    boolean result;
                    result = i == null && i == d;
                    result = i == null && i != d;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
```
2. This is a positive test case
```java
// Ok, is &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null && !list.equals(buz)) {
            return list;
        }
    }
}
```
3. This is a negative test case
```java
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
```
4. This is a negative test case
```java
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
```
5. This is a positive test case
```java
// Ok, is ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null || list.equals(buz)) {
            return list;
        }
    }
}
```
6. This is a positive test case
```java
// Arrays are Ok
public class Foo {
    String[] books;
    void bar(int index) {
        if (index >= 0 && books[index] == null) { }
    }
}
```
7. This is a positive test case
```java
// Different method is Ok
public class Book {
    Book[] books;
    String getJane() { return null; }
    String getEyre() { return null; }
    void bar(int i) {
        if (books[i].getJane() == null &&
            books[i].getEyre() == null) { }
    }
}
```
8. This is a positive test case
```java
// Using a shorter expression with the same variable in the second check should not crash the test
public class Book {
    Book[] books;
    String getJane() { return null; }
    void bar(String eyre) {
        if (books.getJane() == null &&
            books == eyre) { }
    }
}
```
9. This is a negative test case
```java
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
```
10. This is a positive test case
```java
// 1633683, Arrays are Ok II
public class Foo {
    void bar(String[] p) {
        if (p.length > 1 && p[0] == null) { }
    }
}
```
11. This is a positive test case
```java
// Different literals in variables should not match
public class Foo {
    String getJane() { return null; }
    void bar(Foo[] p) {
        if (p[0] == null && p[1].getJane()) { }
    }
}
```
12. This is a positive test case
```java
// Assignments in checks are OK
public class Book {
    Book[] books;
    Book[] getBook(int i) {return books;}
    void bar(int janeEyre) {
        if (books == null &&
            (books = getBook(janeEyre)) == null) { }
    }
}
```
13. This is a positive test case
```java
// Useless code, but it will not throw a NullPointerException
public class Family {
    String plain, bold;
    void bar(Family family) {
        if (family.plain == null && family.bold == null &&
           family.plain == null && family.bold == null) { }
    }
}
```
14. This is a positive test case
```java
// Similar method calls with different arguments are OK
import my.Jane;
import my.Eyre;
public class Library {
    String[] getBook(Class<?> i) {return null;}
    void bar(Library library) {
        if (library.getBooks(Jane.class) != null ||
            library.getBooks(Eyre.class) != null) { }
    }
}
```
15. This is a positive test case
```java
// #3071 BrokenNullCheck FP
class Test{
                Object obj = new Object(), objectWithDifferentName = obj;

                public void testPMD(){
                    Object obj = new Object();
                    String str = "str";

                    //Case 1. : An Alarm is generated
                    if(obj == null && !(obj instanceof String));

                    //Case 3.
                    if(obj == null && this.obj == null); //An Alarm is generated
                    if(obj == null && this.objectWithDifferentName); //An Alarm isn't generated
                    if(obj == null && objectWithDifferentName); //An Alarm isn't generated
                }
            }
```
16. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
```
17. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null && boo != true;  // ok
                    result = boo != null && boo != false; // ok
                    result = boo != null && boo == true;  // ok
                    result = boo != null && boo == false; // ok

                }
            }
```
18. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null || boo != true;  // ok
                    result = boo == null || boo != false; // ok
                    result = boo == null || boo == true;  // ok
                    result = boo == null || boo == false; // ok

                }
            }
```
19. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null || boo != true;  // second expression will throw
                    result = boo != null || boo != false; // second expression will throw
                    result = boo != null || boo == true;  // second expression will throw
                    result = boo != null || boo == false; // second expression will throw

                }
            }
```
20. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null && boo;          // same
                }
            }
```
21. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){
                    Test boo = null;

                    boolean result;
                    result = boo == null && handle(boo::toString);           // method reference
                    result = boo == null && boo.toString();                  // method call
                    result = boo == null && boo.field.field.hashCode() == 0; // field access
                    result = boo == null && boo.new Inner().isEmpty();       // qualified ctor call

                }
            }
```
22. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){

                    boolean result;

                    int[] arr = null;

                    result = arr == null && arr[i] == 0;                     // array access
                }
            }
```
23. This is a positive test case
```java
// #3071 BrokenNullCheck FPs (2)
import java.util.*;

            class Test {

                Test foo = new Test(), another = new Test();
                Map<String, String> map;
                String field;
                int idx;
                String[] arr, anotherArr;

                Object foo(Object o) {}

                public void testPMD() {
                    //Case 1.
                    if ((foo == null) != (another == null) || foo != null && !foo.equals(another)) {
                        ;
                    }

                    //Case 2.
                    if (map.remove(null) != null || map.remove("") != null) {
                        ;
                    }
                    if (foo(foo) != null || foo(foo.field) != null) {
                        ;
                    }

                    //Case 3.
                    if (foo != null || foo == null && another != null && another.hashCode() == 0) {
                        ;
                    }

                    //Case 4.
                    if (null != arr[idx] || null == arr[idx] && !anotherArr[idx].isEmpty()) {
                        ;
                    }
                }
            }
```
24. This is a negative test case
```java
// BrokenNullCheck with unboxing, unboxing this operand will throw a NullPointerException
class Test {
                public void testPMD(Integer i){
                    boolean result;
                    result = i == null && i == 0;
                    result = i == null && i << 1;
                    result = i == null && i + 0;
                    result = i == null && i == 0.d;
                }
            }
```
25. This is a positive test case
```java
// Comparing two boxed things does not unbox
class Test {
                public void testPMD(Integer i, Integer d){
                    boolean result;
                    result = i == null && i == d;
                    result = i == null && i != d;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {

    public BrokenNullCheckRule() {
        super(ASTBinaryExpression.class);
    }

    @Override
    public Object visit(ASTBinaryExpression node, Object data) {
        TypeSystem ts = node.getTypes();
        SymbolTable st = node.getSymbolTable();

        if (node.getOperator() == ASTBinaryExpression.Operator.OR) {
            NodeStream<ASTBinaryExpression> subExpressions = node.findDescendantsOfType(ASTBinaryExpression.class);
            for (ASTBinaryExpression subExpression : subExpressions) {
                if (subExpression.getOperator() == ASTBinaryExpression.Operator.AND && ts.isSubtype(subExpression.getLeftOperand().getType(), ts.OBJECT_TYPE) && ts.isSubtype(subExpression.getRightOperand().getType(), ts.OBJECT_TYPE)) {
                    if (isBrokenNullCheck(subExpression)) {
                        addViolation(data, subExpression);
                    }
                }
            }
        } else if (node.getOperator() == ASTBinaryExpression.Operator.AND) {
            if (isBrokenNullCheck(node)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    private boolean isBrokenNullCheck(ASTBinaryExpression node) {
        TypeSystem ts = node.getTypes();
        SymbolTable st = node.getSymbolTable();

        ASTPrimaryExpression leftOperand = node.getLeftOperand();
        ASTPrimaryExpression rightOperand = node.getRightOperand();

        boolean leftIsNullCheck = isNullCheck(leftOperand);
        boolean rightIsNullCheck = isNullCheck(rightOperand);

        if (leftIsNullCheck && !rightIsNullCheck && willThrowNPE(rightOperand)) {
            return true;
        } else if (!leftIsNullCheck && rightIsNullCheck && willThrowNPE(leftOperand)) {
            return true;
        }
        return false;
    }

    private boolean isNullCheck(ASTPrimaryExpression node) {
        ASTBinaryExpression parent = node.getFirstParentOfType(ASTBinaryExpression.class);
        if (parent != null) {
            ASTPrimaryExpression otherOperand = parent.getLeftOperand() == node ? parent.getRightOperand() : parent.getLeftOperand();
            if (otherOperand instanceof ASTLiteral) {
                ASTLiteral literal = (ASTLiteral) otherOperand;
                return literal.getLiteralValue().equals("null");
            }
        }
        return false;
    }

    private boolean willThrowNPE(ASTPrimaryExpression node) {
        if (node instanceof ASTPrimaryPrefix) {
            ASTPrimaryPrefix prefix = (ASTPrimaryPrefix) node;
            if (prefix.getFirstChildOfType(ASTName.class) != null) {
                return true;
            }
        } else if (node instanceof ASTPrimarySuffix) {
            ASTPrimarySuffix suffix = (ASTPrimarySuffix) node;
            if (suffix.getFirstChildOfType(ASTMethodCall.class) != null || suffix.getFirstChildOfType(ASTFieldAccess.class) != null || suffix.getFirstChildOfType(ASTArrayAccess.class) != null) {
                return true;
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
```
2. This is a positive test case
```java
// Ok, is &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null && !list.equals(buz)) {
            return list;
        }
    }
}
```
3. This is a negative test case
```java
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
```
4. This is a negative test case
```java
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
```
5. This is a positive test case
```java
// Ok, is ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null || list.equals(buz)) {
            return list;
        }
    }
}
```
6. This is a positive test case
```java
// Arrays are Ok
public class Foo {
    String[] books;
    void bar(int index) {
        if (index >= 0 && books[index] == null) { }
    }
}
```
7. This is a positive test case
```java
// Different method is Ok
public class Book {
    Book[] books;
    String getJane() { return null; }
    String getEyre() { return null; }
    void bar(int i) {
        if (books[i].getJane() == null &&
            books[i].getEyre() == null) { }
    }
}
```
8. This is a positive test case
```java
// Using a shorter expression with the same variable in the second check should not crash the test
public class Book {
    Book[] books;
    String getJane() { return null; }
    void bar(String eyre) {
        if (books.getJane() == null &&
            books == eyre) { }
    }
}
```
9. This is a negative test case
```java
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
```
10. This is a positive test case
```java
// 1633683, Arrays are Ok II
public class Foo {
    void bar(String[] p) {
        if (p.length > 1 && p[0] == null) { }
    }
}
```
11. This is a positive test case
```java
// Different literals in variables should not match
public class Foo {
    String getJane() { return null; }
    void bar(Foo[] p) {
        if (p[0] == null && p[1].getJane()) { }
    }
}
```
12. This is a positive test case
```java
// Assignments in checks are OK
public class Book {
    Book[] books;
    Book[] getBook(int i) {return books;}
    void bar(int janeEyre) {
        if (books == null &&
            (books = getBook(janeEyre)) == null) { }
    }
}
```
13. This is a positive test case
```java
// Useless code, but it will not throw a NullPointerException
public class Family {
    String plain, bold;
    void bar(Family family) {
        if (family.plain == null && family.bold == null &&
           family.plain == null && family.bold == null) { }
    }
}
```
14. This is a positive test case
```java
// Similar method calls with different arguments are OK
import my.Jane;
import my.Eyre;
public class Library {
    String[] getBook(Class<?> i) {return null;}
    void bar(Library library) {
        if (library.getBooks(Jane.class) != null ||
            library.getBooks(Eyre.class) != null) { }
    }
}
```
15. This is a positive test case
```java
// #3071 BrokenNullCheck FP
class Test{
                Object obj = new Object(), objectWithDifferentName = obj;

                public void testPMD(){
                    Object obj = new Object();
                    String str = "str";

                    //Case 1. : An Alarm is generated
                    if(obj == null && !(obj instanceof String));

                    //Case 3.
                    if(obj == null && this.obj == null); //An Alarm is generated
                    if(obj == null && this.objectWithDifferentName); //An Alarm isn't generated
                    if(obj == null && objectWithDifferentName); //An Alarm isn't generated
                }
            }
```
16. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
```
17. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null && boo != true;  // ok
                    result = boo != null && boo != false; // ok
                    result = boo != null && boo == true;  // ok
                    result = boo != null && boo == false; // ok

                }
            }
```
18. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null || boo != true;  // ok
                    result = boo == null || boo != false; // ok
                    result = boo == null || boo == true;  // ok
                    result = boo == null || boo == false; // ok

                }
            }
```
19. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null || boo != true;  // second expression will throw
                    result = boo != null || boo != false; // second expression will throw
                    result = boo != null || boo == true;  // second expression will throw
                    result = boo != null || boo == false; // second expression will throw

                }
            }
```
20. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null && boo;          // same
                }
            }
```
21. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){
                    Test boo = null;

                    boolean result;
                    result = boo == null && handle(boo::toString);           // method reference
                    result = boo == null && boo.toString();                  // method call
                    result = boo == null && boo.field.field.hashCode() == 0; // field access
                    result = boo == null && boo.new Inner().isEmpty();       // qualified ctor call

                }
            }
```
22. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){

                    boolean result;

                    int[] arr = null;

                    result = arr == null && arr[i] == 0;                     // array access
                }
            }
```
23. This is a positive test case
```java
// #3071 BrokenNullCheck FPs (2)
import java.util.*;

            class Test {

                Test foo = new Test(), another = new Test();
                Map<String, String> map;
                String field;
                int idx;
                String[] arr, anotherArr;

                Object foo(Object o) {}

                public void testPMD() {
                    //Case 1.
                    if ((foo == null) != (another == null) || foo != null && !foo.equals(another)) {
                        ;
                    }

                    //Case 2.
                    if (map.remove(null) != null || map.remove("") != null) {
                        ;
                    }
                    if (foo(foo) != null || foo(foo.field) != null) {
                        ;
                    }

                    //Case 3.
                    if (foo != null || foo == null && another != null && another.hashCode() == 0) {
                        ;
                    }

                    //Case 4.
                    if (null != arr[idx] || null == arr[idx] && !anotherArr[idx].isEmpty()) {
                        ;
                    }
                }
            }
```
24. This is a negative test case
```java
// BrokenNullCheck with unboxing, unboxing this operand will throw a NullPointerException
class Test {
                public void testPMD(Integer i){
                    boolean result;
                    result = i == null && i == 0;
                    result = i == null && i << 1;
                    result = i == null && i + 0;
                    result = i == null && i == 0.d;
                }
            }
```
25. This is a positive test case
```java
// Comparing two boxed things does not unbox
class Test {
                public void testPMD(Integer i, Integer d){
                    boolean result;
                    result = i == null && i == d;
                    result = i == null && i != d;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {

    public BrokenNullCheckRule() {
        super(ASTBinaryExpression.class);
    }

    @Override
    public Object visit(ASTBinaryExpression node, Object data) {
        if (node.isComparison()) {
            JType type = node.getType();
            if (type != null && !type.isArray() && !type.isPrimitive()) {
                ASTBinaryExpression left = node.getLeftOperand();
                ASTBinaryExpression right = node.getRightOperand();

                if (left.isComparison() && right.isComparison()) {
                    if (isBrokenNullCheck(left, right)) {
                        addViolation(data, node);
                    }
                } else if (left.isComparison() || right.isComparison()) {
                    if (isBrokenNullCheck(left, right)) {
                        addViolation(data, node);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isBrokenNullCheck(ASTExpression left, ASTExpression right) {
        if (left instanceof ASTBinaryExpression && right instanceof ASTBinaryExpression) {
            ASTBinaryExpression leftBinExpr = (ASTBinaryExpression) left;
            ASTBinaryExpression rightBinExpr = (ASTBinaryExpression) right;

            boolean leftNullCheck = isNullCheck(leftBinExpr);
            boolean rightNullCheck = isNullCheck(rightBinExpr);

            if (leftNullCheck && rightNullCheck) {
                return isBrokenNullCheck(leftBinExpr, rightBinExpr);
            } else if (leftNullCheck && !rightNullCheck) {
                return isBrokenNullCheck(leftBinExpr, right);
            } else if (!leftNullCheck && rightNullCheck) {
                return isBrokenNullCheck(left, rightBinExpr);
            }
        } else if (left instanceof ASTBinaryExpression) {
            return isBrokenNullCheck((ASTBinaryExpression) left, right);
        } else if (right instanceof ASTBinaryExpression) {
            return isBrokenNullCheck(left, (ASTBinaryExpression) right);
        }
        return false;
    }

    private boolean isBrokenNullCheck(ASTBinaryExpression nullCheck, ASTExpression otherExpr) {
        if (otherExpr instanceof ASTBinaryExpression) {
            ASTBinaryExpression otherBinExpr = (ASTBinaryExpression) otherExpr;
            return isNullCheck(nullCheck) && !isNullCheck(otherBinExpr) && willThrowNPE(otherBinExpr);
        }
        return false;
    }

    private boolean isBrokenNullCheck(ASTBinaryExpression left, ASTBinaryExpression right) {
        return isNullCheck(left) && !isNullCheck(right) && willThrowNPE(right) ||
               isNullCheck(right) && !isNullCheck(left) && willThrowNPE(left);
    }

    private boolean isNullCheck(ASTBinaryExpression expr) {
        return expr.isComparison() && (expr.getOperator() == ASTBinaryExpression.Operator.EQ || expr.getOperator() == ASTBinaryExpression.Operator.NE) &&
               (expr.getLeftOperand().isLiteralOrNull() || expr.getRightOperand().isLiteralOrNull());
    }

    private boolean willThrowNPE(ASTExpression expr) {
        if (expr instanceof ASTMethodCall) {
            ASTMethodCall methodCall = (ASTMethodCall) expr;
            if (!methodCall.isSafe()) {
                return true;
            }
        } else if (expr instanceof ASTPrimaryExpression) {
            ASTPrimaryExpression primaryExpr = (ASTPrimaryExpression) expr;
            if (primaryExpr.jjtGetNumChildren() > 1 && primaryExpr.jjtGetChild(primaryExpr.jjtGetNumChildren() - 1) instanceof ASTPrimarySuffix) {
                ASTPrimarySuffix suffix = (ASTPrimarySuffix) primaryExpr.jjtGetChild(primaryExpr.jjtGetNumChildren() - 1);
                if (suffix.isFieldAccess() || suffix.isArrayAccess() || suffix.isMethodCall()) {
                    return true;
                }
            }
        } else if (expr instanceof ASTReference) {
            ASTReference reference = (ASTReference) expr;
            if (reference.jjtGetNumChildren() > 1 && reference.jjtGetChild(reference.jjtGetNumChildren() - 1) instanceof ASTPrimarySuffix) {
                ASTPrimarySuffix suffix = (ASTPrimarySuffix) reference.jjtGetChild(reference.jjtGetNumChildren() - 1);
                if (suffix.isFieldAccess() || suffix.isArrayAccess() || suffix.isMethodCall()) {
                    return true;
                }
            }
        } else if (expr instanceof ASTVariableDeclaratorId) {
            ASTVariableDeclaratorId varId = (ASTVariableDeclaratorId) expr;
            JVariableSymbol varSymbol = varId.getSymbol();
            if (varSymbol != null && varSymbol.getType().getBoxedType().equals(varSymbol.getType())) {
                return false;
            }
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
```
2. This is a positive test case
```java
// Ok, is &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null && !list.equals(buz)) {
            return list;
        }
    }
}
```
3. This is a negative test case
```java
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
```
4. This is a negative test case
```java
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
```
5. This is a positive test case
```java
// Ok, is ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null || list.equals(buz)) {
            return list;
        }
    }
}
```
6. This is a positive test case
```java
// Arrays are Ok
public class Foo {
    String[] books;
    void bar(int index) {
        if (index >= 0 && books[index] == null) { }
    }
}
```
7. This is a positive test case
```java
// Different method is Ok
public class Book {
    Book[] books;
    String getJane() { return null; }
    String getEyre() { return null; }
    void bar(int i) {
        if (books[i].getJane() == null &&
            books[i].getEyre() == null) { }
    }
}
```
8. This is a positive test case
```java
// Using a shorter expression with the same variable in the second check should not crash the test
public class Book {
    Book[] books;
    String getJane() { return null; }
    void bar(String eyre) {
        if (books.getJane() == null &&
            books == eyre) { }
    }
}
```
9. This is a negative test case
```java
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
```
10. This is a positive test case
```java
// 1633683, Arrays are Ok II
public class Foo {
    void bar(String[] p) {
        if (p.length > 1 && p[0] == null) { }
    }
}
```
11. This is a positive test case
```java
// Different literals in variables should not match
public class Foo {
    String getJane() { return null; }
    void bar(Foo[] p) {
        if (p[0] == null && p[1].getJane()) { }
    }
}
```
12. This is a positive test case
```java
// Assignments in checks are OK
public class Book {
    Book[] books;
    Book[] getBook(int i) {return books;}
    void bar(int janeEyre) {
        if (books == null &&
            (books = getBook(janeEyre)) == null) { }
    }
}
```
13. This is a positive test case
```java
// Useless code, but it will not throw a NullPointerException
public class Family {
    String plain, bold;
    void bar(Family family) {
        if (family.plain == null && family.bold == null &&
           family.plain == null && family.bold == null) { }
    }
}
```
14. This is a positive test case
```java
// Similar method calls with different arguments are OK
import my.Jane;
import my.Eyre;
public class Library {
    String[] getBook(Class<?> i) {return null;}
    void bar(Library library) {
        if (library.getBooks(Jane.class) != null ||
            library.getBooks(Eyre.class) != null) { }
    }
}
```
15. This is a positive test case
```java
// #3071 BrokenNullCheck FP
class Test{
                Object obj = new Object(), objectWithDifferentName = obj;

                public void testPMD(){
                    Object obj = new Object();
                    String str = "str";

                    //Case 1. : An Alarm is generated
                    if(obj == null && !(obj instanceof String));

                    //Case 3.
                    if(obj == null && this.obj == null); //An Alarm is generated
                    if(obj == null && this.objectWithDifferentName); //An Alarm isn't generated
                    if(obj == null && objectWithDifferentName); //An Alarm isn't generated
                }
            }
```
16. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
```
17. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null && boo != true;  // ok
                    result = boo != null && boo != false; // ok
                    result = boo != null && boo == true;  // ok
                    result = boo != null && boo == false; // ok

                }
            }
```
18. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null || boo != true;  // ok
                    result = boo == null || boo != false; // ok
                    result = boo == null || boo == true;  // ok
                    result = boo == null || boo == false; // ok

                }
            }
```
19. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null || boo != true;  // second expression will throw
                    result = boo != null || boo != false; // second expression will throw
                    result = boo != null || boo == true;  // second expression will throw
                    result = boo != null || boo == false; // second expression will throw

                }
            }
```
20. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null && boo;          // same
                }
            }
```
21. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){
                    Test boo = null;

                    boolean result;
                    result = boo == null && handle(boo::toString);           // method reference
                    result = boo == null && boo.toString();                  // method call
                    result = boo == null && boo.field.field.hashCode() == 0; // field access
                    result = boo == null && boo.new Inner().isEmpty();       // qualified ctor call

                }
            }
```
22. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){

                    boolean result;

                    int[] arr = null;

                    result = arr == null && arr[i] == 0;                     // array access
                }
            }
```
23. This is a positive test case
```java
// #3071 BrokenNullCheck FPs (2)
import java.util.*;

            class Test {

                Test foo = new Test(), another = new Test();
                Map<String, String> map;
                String field;
                int idx;
                String[] arr, anotherArr;

                Object foo(Object o) {}

                public void testPMD() {
                    //Case 1.
                    if ((foo == null) != (another == null) || foo != null && !foo.equals(another)) {
                        ;
                    }

                    //Case 2.
                    if (map.remove(null) != null || map.remove("") != null) {
                        ;
                    }
                    if (foo(foo) != null || foo(foo.field) != null) {
                        ;
                    }

                    //Case 3.
                    if (foo != null || foo == null && another != null && another.hashCode() == 0) {
                        ;
                    }

                    //Case 4.
                    if (null != arr[idx] || null == arr[idx] && !anotherArr[idx].isEmpty()) {
                        ;
                    }
                }
            }
```
24. This is a negative test case
```java
// BrokenNullCheck with unboxing, unboxing this operand will throw a NullPointerException
class Test {
                public void testPMD(Integer i){
                    boolean result;
                    result = i == null && i == 0;
                    result = i == null && i << 1;
                    result = i == null && i + 0;
                    result = i == null && i == 0.d;
                }
            }
```
25. This is a positive test case
```java
// Comparing two boxed things does not unbox
class Test {
                public void testPMD(Integer i, Integer d){
                    boolean result;
                    result = i == null && i == d;
                    result = i == null && i != d;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.List;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class, ASTConditionalExpression.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        analyzeCondition(node.getCondition(), node, data);
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConditionalExpression node, Object data) {
        analyzeCondition(node.getCondition(), node, data);
        return super.visit(node, data);
    }

    private void analyzeCondition(ASTBinaryExpression condition, JavaNode node, Object data) {
        if (condition.getOperator() == ASTBinaryExpression.Operator.OR || condition.getOperator() == ASTBinaryExpression.Operator.AND) {
            List<ASTBinaryExpression> nullChecks = condition.findDescendantsOfType(ASTBinaryExpression.class);
            for (ASTBinaryExpression nullCheck : nullChecks) {
                if (isPotentialNullCheck(nullCheck)) {
                    ASTBinaryExpression otherCheck = findOtherCheck(condition, nullCheck);
                    if (otherCheck != null && isUnsafeCheck(otherCheck)) {
                        addViolation(data, node);
                    }
                }
            }
        }
    }

    private boolean isPotentialNullCheck(ASTBinaryExpression expr) {
        return expr.getOperator() == ASTBinaryExpression.Operator.EQUAL || expr.getOperator() == ASTBinaryExpression.Operator.NOT_EQUAL;
    }

    private ASTBinaryExpression findOtherCheck(ASTBinaryExpression condition, ASTBinaryExpression nullCheck) {
        if (condition.getLeftOperand() != nullCheck && isSimpleExpression(condition.getLeftOperand())) {
            return condition.getLeftOperand();
        }
        if (condition.getRightOperand() != nullCheck && isSimpleExpression(condition.getRightOperand())) {
            return condition.getRightOperand();
        }
        return null;
    }

    private boolean isSimpleExpression(ASTPrimaryExpression expr) {
        return expr.getFirstChildOfType(ASTPrimarySuffix.class) != null;
    }

    private boolean isUnsafeCheck(ASTBinaryExpression expr) {
        QualifiableExpression qe = expr.getFirstDescendantOfType(QualifiableExpression.class);
        if (qe == null) {
            return false;
        }
        JTypeMirror type = qe.getType();
        if (type.isPrimitive()) {
            return false;
        }
        if (expr.getOperator() == ASTBinaryExpression.Operator.EQUAL && expr.getRightOperand() instanceof ASTLiteral) {
            return false;
        }
        if (expr.getOperator() == ASTBinaryExpression.Operator.NOT_EQUAL && expr.getRightOperand() instanceof ASTLiteral) {
            return false;
        }
        return true;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
```
2. This is a positive test case
```java
// Ok, is &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null && !list.equals(buz)) {
            return list;
        }
    }
}
```
3. This is a negative test case
```java
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
```
4. This is a negative test case
```java
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
```
5. This is a positive test case
```java
// Ok, is ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null || list.equals(buz)) {
            return list;
        }
    }
}
```
6. This is a positive test case
```java
// Arrays are Ok
public class Foo {
    String[] books;
    void bar(int index) {
        if (index >= 0 && books[index] == null) { }
    }
}
```
7. This is a positive test case
```java
// Different method is Ok
public class Book {
    Book[] books;
    String getJane() { return null; }
    String getEyre() { return null; }
    void bar(int i) {
        if (books[i].getJane() == null &&
            books[i].getEyre() == null) { }
    }
}
```
8. This is a positive test case
```java
// Using a shorter expression with the same variable in the second check should not crash the test
public class Book {
    Book[] books;
    String getJane() { return null; }
    void bar(String eyre) {
        if (books.getJane() == null &&
            books == eyre) { }
    }
}
```
9. This is a negative test case
```java
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
```
10. This is a positive test case
```java
// 1633683, Arrays are Ok II
public class Foo {
    void bar(String[] p) {
        if (p.length > 1 && p[0] == null) { }
    }
}
```
11. This is a positive test case
```java
// Different literals in variables should not match
public class Foo {
    String getJane() { return null; }
    void bar(Foo[] p) {
        if (p[0] == null && p[1].getJane()) { }
    }
}
```
12. This is a positive test case
```java
// Assignments in checks are OK
public class Book {
    Book[] books;
    Book[] getBook(int i) {return books;}
    void bar(int janeEyre) {
        if (books == null &&
            (books = getBook(janeEyre)) == null) { }
    }
}
```
13. This is a positive test case
```java
// Useless code, but it will not throw a NullPointerException
public class Family {
    String plain, bold;
    void bar(Family family) {
        if (family.plain == null && family.bold == null &&
           family.plain == null && family.bold == null) { }
    }
}
```
14. This is a positive test case
```java
// Similar method calls with different arguments are OK
import my.Jane;
import my.Eyre;
public class Library {
    String[] getBook(Class<?> i) {return null;}
    void bar(Library library) {
        if (library.getBooks(Jane.class) != null ||
            library.getBooks(Eyre.class) != null) { }
    }
}
```
15. This is a positive test case
```java
// #3071 BrokenNullCheck FP
class Test{
                Object obj = new Object(), objectWithDifferentName = obj;

                public void testPMD(){
                    Object obj = new Object();
                    String str = "str";

                    //Case 1. : An Alarm is generated
                    if(obj == null && !(obj instanceof String));

                    //Case 3.
                    if(obj == null && this.obj == null); //An Alarm is generated
                    if(obj == null && this.objectWithDifferentName); //An Alarm isn't generated
                    if(obj == null && objectWithDifferentName); //An Alarm isn't generated
                }
            }
```
16. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
```
17. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null && boo != true;  // ok
                    result = boo != null && boo != false; // ok
                    result = boo != null && boo == true;  // ok
                    result = boo != null && boo == false; // ok

                }
            }
```
18. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null || boo != true;  // ok
                    result = boo == null || boo != false; // ok
                    result = boo == null || boo == true;  // ok
                    result = boo == null || boo == false; // ok

                }
            }
```
19. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null || boo != true;  // second expression will throw
                    result = boo != null || boo != false; // second expression will throw
                    result = boo != null || boo == true;  // second expression will throw
                    result = boo != null || boo == false; // second expression will throw

                }
            }
```
20. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null && boo;          // same
                }
            }
```
21. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){
                    Test boo = null;

                    boolean result;
                    result = boo == null && handle(boo::toString);           // method reference
                    result = boo == null && boo.toString();                  // method call
                    result = boo == null && boo.field.field.hashCode() == 0; // field access
                    result = boo == null && boo.new Inner().isEmpty();       // qualified ctor call

                }
            }
```
22. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){

                    boolean result;

                    int[] arr = null;

                    result = arr == null && arr[i] == 0;                     // array access
                }
            }
```
23. This is a positive test case
```java
// #3071 BrokenNullCheck FPs (2)
import java.util.*;

            class Test {

                Test foo = new Test(), another = new Test();
                Map<String, String> map;
                String field;
                int idx;
                String[] arr, anotherArr;

                Object foo(Object o) {}

                public void testPMD() {
                    //Case 1.
                    if ((foo == null) != (another == null) || foo != null && !foo.equals(another)) {
                        ;
                    }

                    //Case 2.
                    if (map.remove(null) != null || map.remove("") != null) {
                        ;
                    }
                    if (foo(foo) != null || foo(foo.field) != null) {
                        ;
                    }

                    //Case 3.
                    if (foo != null || foo == null && another != null && another.hashCode() == 0) {
                        ;
                    }

                    //Case 4.
                    if (null != arr[idx] || null == arr[idx] && !anotherArr[idx].isEmpty()) {
                        ;
                    }
                }
            }
```
24. This is a negative test case
```java
// BrokenNullCheck with unboxing, unboxing this operand will throw a NullPointerException
class Test {
                public void testPMD(Integer i){
                    boolean result;
                    result = i == null && i == 0;
                    result = i == null && i << 1;
                    result = i == null && i + 0;
                    result = i == null && i == 0.d;
                }
            }
```
25. This is a positive test case
```java
// Comparing two boxed things does not unbox
class Test {
                public void testPMD(Integer i, Integer d){
                    boolean result;
                    result = i == null && i == d;
                    result = i == null && i != d;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.Optional;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTBinaryExpression.class);
    }

    @Override
    public Object visit(ASTBinaryExpression node, Object data) {
        if (node.isUsingOperator(ASTBinaryExpression.Operator.LOGICAL_OR) || node.isUsingOperator(ASTBinaryExpression.Operator.LOGICAL_AND)) {
            ASTExpression left = node.getLeftOperand();
            ASTExpression right = node.getRightOperand();

            boolean leftIsNullCheck = isNullCheck(left);
            boolean rightIsNullableExpression = isNullableExpression(right);
            boolean rightIsNullCheck = isNullCheck(right);
            boolean leftIsNullableExpression = isNullableExpression(left);

            if (node.isUsingOperator(ASTBinaryExpression.Operator.LOGICAL_OR) && leftIsNullCheck && rightIsNullableExpression) {
                addViolation(data, node);
            } else if (node.isUsingOperator(ASTBinaryExpression.Operator.LOGICAL_AND) && leftIsNullCheck && rightIsNullCheck) {
                addViolation(data, node);
            } else if (node.isUsingOperator(ASTBinaryExpression.Operator.LOGICAL_AND) && leftIsNullableExpression && rightIsNullCheck) {
                addViolation(data, node);
            } else if (node.isUsingOperator(ASTBinaryExpression.Operator.LOGICAL_OR) && leftIsNullableExpression && rightIsNullableExpression) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    private boolean isNullCheck(ASTExpression expression) {
        if (expression instanceof ASTBinaryExpression) {
            ASTBinaryExpression be = (ASTBinaryExpression) expression;
            return (be.isUsingOperator(ASTBinaryExpression.Operator.EQUAL) || be.isUsingOperator(ASTBinaryExpression.Operator.NOT_EQUAL))
                    && (be.getLeftOperand().isUsingOperator(ASTBinaryExpression.Operator.NULL) || be.getRightOperand().isUsingOperator(ASTBinaryExpression.Operator.NULL));
        }
        return false;
    }

    private boolean isNullableExpression(ASTExpression expression) {
        if (expression instanceof ASTMethodCall) {
            return true;
        } else if (expression instanceof ASTPrimaryExpression) {
            ASTPrimaryExpression pe = (ASTPrimaryExpression) expression;
            if (pe.getFirstChildOfType(ASTPrimarySuffix.class) != null) {
                return true;
            }
            Optional<JVariableSymbol> symbol = pe.getFirstChildOfType(ASTVariableDeclaratorId.class).getSymbol();
            if (symbol.isPresent() && symbol.get().getType() instanceof JClassType) {
                return true;
            }
        } else if (expression instanceof ASTBinaryExpression) {
            ASTBinaryExpression be = (ASTBinaryExpression) expression;
            return isNullableExpression(be.getLeftOperand()) || isNullableExpression(be.getRightOperand());
        } else if (expression instanceof ASTConditionalExpression) {
            ASTConditionalExpression ce = (ASTConditionalExpression) expression;
            return isNullableExpression(ce.getThenExpression()) || isNullableExpression(ce.getElseExpression());
        }
        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// should be &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null || !list.equals(buz)) {
            return list;
        }
    }
}
```
2. This is a positive test case
```java
// Ok, is &&
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list != null && !list.equals(buz)) {
            return list;
        }
    }
}
```
3. This is a negative test case
```java
// should be &&, but now with a longer expression
class Books {
    String getJane() { return null; }
    void bar(Books books) {
        if (books.getJane()!= null || !books.getJane().equals("")) { }
    }
}
```
4. This is a negative test case
```java
// should be ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null && list.equals(buz)) {
            return list;
        }
    }
}
```
5. This is a positive test case
```java
// Ok, is ||
public class Foo {
    Object buz;
    Object bar(Object list) {
        if (list == null || list.equals(buz)) {
            return list;
        }
    }
}
```
6. This is a positive test case
```java
// Arrays are Ok
public class Foo {
    String[] books;
    void bar(int index) {
        if (index >= 0 && books[index] == null) { }
    }
}
```
7. This is a positive test case
```java
// Different method is Ok
public class Book {
    Book[] books;
    String getJane() { return null; }
    String getEyre() { return null; }
    void bar(int i) {
        if (books[i].getJane() == null &&
            books[i].getEyre() == null) { }
    }
}
```
8. This is a positive test case
```java
// Using a shorter expression with the same variable in the second check should not crash the test
public class Book {
    Book[] books;
    String getJane() { return null; }
    void bar(String eyre) {
        if (books.getJane() == null &&
            books == eyre) { }
    }
}
```
9. This is a negative test case
```java
// 1633683, should be ||, but now with another compare
public class Foo {
    void bar(String str) {
        if (str == null && str.length() == 0) { }
    }
}
```
10. This is a positive test case
```java
// 1633683, Arrays are Ok II
public class Foo {
    void bar(String[] p) {
        if (p.length > 1 && p[0] == null) { }
    }
}
```
11. This is a positive test case
```java
// Different literals in variables should not match
public class Foo {
    String getJane() { return null; }
    void bar(Foo[] p) {
        if (p[0] == null && p[1].getJane()) { }
    }
}
```
12. This is a positive test case
```java
// Assignments in checks are OK
public class Book {
    Book[] books;
    Book[] getBook(int i) {return books;}
    void bar(int janeEyre) {
        if (books == null &&
            (books = getBook(janeEyre)) == null) { }
    }
}
```
13. This is a positive test case
```java
// Useless code, but it will not throw a NullPointerException
public class Family {
    String plain, bold;
    void bar(Family family) {
        if (family.plain == null && family.bold == null &&
           family.plain == null && family.bold == null) { }
    }
}
```
14. This is a positive test case
```java
// Similar method calls with different arguments are OK
import my.Jane;
import my.Eyre;
public class Library {
    String[] getBook(Class<?> i) {return null;}
    void bar(Library library) {
        if (library.getBooks(Jane.class) != null ||
            library.getBooks(Eyre.class) != null) { }
    }
}
```
15. This is a positive test case
```java
// #3071 BrokenNullCheck FP
class Test{
                Object obj = new Object(), objectWithDifferentName = obj;

                public void testPMD(){
                    Object obj = new Object();
                    String str = "str";

                    //Case 1. : An Alarm is generated
                    if(obj == null && !(obj instanceof String));

                    //Case 3.
                    if(obj == null && this.obj == null); //An Alarm is generated
                    if(obj == null && this.objectWithDifferentName); //An Alarm isn't generated
                    if(obj == null && objectWithDifferentName); //An Alarm isn't generated
                }
            }
```
16. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;
                    result = boo == null && boo != true;  // boo != true would throw NPE because of unboxing
                    result = boo == null && boo != false; // same
                    result = boo == null && boo == true;  // same
                    result = boo == null && boo == false; // same
                }
            }
```
17. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null && boo != true;  // ok
                    result = boo != null && boo != false; // ok
                    result = boo != null && boo == true;  // ok
                    result = boo != null && boo == false; // ok

                }
            }
```
18. This is a positive test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null || boo != true;  // ok
                    result = boo == null || boo != false; // ok
                    result = boo == null || boo == true;  // ok
                    result = boo == null || boo == false; // ok

                }
            }
```
19. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo != null || boo != true;  // second expression will throw
                    result = boo != null || boo != false; // second expression will throw
                    result = boo != null || boo == true;  // second expression will throw
                    result = boo != null || boo == false; // second expression will throw

                }
            }
```
20. This is a negative test case
```java
// BrokenNullCheck with Boolean variable
class Test{
                public void testPMD(){
                    Boolean boo = null;

                    boolean result;

                    result = boo == null && boo;          // same
                }
            }
```
21. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){
                    Test boo = null;

                    boolean result;
                    result = boo == null && handle(boo::toString);           // method reference
                    result = boo == null && boo.toString();                  // method call
                    result = boo == null && boo.field.field.hashCode() == 0; // field access
                    result = boo == null && boo.new Inner().isEmpty();       // qualified ctor call

                }
            }
```
22. This is a negative test case
```java
// BrokenNullCheck with other kinds of NPEs (see QualifiableExpression)
class Test {
                interface FunctionalItf { String describe(); }
                boolean handle(FunctionalItf obj) {}
                Test field;
                class Inner {boolean isEmpty();}
                public void testPMD(){

                    boolean result;

                    int[] arr = null;

                    result = arr == null && arr[i] == 0;                     // array access
                }
            }
```
23. This is a positive test case
```java
// #3071 BrokenNullCheck FPs (2)
import java.util.*;

            class Test {

                Test foo = new Test(), another = new Test();
                Map<String, String> map;
                String field;
                int idx;
                String[] arr, anotherArr;

                Object foo(Object o) {}

                public void testPMD() {
                    //Case 1.
                    if ((foo == null) != (another == null) || foo != null && !foo.equals(another)) {
                        ;
                    }

                    //Case 2.
                    if (map.remove(null) != null || map.remove("") != null) {
                        ;
                    }
                    if (foo(foo) != null || foo(foo.field) != null) {
                        ;
                    }

                    //Case 3.
                    if (foo != null || foo == null && another != null && another.hashCode() == 0) {
                        ;
                    }

                    //Case 4.
                    if (null != arr[idx] || null == arr[idx] && !anotherArr[idx].isEmpty()) {
                        ;
                    }
                }
            }
```
24. This is a negative test case
```java
// BrokenNullCheck with unboxing, unboxing this operand will throw a NullPointerException
class Test {
                public void testPMD(Integer i){
                    boolean result;
                    result = i == null && i == 0;
                    result = i == null && i << 1;
                    result = i == null && i + 0;
                    result = i == null && i == 0.d;
                }
            }
```
25. This is a positive test case
```java
// Comparing two boxed things does not unbox
class Test {
                public void testPMD(Integer i, Integer d){
                    boolean result;
                    result = i == null && i == d;
                    result = i == null && i != d;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.HashSet;
import java.util.Set;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class BrokenNullCheckRule extends AbstractJavaRulechainRule {
    public BrokenNullCheckRule() {
        super(ASTIfStatement.class);
    }

    @Override
    public Object visit(ASTIfStatement node, Object data) {
        ASTBinaryExpression condition = node.getFirstDescendantOfType(ASTBinaryExpression.class);
        if (condition != null) {
            checkCondition(condition, data);
        }
        return super.visit(node, data);
    }

    private void checkCondition(ASTBinaryExpression condition, Object data) {
        if (condition.getOperator() == ASTBinaryExpression.Operator.OR || condition.getOperator() == ASTBinaryExpression.Operator.AND) {
            ASTBinaryExpression left = condition.getLeftOperand();
            ASTBinaryExpression right = condition.getRightOperand();
            if (isBrokenNullCheck(left, right, condition.getOperator())) {
                addViolation(data, condition);
            }
        }
    }

    private boolean isBrokenNullCheck(ASTBinaryExpression left, ASTBinaryExpression right, ASTBinaryExpression.Operator operator) {
        boolean isLeftNullCheck = isNullCheck(left);
        boolean isRightNullCheck = isNullCheck(right);
        boolean isLeftMethodCallOrFieldAccess = isMethodCallOrFieldAccess(left);
        boolean isRightMethodCallOrFieldAccess = isMethodCallOrFieldAccess(right);
        boolean isLeftArrayAccess = isArrayAccess(left);
        boolean isRightArrayAccess = isArrayAccess(right);

        if (isLeftNullCheck && isRightMethodCallOrFieldAccess && operator == ASTBinaryExpression.Operator.OR) {
            return true;
        }
        if (isRightNullCheck && isLeftMethodCallOrFieldAccess && operator == ASTBinaryExpression.Operator.OR) {
            return true;
        }
        if (isLeftNullCheck && isRightArrayAccess && operator == ASTBinaryExpression.Operator.OR) {
            return true;
        }
        if (isRightNullCheck && isLeftArrayAccess && operator == ASTBinaryExpression.Operator.OR) {
            return true;
        }
        if (isLeftNullCheck && isRightMethodCallOrFieldAccess && operator == ASTBinaryExpression.Operator.AND) {
            return true;
        }
        if (isRightNullCheck && isLeftMethodCallOrFieldAccess && operator == ASTBinaryExpression.Operator.AND) {
            return true;
        }
        if (isLeftNullCheck && isRightArrayAccess && operator == ASTBinaryExpression.Operator.AND) {
            return true;
        }
        if (isRightNullCheck && isLeftArrayAccess && operator == ASTBinaryExpression.Operator.AND) {
            return true;
        }
        if (isLeftNullCheck && isRightUnboxing(right) && operator == ASTBinaryExpression.Operator.AND) {
            return true;
        }
        if (isRightNullCheck && isLeftUnboxing(left) && operator == ASTBinaryExpression.Operator.AND) {
            return true;
        }
        return false;
    }

    private boolean isNullCheck(ASTBinaryExpression expr) {
        ASTPrimaryExpression primary = expr.getFirstDescendantOfType(ASTPrimaryExpression.class);
        if (primary != null && primary.getFirstChildOfType(ASTBinaryExpression.class) != null) {
            ASTBinaryExpression binary = primary.getFirstChildOfType(ASTBinaryExpression.class);
            return binary.getOperator() == ASTBinaryExpression.Operator.EQ && binary.getRightOperand().isConstantExpression(null);
        }
        return false;
    }

    private boolean isMethodCallOrFieldAccess(ASTBinaryExpression expr) {
        ASTPrimaryExpression primary = expr.getFirstDescendantOfType(ASTPrimaryExpression.class);
        return primary != null && (primary.getFirstChildOfType(ASTMethodCall.class) != null || primary.getFirstChildOfType(ASTFieldAccess.class) != null);
    }

    private boolean isArrayAccess(ASTBinaryExpression expr) {
        ASTPrimaryExpression primary = expr.getFirstDescendantOfType(ASTPrimaryExpression.class);
        return primary != null && primary.getFirstChildOfType(ASTArrayAccess.class) != null;
    }

    private boolean isLeftUnboxing(ASTBinaryExpression expr) {
        ASTPrimaryExpression primary = expr.getLeftOperand().getFirstDescendantOfType(ASTPrimaryExpression.class);
        return primary != null && isUnboxing(primary);
    }

    private boolean isRightUnboxing(ASTBinaryExpression expr) {
        ASTPrimaryExpression primary = expr.getRightOperand().getFirstDescendantOfType(ASTPrimaryExpression.class);
        return primary != null && isUnboxing(primary);
    }

    private boolean isUnboxing(ASTPrimaryExpression primary) {
        JType type = TypeHelper.getType(primary);
        return type != null && type.isA(JPrimitiveType.class) && primary.getFirstChildOfType(ASTPrimaryExpression.class) != null;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 167.24122405052185 秒
