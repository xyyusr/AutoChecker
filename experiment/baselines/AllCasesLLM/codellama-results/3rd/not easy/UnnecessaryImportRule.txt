开始

========================================== Rule UnnecessaryImportRule ===========================================
一共 73 个测试用例
正例 50 个
反例 23 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {

    public UnnecessaryImportRule() {
        super(ImportListItem.class, ImportDeclaration.class, TypeReference.class, QualifiedName.class);
    }

    @Override
    public Object visit(ImportListItem node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ImportDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(TypeReference node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(QualifiedName node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTNode node, Object data) {
        if (node instanceof ImportDeclaration) {
            ImportDeclaration importDeclaration = (ImportDeclaration) node;
            if (importDeclaration.isWildcard()) {
                visitWildcardImport(importDeclaration);
            } else {
                visitStaticImport(importDeclaration);
                visitSingleTypeImport(importDeclaration);
                visitStaticImportOnDemand(importDeclaration);
                visitSingleTypeImportOnDemand(importDeclaration);
            }
        }
        return super.visit(node, data);
    }

    private void visitWildcardImport(ImportDeclaration importDeclaration) {
        if (importDeclaration.getStaticKeyword() != null) {
            visitStaticWildcardImport(importDeclaration);
        } else {
            visitWildcardImport(importDeclaration);
        }
    }

    private void visitStaticWildcardImport(ImportDeclaration importDeclaration) {
        if (importDeclaration.getStaticKeyword() != null) {
            ASTNode parent = importDeclaration.getParent();
            if (parent instanceof ImportDeclaration) {
                ImportDeclaration parentImportDeclaration = (ImportDeclaration) parent;
                if (parentImportDeclaration.isWildcard()) {
                    // ignore
                    return;
                }
                if (parentImportDeclaration.getStaticKeyword() != null) {
                    // ignore
                    return;
                }
            }
            if (isImportDeclaredInSamePackage(importDeclaration)) {
                // ignore
                return;
            }
            addViolation(data, importDeclaration);
        }
    }

    private void visitWildcardImport(ImportDeclaration importDeclaration) {
        if (!isImportDeclaredInSamePackage(importDeclaration)) {
            addViolation(data, importDeclaration);
        }
    }

    private void visitStaticImport(ImportDeclaration importDeclaration) {
        if (importDeclaration.getStaticKeyword() != null) {
            if (importDeclaration.getStaticKeyword().getImage().equals("import")) {
                // ignore
                return;
            }
            if (isImportDeclaredInSamePackage(importDeclaration)) {
                // ignore
                return;
            }
            ASTNode parent = importDeclaration.getParent();
            if (parent instanceof ImportDeclaration) {
                ImportDeclaration parentImportDeclaration = (ImportDeclaration) parent;
                if (parentImportDeclaration.getStaticKeyword() != null) {
                    if (parentImportDeclaration.getStaticKeyword().getImage().equals("import")) {
                        // ignore
                        return;
                    }
                    if (isImportDeclaredInSamePackage(parentImportDeclaration)) {
                        // ignore
                        return;
                    }
                }
            }
            addViolation(data, importDeclaration);
        }
    }

    private void visitSingleTypeImport(ImportDeclaration importDeclaration) {
        if (!importDeclaration.getStaticKeyword().getImage().equals("import")) {
            if (importDeclaration.getStaticKeyword() != null) {
                // ignore
                return;
            }
            if (!isImportDeclaredInSamePackage(importDeclaration)) {
                addViolation(data, importDeclaration);
            }
        }
    }

    private void visitStaticImportOnDemand(ImportDeclaration importDeclaration) {
        if (importDeclaration.getStaticKeyword() != null && importDeclaration.getStaticKeyword().getImage().equals("import")) {
            // ignore
            return;
        }
        if (importDeclaration.getStaticKeyword() != null) {
            if (isImportDeclaredInSamePackage(importDeclaration)) {
                // ignore
                return;
            }
            ASTNode parent = importDeclaration.getParent();
            if (parent instanceof ImportDeclaration) {
                ImportDeclaration parentImportDeclaration = (ImportDeclaration) parent;
                if (parentImportDeclaration.getStaticKeyword() != null && parentImportDeclaration.getStaticKeyword().getImage().equals("import")) {
                    // ignore
                    return;
                }
            }
            addViolation(data, importDeclaration);
        }
    }

    private void visitSingleTypeImportOnDemand(ImportDeclaration importDeclaration) {
        if (importDeclaration.getStaticKeyword() != null && importDeclaration.getStaticKeyword().getImage().equals("import")) {
            // ignore
            return;
        }
        if (!isImportDeclaredInSamePackage(importDeclaration)) {
            addViolation(data, importDeclaration);
        }
    }

    private boolean isImportDeclaredInSamePackage(ImportDeclaration importDeclaration) {
        String packageName = importDeclaration.getPackageSymbol().getQualifiedName().toString();
        String importedTypeName = importDeclaration.getImportedName().getImage();
        if (importedTypeName.startsWith(packageName)) {
            return true;
        }
        return false;
    }

    private void addViolation(Object data, ASTNode node) {
        // implementation of adding violation to data
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {

    public UnnecessaryImportRule() {
        super(ASTImportDeclaration.class, ASTClassOrInterfaceDeclaration.class, ASTImportStaticDeclaration.class, ASTMemberReference.class, ASTLiteral.class, ASTMethodInvocation.class, ASTFieldAccess.class, ASTClassOrInterfaceType.class, ASTName.class, ASTCompilationUnit.class, ASTClassOrInterfaceBody.class, ASTImportStaticWildcardDeclaration.class, ASTClassOrInterfaceBodyDeclarations.class, ASTImportStaticSingleNameDeclaration.class, ASTClassOrInterfaceTypeArguments.class, ASTClassOrInterfaceRestType.class, ASTImportStaticTypeArguments.class, ASTClassOrInterfaceTypeParameters.class, ASTImportStaticTypeArgumentsOrAnnotation.class, ASTNameList.class, ASTCompilationUnitMember.class, ASTClassOrInterfaceDeclarationMembers.class, ASTClassOrInterfaceTypeParametersList.class, ASTImportStaticTypeArgument.class, ASTBinaryExpression.class, ASTExpression.class, ASTStatement.class, ASTStatementExpression.class, ASTStatementBlock.class, ASTThrowStatement.class, ASTFinallyStatement.class, ASTCatchClause.class, ASTCatchClauseDeclaration.class, ASTImportStaticWildcardTypeArguments.class, ASTClassOrInterfaceDeclarationMember.class, ASTImportStaticWildcardTypeArgument.class, ASTCompilationUnitMemberDeclarations.class, ASTImportStaticWildcardTypeArgumentsOrAnnotation.class, ASTWildcardOrRestrictedModifier.class, ASTWildcardOrRestrictedType.class, ASTTypeArgument.class, ASTTypeArgumentList.class, ASTTypeParameter.class, ASTImportStaticTypeArgumentList.class, ASTWildcardType.class, ASTClassOrInterfaceDeclarationBody.class, ASTImportStaticWildcardTypeArgumentsOrAnnotationList.class, ASTImportStaticTypeArgumentsOrAnnotationList.class, ASTClassOrInterfaceTypeParameter.class, ASTImportStaticWildcardTypeArgumentList.class, ASTCompilationUnitMemberDeclarationsStatement.class, ASTImportStaticWildcardTypeArgumentsList.class, ASTTypeParameterList.class, ASTImportStaticWildcardTypeArgument.class, ASTWildcardTypeArgument.class, ASTImportStaticTypeArgumentList.class, ASTWildcardTypeArgumentList.class, ASTImportStaticTypeArgumentsList.class, ASTTypeArgumentList.class, ASTWildcardTypeArgumentList.class, ASTImportStaticWildcardTypeArgumentList.class);
    }

    @Override
    public Object visit(ASTImportDeclaration node, Object data) {
        List<ASTCompilationUnitMember> compilationUnitMembers = node.getCompilationUnit().getMembers();
        if (compilationUnitMembers.size() > 0) {
            ASTCompilationUnit compilationUnit = node.getCompilationUnit();
            ASTClassOrInterfaceDeclaration classOrInterfaceDeclaration = (ASTClassOrInterfaceDeclaration) compilationUnitMembers.get(0);
            NodeStream<ASTImportDeclaration> imports = compilationUnit.imports();
            for (ASTImportDeclaration importDeclaration : imports) {
                if (importDeclaration.isStatic() && importDeclaration.isWildcard()) {
                    continue;
                }
                String name = importDeclaration.getName();
                if (importDeclaration.isWildcard()) {
                    ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration = (ASTImportStaticWildcardDeclaration) importDeclaration;
                    if (isImportUsed(compilationUnit, importStaticWildcardDeclaration.getTypeArgument(), classOrInterfaceDeclaration)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration2 : imports) {
                        if (importStaticWildcardDeclaration2.equals(importStaticWildcardDeclaration)) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticWildcardDeclaration2.getTypeArgument(), classOrInterfaceDeclaration)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else if (importDeclaration.isStatic()) {
                    ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration = (ASTImportStaticSingleNameDeclaration) importDeclaration;
                    if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration.getName(), classOrInterfaceDeclaration)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration2 : imports) {
                        if (importStaticSingleNameDeclaration2.equals(importStaticSingleNameDeclaration)) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration2.getName(), classOrInterfaceDeclaration)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else {
                    if (!isImportUsed(compilationUnit, name, classOrInterfaceDeclaration)) {
                        addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        List<ASTCompilationUnitMember> compilationUnitMembers = node.getCompilationUnit().getMembers();
        if (compilationUnitMembers.size() > 0) {
            ASTCompilationUnit compilationUnit = node.getCompilationUnit();
            ASTClassOrInterfaceDeclaration classOrInterfaceDeclaration = (ASTClassOrInterfaceDeclaration) compilationUnitMembers.get(0);
            for (ASTImportDeclaration importDeclaration : compilationUnit.imports()) {
                if (importDeclaration.isStatic() && importDeclaration.isWildcard()) {
                    continue;
                }
                String name = importDeclaration.getName();
                if (importDeclaration.isWildcard()) {
                    ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration = (ASTImportStaticWildcardDeclaration) importDeclaration;
                    if (isImportUsed(compilationUnit, importStaticWildcardDeclaration.getTypeArgument(), classOrInterfaceDeclaration)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration2 : compilationUnit.imports()) {
                        if (importStaticWildcardDeclaration2.equals(importStaticWildcardDeclaration)) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticWildcardDeclaration2.getTypeArgument(), classOrInterfaceDeclaration)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else if (importDeclaration.isStatic()) {
                    ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration = (ASTImportStaticSingleNameDeclaration) importDeclaration;
                    if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration.getName(), classOrInterfaceDeclaration)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration2 : compilationUnit.imports()) {
                        if (importStaticSingleNameDeclaration2.equals(importStaticSingleNameDeclaration)) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration2.getName(), classOrInterfaceDeclaration)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else {
                    if (!isImportUsed(compilationUnit, name, classOrInterfaceDeclaration)) {
                        addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticDeclaration node, Object data) {
        List<ASTCompilationUnitMember> compilationUnitMembers = node.getCompilationUnit().getMembers();
        if (compilationUnitMembers.size() > 0) {
            ASTCompilationUnit compilationUnit = node.getCompilationUnit();
            ASTClassOrInterfaceDeclaration classOrInterfaceDeclaration = (ASTClassOrInterfaceDeclaration) compilationUnitMembers.get(0);
            NodeStream<ASTImportDeclaration> imports = compilationUnit.imports();
            for (ASTImportDeclaration importDeclaration : imports) {
                if (importDeclaration.isStatic() && importDeclaration.isWildcard()) {
                    continue;
                }
                String name = importDeclaration.getName();
                if (importDeclaration.isWildcard()) {
                    ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration = (ASTImportStaticWildcardDeclaration) importDeclaration;
                    if (isImportUsed(compilationUnit, importStaticWildcardDeclaration.getTypeArgument(), classOrInterfaceDeclaration)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration2 : imports) {
                        if (importStaticWildcardDeclaration2.equals(importStaticWildcardDeclaration)) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticWildcardDeclaration2.getTypeArgument(), classOrInterfaceDeclaration)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else if (importDeclaration.isStatic()) {
                    ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration = (ASTImportStaticSingleNameDeclaration) importDeclaration;
                    if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration.getName(), classOrInterfaceDeclaration)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration2 : imports) {
                        if (importStaticSingleNameDeclaration2.equals(importStaticSingleNameDeclaration)) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration2.getName(), classOrInterfaceDeclaration)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else {
                    if (!isImportUsed(compilationUnit, name, classOrInterfaceDeclaration)) {
                        addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMemberReference node, Object data) {
        if (node.getType() instanceof ASTClassOrInterfaceType) {
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType) node.getType();
            if (classOrInterfaceType.getArgumentList().size() > 0) {
                return super.visit(node, data);
            }
            String name = classOrInterfaceType.getName();
            ASTCompilationUnit compilationUnit = node.getCompilationUnit();
            if (compilationUnit == null) {
                return super.visit(node, data);
            }
            for (ASTImportDeclaration importDeclaration : compilationUnit.imports()) {
                if (importDeclaration.isStatic() && importDeclaration.isWildcard()) {
                    continue;
                }
                if (importDeclaration.getName().equals(name)) {
                    continue;
                }
                if (importDeclaration.isWildcard()) {
                    ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration = (ASTImportStaticWildcardDeclaration) importDeclaration;
                    if (isImportUsed(compilationUnit, importStaticWildcardDeclaration.getTypeArgument(), null)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration2 : compilationUnit.imports()) {
                        if (importStaticWildcardDeclaration2.equals(importStaticWildcardDeclaration)) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticWildcardDeclaration2.getTypeArgument(), null)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else if (importDeclaration.isStatic()) {
                    ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration = (ASTImportStaticSingleNameDeclaration) importDeclaration;
                    if (importDeclaration.getName().equals(name)) {
                        continue;
                    }
                    if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration.getName(), null)) {
                        continue;
                    }
                    Set<String> usedNames = getUsedNames(compilationUnit);
                    for (ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration2 : compilationUnit.imports()) {
                        if (importStaticSingleNameDeclaration2.equals(importStaticSingleNameDeclaration)) {
                            continue;
                        }
                        if (importDeclaration.getName().equals(importStaticSingleNameDeclaration2.getName())) {
                            continue;
                        }
                        if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration2.getName(), null)) {
                            continue;
                        }
                        Set<String> usedNames2 = getUsedNames(compilationUnit);
                        Set<String> intersection = usedNames.retainAll(usedNames2);
                        if (intersection.isEmpty()) {
                            addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                        }
                    }
                } else {
                    if (importDeclaration.getName().equals(name)) {
                        continue;
                    }
                    if (!isImportUsed(compilationUnit, name, null)) {
                        addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTLiteral node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodInvocation node, Object data) {
        ASTCompilationUnit compilationUnit = node.getCompilationUnit();
        if (compilationUnit == null) {
            return super.visit(node, data);
        }
        for (ASTImportDeclaration importDeclaration : compilationUnit.imports()) {
            if (importDeclaration.isStatic() && importDeclaration.isWildcard()) {
                continue;
            }
            ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration = (ASTImportStaticWildcardDeclaration) importDeclaration;
            if (node.getName().equals(importStaticWildcardDeclaration.getTypeArgument())) {
                continue;
            }
            Set<String> usedNames = getUsedNames(compilationUnit);
            for (ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration2 : compilationUnit.imports()) {
                if (importStaticWildcardDeclaration2.equals(importStaticWildcardDeclaration)) {
                    continue;
                }
                if (node.getName().equals(importStaticWildcardDeclaration2.getTypeArgument())) {
                    continue;
                }
                Set<String> usedNames2 = getUsedNames(compilationUnit);
                Set<String> intersection = usedNames.retainAll(usedNames2);
                if (intersection.isEmpty()) {
                    addViolation(this, data, importDeclaration, "Unused import [" + importStaticWildcardDeclaration.getTypeArgument() + "]");
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFieldAccess node, Object data) {
        ASTCompilationUnit compilationUnit = node.getCompilationUnit();
        if (compilationUnit == null) {
            return super.visit(node, data);
        }
        for (ASTImportDeclaration importDeclaration : compilationUnit.imports()) {
            if (importDeclaration.isStatic() && importDeclaration.isWildcard()) {
                continue;
            }
            ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration = (ASTImportStaticWildcardDeclaration) importDeclaration;
            if (node.getName().equals(importStaticWildcardDeclaration.getTypeArgument())) {
                continue;
            }
            Set<String> usedNames = getUsedNames(compilationUnit);
            for (ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration2 : compilationUnit.imports()) {
                if (importStaticWildcardDeclaration2.equals(importStaticWildcardDeclaration)) {
                    continue;
                }
                if (node.getName().equals(importStaticWildcardDeclaration2.getTypeArgument())) {
                    continue;
                }
                Set<String> usedNames2 = getUsedNames(compilationUnit);
                Set<String> intersection = usedNames.retainAll(usedNames2);
                if (intersection.isEmpty()) {
                    addViolation(this, data, importDeclaration, "Unused import [" + importStaticWildcardDeclaration.getTypeArgument() + "]");
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceType node, Object data) {
        ASTCompilationUnit compilationUnit = node.getCompilationUnit();
        if (compilationUnit == null) {
            return super.visit(node, data);
        }
        for (ASTImportDeclaration importDeclaration : compilationUnit.imports()) {
            if (importDeclaration.isStatic() && importDeclaration.isWildcard()) {
                continue;
            }
            String name = importDeclaration.getName();
            if (node.getName().equals(name)) {
                continue;
            }
            if (importDeclaration.isWildcard()) {
                ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration = (ASTImportStaticWildcardDeclaration) importDeclaration;
                if (isImportUsed(compilationUnit, importStaticWildcardDeclaration.getTypeArgument(), null)) {
                    continue;
                }
                Set<String> usedNames = getUsedNames(compilationUnit);
                for (ASTImportStaticWildcardDeclaration importStaticWildcardDeclaration2 : compilationUnit.imports()) {
                    if (importStaticWildcardDeclaration2.equals(importStaticWildcardDeclaration)) {
                        continue;
                    }
                    if (isImportUsed(compilationUnit, importStaticWildcardDeclaration2.getTypeArgument(), null)) {
                        continue;
                    }
                    Set<String> usedNames2 = getUsedNames(compilationUnit);
                    Set<String> intersection = usedNames.retainAll(usedNames2);
                    if (intersection.isEmpty()) {
                        addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                    }
                }
            } else if (importDeclaration.isStatic()) {
                ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration = (ASTImportStaticSingleNameDeclaration) importDeclaration;
                if (node.getName().equals(name)) {
                    continue;
                }
                if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration.getName(), null)) {
                    continue;
                }
                Set<String> usedNames = getUsedNames(compilationUnit);
                for (ASTImportStaticSingleNameDeclaration importStaticSingleNameDeclaration2 : compilationUnit.imports()) {
                    if (importStaticSingleNameDeclaration2.equals(importStaticSingleNameDeclaration)) {
                        continue;
                    }
                    if (node.getName().equals(importStaticSingleNameDeclaration2.getName())) {
                        continue;
                    }
                    if (isImportUsed(compilationUnit, importStaticSingleNameDeclaration2.getName(), null)) {
                        continue;
                    }
                    Set<String> usedNames2 = getUsedNames(compilationUnit);
                    Set<String> intersection = usedNames.retainAll(usedNames2);
                    if (intersection.isEmpty()) {
                        addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                    }
                }
            } else {
                if (node.getName().equals(name)) {
                    continue;
                }
                if (!isImportUsed(compilationUnit, name, null)) {
                    addViolation(this, data, importDeclaration, "Unused import [" + name + "]");
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTName node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCompilationUnit node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBodyDeclarations node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticSingleNameDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceTypeArguments node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceRestType node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticTypeArguments node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceTypeParameters node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticTypeArgumentsOrAnnotation node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTNameList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCompilationUnitMember node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclarationMembers node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceTypeParametersList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticTypeArgument node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTBinaryExpression node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTExpression node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStatementExpression node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTStatementBlock node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTThrowStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTFinallyStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClause node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCatchClauseDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArguments node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclarationMember node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArgument node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCompilationUnitMemberDeclarations node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArgumentsOrAnnotation node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWildcardOrRestrictedModifier node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWildcardOrRestrictedType node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTypeArgument node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTypeParameter node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWildcardType node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclarationBody node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArgumentsOrAnnotationList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticTypeArgumentsOrAnnotationList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceTypeParameter node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTCompilationUnitMemberDeclarationsStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArgumentsList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTypeParameterList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArgument node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWildcardTypeArgument node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWildcardTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticTypeArgumentsList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTWildcardTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTImportStaticWildcardTypeArgumentList node, Object data) {
        return super.visit(node, data);
    }

    private boolean isImportUsed(ASTCompilationUnit compilationUnit, String name, ASTClassOrInterfaceDeclaration classOrInterfaceDeclaration) {
        Set<String> usedNames = getUsedNames(compilationUnit);
        if (compilationUnit == null) {
            return false;
        }
        return usedNames.contains(name);
    }

    private Set<String> getUsedNames(ASTCompilationUnit compilationUnit) {
        Set<String> usedNames = new HashSet<>();
        NodeStream<ASTCompilationUnitMember> compilationUnitMembers = compilationUnit.members();
        for (ASTCompilationUnitMember member : compilationUnitMembers) {
            if (member instanceof ASTClassOrInterfaceDeclaration) {
                ASTClassOrInterfaceDeclaration classOrInterfaceDeclaration = (ASTClassOrInterfaceDeclaration) member;
                usedNames.addAll(getUsedNamesFromClassOrInterfaceDeclaration(compilationUnit, classOrInterfaceDeclaration));
            } else if (member instanceof ASTMethodDeclaration) {
                ASTMethodDeclaration methodDeclaration = (ASTMethodDeclaration) member;
                usedNames.addAll(getUsedNamesFromMethodDeclaration(compilationUnit, methodDeclaration));
            } else if (member instanceof ASTFieldDeclaration) {
                ASTFieldDeclaration fieldDeclaration = (ASTFieldDeclaration) member;
                usedNames.addAll(getUsedNamesFromFieldDeclaration(compilationUnit, fieldDeclaration));
            }
        }
        return usedNames;
    }

    private Set<String> getUsedNamesFromClassOrInterfaceDeclaration(ASTCompilationUnit compilationUnit, ASTClassOrInterfaceDeclaration classOrInterfaceDeclaration) {
        Set<String> usedNames = new HashSet<>();
        NodeStream<ASTClassOrInterfaceType> typeParameters = classOrInterfaceDeclaration.getTypeParameters();
        for (ASTClassOrInterfaceType typeParameter : typeParameters) {
            usedNames.addAll(getUsedNamesFromClassOrInterfaceType(compilationUnit, typeParameter));
        }
        NodeStream<ASTClassOrInterfaceBodyDeclarations> bodyDeclarations = classOrInterfaceDeclaration.getBodyDeclarations();
        for (ASTClassOrInterfaceBodyDeclarations bodyDeclarations2 : bodyDeclarations) {
            NodeStream<ASTClassOrInterfaceDeclarationMember> members = bodyDeclarations2.getMembers();
            for (ASTClassOrInterfaceDeclarationMember member : members) {
                if (member instanceof ASTClassOrInterfaceMethodDeclaration) {
                    ASTClassOrInterfaceMethodDeclaration methodDeclaration = (ASTClassOrInterfaceMethodDeclaration) member;
                    usedNames.addAll(getUsedNamesFromMethodDeclaration(compilationUnit, methodDeclaration));
                } else if (member instanceof ASTClassOrInterfaceFieldDeclaration) {
                    ASTClassOrInterfaceFieldDeclaration fieldDeclaration = (ASTClassOrInterfaceFieldDeclaration) member;
                    usedNames.addAll(getUsedNamesFromFieldDeclaration(compilationUnit, fieldDeclaration));
                }
            }
        }
        return usedNames;
    }

    private Set<String> getUsedNamesFromMethodDeclaration(ASTCompilationUnit compilationUnit, ASTMethodDeclaration methodDeclaration) {
        Set<String> usedNames = new HashSet<>();
        NodeStream<ASTFormalParameter> parameters = methodDeclaration.getParameters();
        for (ASTFormalParameter parameter : parameters) {
            usedNames.addAll(getUsedNamesFromFormalParameter(compilationUnit, parameter));
        }
        NodeStream<ASTStatement> statements = methodDeclaration.getStatements();
        for (ASTStatement statement : statements) {
            usedNames.addAll(getUsedNamesFromStatement(compilationUnit, statement));
        }
        NodeStream<ASTExpression> expressions = methodDeclaration.getExpressions();
        for (ASTExpression expression : expressions) {
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, expression));
        }
        return usedNames;
    }

    private Set<String> getUsedNamesFromFieldDeclaration(ASTCompilationUnit compilationUnit, ASTFieldDeclaration fieldDeclaration) {
        Set<String> usedNames = new HashSet<>();
        NodeStream<ASTVariableDeclarator> declarators = fieldDeclaration.getDeclarators();
        for (ASTVariableDeclarator declarator : declarators) {
            usedNames.addAll(getUsedNamesFromVariableDeclarator(compilationUnit, declarator));
        }
        return usedNames;
    }

    private Set<String> getUsedNamesFromClassOrInterfaceType(ASTCompilationUnit compilationUnit, ASTClassOrInterfaceType classOrInterfaceType) {
        Set<String> usedNames = new HashSet<>();
        NodeStream<ASTTypeArgument> typeArguments = classOrInterfaceType.getTypeArguments();
        for (ASTTypeArgument typeArgument : typeArguments) {
            usedNames.addAll(getUsedNamesFromTypeArgument(compilationUnit, typeArgument));
        }
        return usedNames;
    }

    private Set<String> getUsedNamesFromFormalParameter(ASTCompilationUnit compilationUnit, ASTFormalParameter formalParameter) {
        Set<String> usedNames = new HashSet<>();
        usedNames.addAll(getUsedNamesFromExpression(compilationUnit, formalParameter.getType()));
        return usedNames;
    }

    private Set<String> getUsedNamesFromStatement(ASTCompilationUnit compilationUnit, ASTStatement statement) {
        Set<String> usedNames = new HashSet<>();
        if (statement instanceof ASTExpressionStatement) {
            ASTExpressionStatement expressionStatement = (ASTExpressionStatement) statement;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, expressionStatement.getExpression()));
        } else if (statement instanceof ASTThrowStatement) {
            ASTThrowStatement throwStatement = (ASTThrowStatement) statement;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, throwStatement.getExpression()));
        } else if (statement instanceof ASTReturnStatement) {
            ASTReturnStatement returnStatement = (ASTReturnStatement) returnStatement;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, returnStatement.getExpression()));
        }
        return usedNames;
    }

    private Set<String> getUsedNamesFromExpression(ASTCompilationUnit compilationUnit, ASTExpression expression) {
        Set<String> usedNames = new HashSet<>();
        if (expression instanceof ASTMethodInvocation) {
            ASTMethodInvocation methodInvocation = (ASTMethodInvocation) expression;
            usedNames.add(methodInvocation.getName());
            NodeStream<ASTExpression> arguments = methodInvocation.getArguments();
            for (ASTExpression argument : arguments) {
                usedNames.addAll(getUsedNamesFromExpression(compilationUnit, argument));
            }
        } else if (expression instanceof ASTFieldAccess) {
            ASTFieldAccess fieldAccess = (ASTFieldAccess) expression;
            usedNames.add(fieldAccess.getName());
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, fieldAccess.getExpression()));
        } else if (expression instanceof ASTLiteral) {
            ASTLiteral literal = (ASTLiteral) expression;
            usedNames.add(literal.getImage());
        } else if (expression instanceof ASTArrayAccess) {
            ASTArrayAccess arrayAccess = (ASTArrayAccess) expression;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, arrayAccess.getArray()));
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, arrayAccess.getIndex()));
        } else if (expression instanceof ASTArrayCreation) {
            ASTArrayCreation arrayCreation = (ASTArrayCreation) expression;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, arrayCreation.getType()));
            NodeStream<ASTExpression> initializers = arrayCreation.getInitializers();
            for (ASTExpression initializer : initializers) {
                usedNames.addAll(getUsedNamesFromExpression(compilationUnit, initializer));
            }
        } else if (expression instanceof ASTClassOrInterfaceType) {
            ASTClassOrInterfaceType classOrInterfaceType = (ASTClassOrInterfaceType) expression;
            usedNames.add(classOrInterfaceType.getName());
        } else if (expression instanceof ASTName) {
            ASTName name = (ASTName) expression;
            usedNames.add(name.getImage());
        } else if (expression instanceof ASTCastExpression) {
            ASTCastExpression castExpression = (ASTCastExpression) expression;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, castExpression.getExpression()));
        } else if (expression instanceof ASTUnaryExpression) {
            ASTUnaryExpression unaryExpression = (ASTUnaryExpression) expression;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, unaryExpression.getExpression()));
        } else if (expression instanceof ASTBinaryExpression) {
            ASTBinaryExpression binaryExpression = (ASTBinaryExpression) expression;
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, binaryExpression.getLeftOperand()));
            usedNames.addAll(getUsedNamesFromExpression(compilationUnit, binaryExpression.getRightOperand()));
        } else if (expression instanceof ASTLiteralBoolean) {
            ASTLiteralBoolean literalBoolean = (ASTLiteralBoolean) expression;
            usedNames.add(literalBoolean.getImage());
        } else if (expression instanceof ASTLiteralCharacter) {
            ASTLiteralCharacter literalCharacter = (ASTLiteralCharacter) expression;
            usedNames.add(literalCharacter.getImage());
        } else if (expression instanceof ASTLiteralLong) {
            ASTLiteralLong literalLong = (ASTLiteralLong) expression;
            usedNames.add(literalLong.getImage());
        } else if (expression instanceof ASTLiteralFloat) {
            ASTLiteralFloat literalFloat = (ASTLiteralFloat) expression;
            usedNames.add(literalFloat.getImage());
        } else if (expression instanceof ASTLiteralDouble) {
            ASTLiteralDouble literalDouble = (ASTLiteralDouble) expression;
            usedNames.add(literalDouble.getImage());
        } else if (expression instanceof ASTLiteralByte) {
            ASTLiteralByte literalByte = (ASTLiteralByte) expression;
            usedNames.add(literalByte.getImage());
        } else if (expression instanceof ASTLiteralShort) {
            ASTLiteralShort literalShort = (ASTLiteralShort) expression;
            usedNames.add(literalShort.getImage());
        } else if (expression instanceof ASTLiteralInteger) {
            ASTLiteralInteger literalInteger = (ASTLiteralInteger) expression;
            usedNames.add(literalInteger.getImage());
        } else if (expression instanceof ASTLiteralString) {
            ASTLiteralString literalString = (ASTLiteralString) expression;
            usedNames.add(literalString.getImage());
        } else if (expression instanceof ASTLiteralNull) {
            ASTLiteralNull literalNull = (ASTLiteralNull) expression;
            usedNames.add(literalNull.getImage());
        } else if (expression instanceof ASTNullLiteral) {
            ASTNullLiteral nullLiteral = (ASTNullLiteral) expression;
            usedNames.add(nullLiteral.getImage());
        }
        return usedNames;
    }

    private Set<String> getUsedNamesFromVariableDeclarator(ASTCompilationUnit compilationUnit, ASTVariableDeclarator variableDeclarator) {
        Set<String> usedNames = new HashSet<>();
        usedNames.addAll(getUsedNamesFromExpression(compilationUnit, variableDeclarator.getInitializer()));
        return usedNames;
    }

    private Set<String> getUsedNamesFromTypeArgument(ASTCompilationUnit compilationUnit, ASTTypeArgument typeArgument) {
        Set<String> usedNames = new HashSet<>();
        if (typeArgument instanceof ASTWildcardTypeArgument) {
            ASTWildcardTypeArgument wildcardTypeArgument = (ASTWildcardTypeArgument) typeArgument;
            usedNames.add(wildcardTypeArgument.getUpperBound().getImage());
            usedNames.add(wildcardTypeArgument.getLowerBound().getImage());
        } else if (typeArgument instanceof ASTClassOrInterfaceTypeArgument) {
            ASTClassOrInterfaceTypeArgument classOrInterfaceTypeArgument = (ASTClassOrInterfaceTypeArgument) typeArgument;
            usedNames.add(classOrInterfaceTypeArgument.getType().getImage());
        } else if (typeArgument instanceof ASTPrimitiveTypeArgument) {
            ASTPrimitiveTypeArgument primitiveTypeArgument = (ASTPrimitiveTypeArgument) typeArgument;
            usedNames.add(primitiveTypeArgument.getType().getImage());
        }
        return usedNames;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

出现语法错误，这一轮舍弃，直接重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {

    public UnnecessaryImportRule() {
        super(NodeTypes.IMPORTS, NodeTypes.IMPORT, NodeTypes.ASSERT_STATIC_IMPORT, NodeTypes.ASSERT_STATIC_IMPORT_PARAM, NodeTypes.TYPE_IMPORT, NodeTypes.WILDCARD_IMPORT, NodeTypes.STATIC_IMPORT, NodeTypes.STATIC_IMPORT_PARAM, NodeTypes.JAVADOC_LINK, NodeTypes.JAVADOC_SEE, NodeTypes.JAVADOC_THROWS);
    }

    @Override
    public Object visit(NodeTypes.IMPORTS imports, Object data) {
        return super.visit(imports, data);
    }

    @Override
    public Object visit(NodeTypes.IMPORT importNode, Object data) {
        return super.visit(importNode, data);
    }

    @Override
    public Object visit(NodeTypes.ASSERT_STATIC_IMPORT assertStaticImport, Object data) {
        return super.visit(assertStaticImport, data);
    }

    @Override
    public Object visit(NodeTypes.ASSERT_STATIC_IMPORT_PARAM assertStaticImportParam, Object data) {
        return super.visit(assertStaticImportParam, data);
    }

    @Override
    public Object visit(NodeTypes.TYPE_IMPORT typeImport, Object data) {
        return super.visit(typeImport, data);
    }

    @Override
    public Object visit(NodeTypes.WILDCARD_IMPORT wildcardImport, Object data) {
        return super.visit(wildcardImport, data);
    }

    @Override
    public Object visit(NodeTypes.STATIC_IMPORT staticImport, Object data) {
        return super.visit(staticImport, data);
    }

    @Override
    public Object visit(NodeTypes.STATIC_IMPORT_PARAM staticImportParam, Object data) {
        return super.visit(staticImportParam, data);
    }

    @Override
    public Object visit(NodeTypes.JAVADOC_LINK javadocLink, Object data) {
        return super.visit(javadocLink, data);
    }

    @Override
    public Object visit(NodeTypes.JAVADOC_SEE javadocSee, Object data) {
        return super.visit(javadocSee, data);
    }

    @Override
    public Object visit(NodeTypes.JAVADOC_THROWS javadocThrows, Object data) {
        return super.visit(javadocThrows, data);
    }

    @Override
    public Object visit(NodeTypes.IMPORT_STATEMENT importStatement, Object data) {
        if (isImportFromSamePackage(importStatement)) {
            return data;
        }

        if (hasImportWithSameName(importStatement)) {
            return data;
        }

        if (isImportOfJavaLangTypes(importStatement)) {
            return data;
        }

        if (isImportOfUsedTypes(importStatement)) {
            return data;
        }

        if (isImportUsedInJavadoc(importStatement)) {
            return data;
        }

        if (isStaticImportOfUsedTypes(importStatement)) {
            return data;
        }

        if (hasImportDuplicates(importStatement)) {
            return data;
        }

        if (hasWildcardImportDuplicates(importStatement)) {
            return data;
        }

        if (hasSingleTypeImportAfterWildcardImport(importStatement)) {
            return data;
        }

        if (hasImportDuplicatesWithStaticImports(importStatement)) {
            return data;
        }

        if (hasImportDuplicatesWithWildcardImports(importStatement)) {
            return data;
        }

        List<ImportNode> importNodes = getImportNodes(importStatement);
        if (importNodes.isEmpty()) {
            return data;
        }

        for (ImportNode importNode : importNodes) {
            if (isImportUsed(importNode)) {
                return data;
            }
        }

        return addViolation(this, data, "Unused import", importStatement);
    }

    private boolean isImportFromSamePackage(ImportStatement importStatement) {
        if (importStatement.getScope() == null) {
            return false;
        }

        String packageName = importStatement.getScope().getPackageName();
        if (packageName == null) {
            return false;
        }

        String importPackage = importStatement.getImportName().getPackageName();
        if (importPackage == null) {
            return false;
        }

        return packageName.equals(importPackage);
    }

    private boolean hasImportWithSameName(ImportStatement importStatement) {
        List<ImportNode> importNodes = getImportNodes(importStatement);
        if (importNodes.isEmpty()) {
            return false;
        }

        for (ImportNode importNode : importNodes) {
            String importName = importNode.getImportName().getName();
            if (importName.equals(importStatement.getImportName().getName())) {
                return true;
            }
        }

        return false;
    }

    private boolean isImportOfJavaLangTypes(ImportStatement importStatement) {
        if (importStatement.getImportName().getPackageName() == null) {
            return false;
        }

        String packageName = importStatement.getImportName().getPackageName();
        if (packageName.equals("java.lang")) {
            return true;
        }

        return false;
    }

    private boolean isImportOfUsedTypes(ImportStatement importStatement) {
        List<ImportNode> importNodes = getImportNodes(importStatement);
        if (importNodes.isEmpty()) {
            return false;
        }

        for (ImportNode importNode : importNodes) {
            if (isImportUsed(importNode)) {
                return true;
            }
        }

        return false;
    }

    private boolean isImportUsedInJavadoc(ImportStatement importStatement) {
        List<ImportNode> importNodes = getImportNodes(importStatement);
        if (importNodes.isEmpty()) {
            return false;
        }

        for (ImportNode importNode : importNodes) {
            if (isImportUsedInJavadoc(importNode)) {
                return true;
            }
        }

        return false;
    }

    private boolean isStaticImportOfUsedTypes(ImportStatement importStatement) {
        List<StaticImportParam> staticImportParams = getStaticImportParams(importStatement);
        if (staticImportParams.isEmpty()) {
            return false;
        }

        for (StaticImportParam staticImportParam : staticImportParams) {
            if (isImportUsed(staticImportParam)) {
                return true;
            }
        }

        return false;
    }

    private boolean hasImportDuplicates(ImportStatement importStatement) {
        List<ImportNode> importNodes = getImportNodes(importStatement);
        if (importNodes.size() != new HashSet<>(importNodes).size()) {
            return true;
        }

        return false;
    }

    private boolean hasWildcardImportDuplicates(ImportStatement importStatement) {
        List<WildcardImport> wildcardImports = getWildcardImports(importStatement);
        if (wildcardImports.size() != new HashSet<>(wildcardImports).size()) {
            return true;
        }

        return false;
    }

    private boolean hasSingleTypeImportAfterWildcardImport(ImportStatement importStatement) {
        List<WildcardImport> wildcardImports = getWildcardImports(importStatement);
        List<ImportNode> importNodes = getImportNodes(importStatement);

        for (int i = 0; i < importNodes.size(); i++) {
            if (isWildcardImport(wildcardImports.get(i))) {
                if (i + 1 < importNodes.size() && !isWildcardImport(importNodes.get(i + 1))) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean hasImportDuplicatesWithStaticImports(ImportStatement importStatement) {
        List<StaticImportParam> staticImportParams = getStaticImportParams(importStatement);
        if (staticImportParams.size() != new HashSet<>(staticImportParams).size()) {
            return true;
        }

        return false;
    }

    private boolean hasImportDuplicatesWithWildcardImports(ImportStatement importStatement) {
        List<WildcardImport> wildcardImports = getWildcardImports(importStatement);
        if (wildcardImports.size() != new HashSet<>(wildcardImports).size()) {
            return true;
        }

        return false;
    }

    private List<ImportNode> getImportNodes(ImportStatement importStatement) {
        List<ImportNode> importNodes = new ArrayList<>();

        if (importStatement.getImportName() != null) {
            importNodes.add(importStatement.getImportName());
        }

        if (importStatement.getStaticImports() != null) {
            importNodes.addAll(importStatement.getStaticImports());
        }

        return importNodes;
    }

    private List<StaticImportParam> getStaticImportParams(ImportStatement importStatement) {
        List<StaticImportParam> staticImportParams = new ArrayList<>();

        if (importStatement.getStaticImports() != null) {
            staticImportParams.addAll(importStatement.getStaticImports());
        }

        return staticImportParams;
    }

    private List<WildcardImport> getWildcardImports(ImportStatement importStatement) {
        List<WildcardImport> wildcardImports = new ArrayList<>();

        if (importStatement.getWildcardImports() != null) {
            wildcardImports.addAll(importStatement.getWildcardImports());
        }

        return wildcardImports;
    }

    private boolean isImportUsed(ImportNode importNode) {
        if (importNode.getUsage() != null) {
            return true;
        }

        if (importNode.getUsageInJavadoc() != null) {
            return true;
        }

        return false;
    }

    private boolean isImportUsedInJavadoc(ImportNode importNode) {
        if (importNode.getUsageInJavadoc() != null) {
            return true;
        }

        return false;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Reports import statements that can be removed. They are either unused, duplicated, or the members they import are already implicitly in scope, because they’re in java.lang, or the current package.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// simple unused single type import
import java.io.File;
public class Foo {}
```
2. This is a positive test case
```java
// one used single type import
import java.io.File;
public class Foo {
    private File file;
}
```
3. This is a negative test case
```java
// 2 unused single-type imports
import java.io.File;
import java.util.List;
public class Foo {
}
```
4. This is a positive test case
```java
// 1 used single type import
import java.security.AccessController;
public class Foo {
    public void foo() {
        AccessController.doPrivileged(null);
    }
}
```
5. This is a positive test case
```java
// 1 import stmt, used only in throws clause
import java.rmi.RemoteException;
public class Foo {
    public void foo() throws RemoteException {}
}
```
6. This is a positive test case
```java
// for loop
import java.util.ArrayList;
public class Foo {
    public void foo(ArrayList list) {
        for (String s : list) {}
    }
}
```
7. This is a positive test case
```java
// Generics
import foo.TestInterfaceTwo;
import java.util.*;
public class Foo {
    private List<TestInterfaceTwo> x = new ArrayList<TestInterfaceTwo>();
}
```
8. This is a positive test case
```java
// Generics 2
import java.util.Collection;
import java.util.List;
import java.util.ArrayList;
public class Foo {
    private List<Collection> x = new ArrayList<Collection>();
}
```
9. This is a positive test case
```java
// Annotations
import foo.annotation.Retention;
import foo.annotation.RetentionPolicy;
@Retention(RetentionPolicy.RUNTIME)
public @interface Foo {
}
```
10. This is a positive test case
```java
// Annotations 2
import foo.FooAnnotation1;
import foo.FooAnnotation2;
@FooAnnotation1
@FooAnnotation2
public class Foo {}
```
11. This is a negative test case
```java
// import from default package
import Bar;
public class Foo {
    public Bar foo() {}
}
```
12. This is a positive test case
```java
// import from default package from somewhere else
package somewhere;
import Bar;
public class Foo {
    public Bar foo() {}
}
```
13. This is a negative test case
```java
// import from default package
package somewhere;
import Bar;
public class Foo {
    public void foo() {}
}
```
14. This is a negative test case
```java
// Used static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo(){
        staticMethod("This is OK");
    }
}
```
15. This is a negative test case
```java
// Unused static import
import static com.foo.MyClass.staticMethod;
public class Foo {
    public Foo() {
    }
}
```
16. This is a positive test case
```java
// On demand import
import java.util.*;
public class Foo {
    List list = new ArrayList();
}
```
17. This is a positive test case
```java
// imports used in javadoc comment, see also bug #254
import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;
import java.util.LinkedList;
import java.util.File;
import java.util.NoSuchElementException;
import java.io.IOException;

public class Foo {
    /**
     * {@linkplain  List list}
     * {@link  ArrayList  arraylist}
     * {@link  LinkedList}
     * {@value  Calendar#DATE}
     * @see File
     * @throws NoSuchElementException no such element
     * @exception IOException IO operation exception
     */
    public void test() {}
}
```
18. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
19. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc link with array type
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, SomeObjectArray[])} method does something.
     */
    public void someMethod() {
    }
}
```
20. This is a positive test case
```java
// Bug 2606609 : False "UnusedImports" positive in package-info.java
@DefaultAnnotation(NonNull.class)
package net.sourceforge.pmd.test;

import edu.umd.cs.findbugs.annotations.DefaultAnnotation;
import edu.umd.cs.findbugs.annotations.NonNull;
```
21. This is a positive test case
```java
// bug #254 False+ : UnusedImport with Javadoc @link
import java.util.ArrayList;
import java.util.Collections;
import java.util.NoSuchElementException;

public class Test {
    /**
     * {@link ArrayList#add(Object)}
     * @see Collections
     * @throws NoSuchElementException no such element
     */
    String[] getList() { }
}
```
22. This is a positive test case
```java
// #1181 unused import false positive if used as parameter in javadoc only.
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Vector;

public class Foo {
    /**
     * See here: {@link Collections#reverse(List, Collection)}
     * @see Collections#reverse(ArrayList, Vector)
     */
    public Object bar() {}
}
```
23. This is a positive test case
```java
// #1280 False Positive in UnusedImports when import used in javadoc
import some.pack.SomeUtility;

public class Foo {
    /**
     * The {@link SomeUtility#someHelperMethod(String, test.SomeObject)} method does something.
     */
    public void someMethod() {
    }
}
```
24. This is a positive test case
```java
// #914 False +ve from UnusedImports with wildcard static imports
import static org.junit.Assert.*;
import org.junit.Test;
import static java.lang.Math.*;

public class FooTest {
    @Test
    public void testStuff() {
        assertEquals( "a", "a" );
        assertFalse( false );
        assertTrue( true );
        assertNull( null );
    }
    public static void main(String[] args) {
        System.out.println(PI);
    }
}
```
25. This is a positive test case
```java
// #1465 False Positve UnusedImports with javadoc @link
import a.b.c.d.AgentState;
import a.b.c.d.OtherState;

public interface Foo {
    /**
     * Gets all active AgentHandles.
     * <p/>
     * An agent is active if it has not posted a {@link AgentStateChangeEvent} containing {@link AgentState#TERMINATED}.
     *
     * @return agent handles.
     * @see OtherState#TERMINATED
     */
    Iterable<AgentHandle> getAgentHandles();
}
```
26. This is a positive test case
```java
// #1547 False Positve UnusedImports with javadoc for identifiers with underscores
import java.net.HttpURLConnection;

import foo.bar.Some_Thing;
import foo.bar.Under_Score_Exception;
import foo.bar.Fixed_Values;

/**
 * {@link HttpURLConnection#HTTP_NOT_ACCEPTABLE}
 *
 * {@value Fixed_Values#FOO_BAR}
 *
 * @see Some_Thing#SOMETHING_ELSE
 */
public interface Interface {

    /**
     * @throws Under_Score_Exception
     */
    void doSomething();

}
```
27. This is a positive test case
```java
// #348 False Positive UnusedImports with javadoc for public static inner classes of imports
import javax.swing.GroupLayout;

public class Foo {

    /**
     * {@link Bar#doSomething(GroupLayout.Group)}
     */
    void doSomething();
}
```
28. This is a positive test case
```java
// #925 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    System.out.println("List 1: " + LIST1);
                    System.out.println("List 2: " + LIST2);
                }
            }
```
29. This is a positive test case
```java
// #1404 [java] UnusedImports false positive for static import
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ClassWithStringConstants.*;

            public class ClassWithImport {

                public static void main(String[] args) {
                    if (CONST1.equals("a")) {
                        System.out.println("CONST1 is a");
                    }
                }
            }
```
30. This is a positive test case
```java
// #1209 [java] UnusedImports false positive for static import with package-private method usage
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PackagePrivateUtils.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.PublicUtils.*;

            public class Imports {

                int importtest() {
                    int i = 0;
                    i = f1(i);
                    i = g1(i);
                    i = f2(i);
                    i = g2(i);
                    i = f3(i);
                    i = g3(i);
                    return i;
                }
            }
```
31. This is a positive test case
```java
// #1625 [java] UnusedImports false positive for method parameter type in @see Javadoc
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File) */
    void main() {}
}
```
32. This is a positive test case
```java
// #1720 False Positive in UnusedImports for Javadoc @see with array type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import java.io.File;
import java.io.FileInputStream;

public class Derived extends FileInputStream {
    /** @see #FileInputStream(File, File[]) */
    void main() {}
}
```
33. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @see with FQCN
import spark.Response; // flaged, should not

/**
 * @see foo.bar.MyController#startTransaction(Response)
 */
public class VendingV2PaymentRequest {
}
```
34. This is a positive test case
```java
// #2025 False Positive in UnusedImports for params when using @link with FQCN
import spark.Request; // flaged, should not

/**
 * {@link foo.bar.MyController#startTransaction(Request)}
 */
public class VendingV2PaymentRequest {
}
```
35. This is a positive test case
```java
// #2016 [java] UnusedImports: False positive if wildcard is used and only static methods
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

// star import is important here for the test case!!
import java.util.*;

/**
 * Note: In order for this test case to work, the class "Issue2016" must also be compiled and available
 * on the auxclasspath.
 */
public class Issue2016 {
    public void testFunction() {
        Objects.toString(null);
    }
}
```
36. This is a positive test case
```java
// resolve ambiguous static on-demand imports (#2277)
import static java.lang.Integer.*;
import static java.lang.Long.valueOf;
import static java.lang.Long.*;

public class Foo {
    public void foo() {
        // the "valueOf" method is both in Integer.* and Long.*
        // we need an explicit static import to specify one of them, e.g. Long.valueOf
        valueOf("123", 10);

        // covered by Integer.*
        int i = parseInt("123");

        // covered by Long.*
        long l = parseLong("123");
    }
}
```
37. This is a positive test case
```java
// [java] UnusedImports with static imports on subclasses #3132
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.*; // flagged as unused

public class Test {
    public static void main(String... args) {
        sayHello();
    }
}
```
38. This is a negative test case
```java
// Unused import with member inherited AND imported
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.HelloMore.sayHello;

public class Test extends HelloMore {
    public static void main(String... args) {
        // import is unused as the method is inherited here
        sayHello();
    }
}
```
39. This is a negative test case
```java
// NPE with static import on interface
import static javax.swing.WindowConstants.*; //warn

class NPEImport {}
```
40. This is a negative test case
```java
// duplicate single type imports
import java.io.File;
            import java.util.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
41. This is a negative test case
```java
// duplicate wildcard imports
import java.io.*;
            import java.io.*;
            public class Foo {
                File f;
            }
```
42. This is a negative test case
```java
// single type import after wildcard import
import java.io.*;
            import java.io.File;
            public class Foo {
                File f;
            }
```
43. This is a positive test case
```java
// subpackage import, ok
import java.util.*;
            import java.util.logging.*;
            public class Foo {
                List c; Logger f;
            }
```
44. This is a positive test case
```java
// 674394, disambiguation import should be allowed
import java.awt.*;
            import java.util.*;
            import java.util.List; //False positive

            class Foo{
                Color color;
                List list;
                Set set;
            }
```
45. This is a negative test case
```java
// 674394, disambiguation import because of conflict with java.lang
import foo.*;
            import foo.System;  //False positive

            class Foo {
                System system;  //No, I do not mean java.lang.System
            }
```
46. This is a negative test case
```java
// #1306 False positive on duplicate when using static imports
import static org.junit.Assert.*;
            import static net.sourceforge.pmd.lang.java.rule.codestyle.UnnecessaryImportTest.*;
            import static org.junit.Assert.assertTrue;
            // this import is needed for disambiguation - as DuplicateImportsTest
            // defines assertTrue with the same signature, too.

            public class DuplicateImports {
                static {
                    assertTrue("", true); // the one from the disambiguation import
                    assertSomething("", true); // from UnnecessaryImportTest.*
                    assertFalse("", true); // from Assert.*
                }
            }
```
47. This is a positive test case
```java
// Static on-demand import is used
import static org.junit.Assert.*;
            import static org.junit.Assert.assertTrue;

            public class DuplicateImports {
                static {
                    assertTrue("", true);
                    assertFalse("", true);
                }
            }
```
48. This is a negative test case
```java
// [java]  similar imports static/nonstatic with method #2546
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo -- used
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    foo();
                }
            }
```
49. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is used
// imports NonStatic -- unused
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    Static b;
                }
            }
```
50. This is a negative test case
```java
// [java] #2546 -- similar imports static/nonstatic - static is unused
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static -- unused
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    NonStatic b;
                }
            }
```
51. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports Static
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    Static b;
                }
            }
```
52. This is a positive test case
```java
// [java] #2546 -- similar imports static/nonstatic - both are used (method)
// imports NonStatic
            import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;
            // imports foo()
            import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.NonStaticContainer.*;

            public class DuplicateImports {
                static {
                    // both are used
                    NonStatic a;
                    foo();
                }
            }
```
53. This is a negative test case
```java
// ImportFromSamePackage: simple failure
package foo;
            import foo.Bar;
            public class Baz {
                Bar bar;
            }
```
54. This is a positive test case
```java
// ImportFromSamePackage: class in default package importing from sub package
package foo;
            import foo.buz.Bar;
            public class Baz{
                Bar b;
            }
```
55. This is a negative test case
```java
// ImportFromSamePackage: importing all from same package
package foo.bar;
            import foo.bar.*;
            public class Baz{}
```
56. This is a negative test case
```java
// import java.lang.String (used)
import java.lang.String;
            public class Foo {
                String foo;
            }
```
57. This is a negative test case
```java
// import java.lang.String (unused)
import java.lang.String;
            public class Foo { }
```
58. This is a positive test case
```java
// import java.lang type when it shadows a same package type
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo {
                String foo;
            }
```
59. This is a negative test case
```java
// import java.lang type when it shadows a same package type (unused)
// this package redefines a String type
            package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.javalang;

            import java.lang.String;
            public class Foo { }
```
60. This is a negative test case
```java
// import java.lang.*
import java.lang.*;
            public class Foo {}
```
61. This is a positive test case
```java
// import java.lang.ref/reflect/annotation/instrument/management
import java.lang.ref.*;
            import java.lang.reflect.*;
            import java.lang.annotation.*;
            import java.lang.management.*;
            public class Foo {
                Annotation a; Method m; WeakReference r;
                RuntimeMXBean x;
            }
```
62. This is a positive test case
```java
// Static Java imports are OK
import static java.lang.String.*;
            public class Foo {
                static {
                    valueOf(1);
                }
            }
```
63. This is a negative test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler, unused
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                Thread.UncaughtExceptionHandler unused;
            }
```
64. This is a positive test case
```java
// Importing java.lang.Thread.UncaughtExceptionHandler
import java.lang.Thread.UncaughtExceptionHandler;
            public class Foo {
                UncaughtExceptionHandler used;
            }
```
65. This is a positive test case
```java
// import java.lang.ProcessBuilder.Redirect: #1031 false DontImportJavaLang
import java.lang.ProcessBuilder.Redirect;

            public class Foo {
                Redirect r;
            }
```
66. This is a positive test case
```java
// import java.lang.invoke.MethodHandles: #339 false DontImportJavaLang
import java.lang.invoke.MethodHandles;

            public class Foo {
                static {
                    MethodHandles.argumentsWithCombiner();// use it
                }
            }
```
67. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports #2655
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    private void g() {
        String k = C.V;
    }
}
```
68. This is a positive test case
```java
// static import of a type
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscriber;
import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Publisher;
import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.ConcFlow.Subscription;

/**
 * {@link Flow.Subscription#request(long) request}
 * {@link Flow.Subscription}
 */
public class SubmissionPublisher<T> implements Publisher<T> {
    static final class ConsumerSubscriber<T> implements Subscriber<T> {
        Subscription subscription;
    }
}
```
69. This is a positive test case
```java
// [java] UnnecessaryImport false positive for on-demand imports of non-static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    IC c;
}
```
70. This is a positive test case
```java
// [java] UnnecessaryImport false positive for static on-demand imports of static nested classes
package net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package1;

import static net.sourceforge.pmd.lang.java.rule.codestyle.unnecessaryimport.package2.C.*; // SUPPRESS CHECKSTYLE needed for test case

public class U {
    ISC sc;
}
```
71. This is a positive test case
```java
// Necessary imports for @snippet tags introduced with JEP 413 in Java 18
import java.math.BigDecimal;
import java.util.ArrayList;

/**
 * {@snippet :
 *    BigDecimal n = new BigDecimal("10.0"); // @link substring="BigDecimal" target="BigDecimal"
 * }
 *
 * <p>Other example:
 * {@snippet :
 *    Sample.add(this); // @link target="ArrayList#add(Object)"
 * }
 */
public class Sample {
    // ...
}
```
72. This is a positive test case
```java
// #4432 - Necessary import for interface method
package p;

            import static p.Top2.foo;

            class Klass implements Top {
                static {
                    foo(); // This is Top2.foo
                }

                static class Child {
                    {
                        foo(); // This is also Top2.foo
                    }
                }
            }
            interface Top {
                static void foo() {}
            }
            interface Top2 {
                static void foo() {}
            }
```
73. This is a positive test case
```java
// #4557 - UnnecessaryImport FP with static imports of overloaded methods
package p;

            import static p.Static.assertThat;

            class Klass {
                static {
                    assertThat(1); // This is assertThat(Integer)
                }
            }
            class Static {

                public static Object assertThat(Integer actual) {
                    return null;
                }

                public static Object assertThat(Long actual) {
                    return null;
                }
            }
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.codestyle;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class UnnecessaryImportRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.codestyle;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class UnnecessaryImportRule extends AbstractJavaRulechainRule {

    public UnnecessaryImportRule() {
        super("unused", "Unused import", "Unused import", RuleChainVisitorWrapper.class, JavaPackageImport.class);
    }

    @Override
    public Object visit(JavaPackageImport node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(JavaSingleTypeImport node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(JavaWildcardImport node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(JavaStaticImport node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(JavaStaticImportMember node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(JavaImportList node, Object data) {
        List<JavaImport> imports = new ArrayList<>();
        for (JavaImport importNode : node.getImports()) {
            if (importNode instanceof JavaSingleTypeImport) {
                JavaSingleTypeImport singleImport = (JavaSingleTypeImport) importNode;
                String qualifiedName = singleImport.getQualifiedName();
                if (!usedInClass(singleImport)) {
                    imports.add(singleImport);
                } else {
                    java.util.List<JavaImport> sameClassImports = findSameClassImports(singleImport);
                    if (sameClassImports.size() == 0) {
                        imports.add(singleImport);
                    }
                }
            } else if (importNode instanceof JavaStaticImport) {
                JavaStaticImport staticImport = (JavaStaticImport) importNode;
                String qualifiedName = staticImport.getQualifiedName();
                if (!usedInClass(staticImport)) {
                    imports.add(staticImport);
                } else {
                    java.util.List<JavaImport> sameClassImports = findSameClassImports(staticImport);
                    if (sameClassImports.size() == 0) {
                        imports.add(staticImport);
                    }
                }
            } else if (importNode instanceof JavaWildcardImport) {
                JavaWildcardImport wildcardImport = (JavaWildcardImport) importNode;
                String qualifiedName = wildcardImport.getQualifiedName();
                if (!usedInClass(wildcardImport)) {
                    imports.add(wildcardImport);
                } else {
                    java.util.List<JavaImport> sameClassImports = findSameClassImports(wildcardImport);
                    if (sameClassImports.size() == 0) {
                        imports.add(wildcardImport);
                    }
                }
            }
        }
        return imports;
    }

    @Override
    public Object visit(JavaImport node, Object data) {
        List<JavaImport> imports = new ArrayList<>();
        if (node instanceof JavaSingleTypeImport) {
            JavaSingleTypeImport singleImport = (JavaSingleTypeImport) node;
            String qualifiedName = singleImport.getQualifiedName();
            if (!usedInClass(singleImport)) {
                imports.add(singleImport);
            } else {
                java.util.List<JavaImport> sameClassImports = findSameClassImports(singleImport);
                if (sameClassImports.size() == 0) {
                    imports.add(singleImport);
                }
            }
        } else if (node instanceof JavaStaticImport) {
            JavaStaticImport staticImport = (JavaStaticImport) node;
            String qualifiedName = staticImport.getQualifiedName();
            if (!usedInClass(staticImport)) {
                imports.add(staticImport);
            } else {
                java.util.List<JavaImport> sameClassImports = findSameClassImports(staticImport);
                if (sameClassImports.size() == 0) {
                    imports.add(staticImport);
                }
            }
        } else if (node instanceof JavaWildcardImport) {
            JavaWildcardImport wildcardImport = (JavaWildcardImport) node;
            String qualifiedName = wildcardImport.getQualifiedName();
            if (!usedInClass(wildcardImport)) {
                imports.add(wildcardImport);
            } else {
                java.util.List<JavaImport> sameClassImports = findSameClassImports(wildcardImport);
                if (sameClassImports.size() == 0) {
                    imports.add(wildcardImport);
                }
            }
        }
        return imports;
    }

    @Override
    public Object visit(JavaCompilationUnit node, Object data) {
        List<JavaImport> imports = new ArrayList<>();
        JavaImportList importList = node.getImports();
        if (importList != null) {
            imports = (List<JavaImport>) visit(importList, data);
        }
        return imports;
    }

    private boolean usedInClass(JavaImport importNode) {
        NodeStream<JavaNode> nodes = new NodeStream<>(node.getCompilationUnit().getAST());
        List<JavaClassOrInterfaceOwner> classOwners = new ArrayList<>();
        nodes.findByType(JavaClassOrInterfaceOwner.class).forEach(classOwner -> classOwners.add((JavaClassOrInterfaceOwner) classOwner));
        for (JavaClassOrInterfaceOwner classOwner : classOwners) {
            if (isImportedInClass(classOwner, importNode)) {
                return true;
            }
        }
        return false;
    }

    private boolean isImportedInClass(JavaClassOrInterfaceOwner classOwner, JavaImport importNode) {
        if (importNode instanceof JavaSingleTypeImport) {
            JavaSingleTypeImport singleImport = (JavaSingleTypeImport) importNode;
            String qualifiedName = singleImport.getQualifiedName();
            return classOwner.getImports().stream().anyMatch(node -> node.getQualifiedName().equals(qualifiedName));
        } else if (importNode instanceof JavaStaticImport) {
            JavaStaticImport staticImport = (JavaStaticImport) importNode;
            String qualifiedName = staticImport.getQualifiedName();
            return classOwner.getStaticImports().stream().anyMatch(node -> node.getQualifiedName().equals(qualifiedName));
        } else if (importNode instanceof JavaWildcardImport) {
            JavaWildcardImport wildcardImport = (JavaWildcardImport) importNode;
            String qualifiedName = wildcardImport.getQualifiedName();
            return classOwner.getStaticImports().stream().anyMatch(node -> node.getQualifiedName().equals(qualifiedName));
        }
        return false;
    }

    private List<JavaImport> findSameClassImports(JavaImport importNode) {
        List<JavaImport> sameClassImports = new ArrayList<>();
        if (importNode instanceof JavaSingleTypeImport) {
            JavaSingleTypeImport singleImport = (JavaSingleTypeImport) importNode;
            String qualifiedName = singleImport.getQualifiedName();
            JavaCompilationUnit compilationUnit = singleImport.getCompilationUnit();
            for (JavaImport importOther : compilationUnit.getImports()) {
                if (importOther instanceof JavaSingleTypeImport) {
                    JavaSingleTypeImport otherImport = (JavaSingleTypeImport) importOther;
                    if (otherImport.getQualifiedName().equals(qualifiedName)) {
                        sameClassImports.add(otherImport);
                    }
                } else if (importOther instanceof JavaWildcardImport) {
                    JavaWildcardImport wildcardImport = (JavaWildcardImport) importOther;
                    if (wildcardImport.getQualifiedName().equals(qualifiedName)) {
                        sameClassImports.add(wildcardImport);
                    }
                }
            }
        } else if (importNode instanceof JavaStaticImport) {
            JavaStaticImport staticImport = (JavaStaticImport) importNode;
            String qualifiedName = staticImport.getQualifiedName();
            JavaCompilationUnit compilationUnit = staticImport.getCompilationUnit();
            for (JavaImport importOther : compilationUnit.getImports()) {
                if (importOther instanceof JavaStaticImport) {
                    JavaStaticImport otherImport = (JavaStaticImport) importOther;
                    if (otherImport.getQualifiedName().equals(qualifiedName)) {
                        sameClassImports.add(otherImport);
                    }
                } else if (importOther instanceof JavaWildcardImport) {
                    JavaWildcardImport wildcardImport = (JavaWildcardImport) importOther;
                    if (wildcardImport.getQualifiedName().equals(qualifiedName)) {
                        sameClassImports.add(wildcardImport);
                    }
                }
            }
        } else if (importNode instanceof JavaWildcardImport) {
            JavaWildcardImport wildcardImport = (JavaWildcardImport) importNode;
            String qualifiedName = wildcardImport.getQualifiedName();
            JavaCompilationUnit compilationUnit = wildcardImport.getCompilationUnit();
            for (JavaImport importOther : compilationUnit.getImports()) {
                if (importOther instanceof JavaWildcardImport) {
                    JavaWildcardImport otherImport = (JavaWildcardImport) importOther;
                    if (otherImport.getQualifiedName().equals(qualifiedName)) {
                        sameClassImports.add(otherImport);
                    }
                }
            }
        }
        return sameClassImports;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 334.84346055984497 秒
