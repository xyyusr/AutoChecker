开始

========================================== Rule SignatureDeclareThrowsExceptionRule ===========================================
一共 22 个测试用例
正例 15 个
反例 7 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: A method/constructor shouldn’t explicitly throw the generic java.lang.Exception.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// method throws Exception
public class Foo {
    void foo() throws Exception {}
}
```
2. This is a positive test case
```java
// ok
public class Foo {
    void foo() {}
}
```
3. This is a negative test case
```java
// constructor throws Exception
public class Foo {
    Foo() throws Exception {}
}
```
4. This is a positive test case
```java
// constructor throws IOException
import java.io.IOException;
            public class Foo {
                Foo() throws IOException { }
            }
```
5. This is a positive test case
```java
// method throws IOException
import java.io.IOException;
            public class Foo {
                void foo() throws IOException { }
            }
```
6. This is a positive test case
```java
// skip junit3 setUp method
import junit.framework.*;
public class Foo extends TestCase {
    void setUp() throws Exception {}
}
```
7. This is a positive test case
```java
// skip junit3 tearDown method
import junit.framework.*;
public class Foo extends TestCase {
    void tearDown() throws Exception {}
}
```
8. This is a positive test case
```java
// JUnit 4 testcase
import org.junit.*;
public class Foo {
    @Before
    void setUp() throws Exception {}
}
```
9. This is a negative test case
```java
// Don't skip other methods
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
10. This is a negative test case
```java
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
11. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase
public class Foo extends net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase {
    void setUp() throws Exception {}
}
```
12. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, imported explicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
13. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, but is imported implicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.*;
public class Foo extends MyTestCase {
 void setUp() throws Exception {}
}
```
14. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase  and is in the same package
package net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception;

public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
15. This is a positive test case
```java
// Generics
public class Foo {
    public <T> Bar<T> foo() { /* blah */}
}
class Bar<X> {}
```
16. This is a positive test case
```java
// skip any method starting with 'test' for junit3
import junit.framework.*;
public class FooTest extends TestCase {
    public void testFoo() throws Exception {}
}
```
17. This is a negative test case
```java
// #913 SignatureDeclareThrowsException is raised twice
import javax.swing.SwingWorker;
public class BugSignature {
  public void record() {
    SwingWorker worker = new SwingWorker() {
      protected String construct() throws Exception {
        //
      }
    };
  }
}
```
18. This is a positive test case
```java
// #1535 [java] SignatureDeclareThrowsException: ClassCastException with Annotation
import java.util.List;
public class UnmodifiableList<T> implements @Readonly List<@Readonly T> {}
@interface Readonly {}
```
19. This is a negative test case
```java
// #350 allow throws exception when overriding a method defined elsewhere
public class BugSignature implements LousyInterface {
    @Override
    public void record() throws Exception {
    }
}
interface LousyInterface {
    void record() throws Exception; // <-- this is reported
}
```
20. This is a negative test case
```java
import junit.framework.*;

public class JUnitAnnotationTest extends TestCase {
    public JUnitAnnotationTest() throws Exception {
    }
}
```
21. This is a positive test case
```java
// #1369 ClassCastException in annotated extends
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public final class Namespace {

    @Target(ElementType.TYPE_USE)
    public @interface Weird {
    }

    public class WeirdException extends @Weird Exception {
    }

}
```
22. This is a positive test case
```java
// #4477:[java] SignatureDeclareThrowsException: false-positive with TestNG annotations
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    @org.testng.annotations.AfterClass
    void setUp() throws Exception {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: A method/constructor shouldn’t explicitly throw the generic java.lang.Exception.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// method throws Exception
public class Foo {
    void foo() throws Exception {}
}
```
2. This is a positive test case
```java
// ok
public class Foo {
    void foo() {}
}
```
3. This is a negative test case
```java
// constructor throws Exception
public class Foo {
    Foo() throws Exception {}
}
```
4. This is a positive test case
```java
// constructor throws IOException
import java.io.IOException;
            public class Foo {
                Foo() throws IOException { }
            }
```
5. This is a positive test case
```java
// method throws IOException
import java.io.IOException;
            public class Foo {
                void foo() throws IOException { }
            }
```
6. This is a positive test case
```java
// skip junit3 setUp method
import junit.framework.*;
public class Foo extends TestCase {
    void setUp() throws Exception {}
}
```
7. This is a positive test case
```java
// skip junit3 tearDown method
import junit.framework.*;
public class Foo extends TestCase {
    void tearDown() throws Exception {}
}
```
8. This is a positive test case
```java
// JUnit 4 testcase
import org.junit.*;
public class Foo {
    @Before
    void setUp() throws Exception {}
}
```
9. This is a negative test case
```java
// Don't skip other methods
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
10. This is a negative test case
```java
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
11. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase
public class Foo extends net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase {
    void setUp() throws Exception {}
}
```
12. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, imported explicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
13. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, but is imported implicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.*;
public class Foo extends MyTestCase {
 void setUp() throws Exception {}
}
```
14. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase  and is in the same package
package net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception;

public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
15. This is a positive test case
```java
// Generics
public class Foo {
    public <T> Bar<T> foo() { /* blah */}
}
class Bar<X> {}
```
16. This is a positive test case
```java
// skip any method starting with 'test' for junit3
import junit.framework.*;
public class FooTest extends TestCase {
    public void testFoo() throws Exception {}
}
```
17. This is a negative test case
```java
// #913 SignatureDeclareThrowsException is raised twice
import javax.swing.SwingWorker;
public class BugSignature {
  public void record() {
    SwingWorker worker = new SwingWorker() {
      protected String construct() throws Exception {
        //
      }
    };
  }
}
```
18. This is a positive test case
```java
// #1535 [java] SignatureDeclareThrowsException: ClassCastException with Annotation
import java.util.List;
public class UnmodifiableList<T> implements @Readonly List<@Readonly T> {}
@interface Readonly {}
```
19. This is a negative test case
```java
// #350 allow throws exception when overriding a method defined elsewhere
public class BugSignature implements LousyInterface {
    @Override
    public void record() throws Exception {
    }
}
interface LousyInterface {
    void record() throws Exception; // <-- this is reported
}
```
20. This is a negative test case
```java
import junit.framework.*;

public class JUnitAnnotationTest extends TestCase {
    public JUnitAnnotationTest() throws Exception {
    }
}
```
21. This is a positive test case
```java
// #1369 ClassCastException in annotated extends
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public final class Namespace {

    @Target(ElementType.TYPE_USE)
    public @interface Weird {
    }

    public class WeirdException extends @Weird Exception {
    }

}
```
22. This is a positive test case
```java
// #4477:[java] SignatureDeclareThrowsException: false-positive with TestNG annotations
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    @org.testng.annotations.AfterClass
    void setUp() throws Exception {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {

    public SignatureDeclareThrowsExceptionRule() {
        super(MethodDeclaration.class, ConstructorDeclaration.class, InitializerDeclaration.class, BlockStatement.class, 
                AmbientContext.class, Name.class, PrimitiveType.class, QualifiedName.class, SimpleName.class, 
                MethodInvocation.class, Statement.class, SimpleName, ParameterDeclaration.class);
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        List<MethodInvocation> methodInvocations = new ArrayList<>();
        walk(node.getBody(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    methodInvocations.add((MethodInvocation) node);
                }
            }
        });
        if (methodInvocations.isEmpty()) {
            return super.visit(node, data);
        }
        List<Name> methodInvocationsNames = new ArrayList<>();
        walk(methodInvocations, new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    MethodInvocation methodInvocation = (MethodInvocation) node;
                    if (methodInvocation.getExpression() instanceof SimpleName) {
                        methodInvocationsNames.add((SimpleName) methodInvocation.getExpression());
                    }
                }
            }
        });
        Set<QualifiedName> importedNames = new HashSet<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof ImportDeclaration) {
                    ImportDeclaration importDeclaration = (ImportDeclaration) node;
                    for (QualifiedName name : importDeclaration.getQualifiedNames()) {
                        importedNames.add(name);
                    }
                }
            }
        });
        List<Name> allNames = new ArrayList<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof SimpleName) {
                    allNames.add((SimpleName) node);
                }
            }
        });
        Set<QualifiedName> nonImportedNames = new HashSet<>();
        for (Name name : allNames) {
            if (!importedNames.contains(name.getQualifiedName())) {
                nonImportedNames.add(name.getQualifiedName());
            }
        }
        if (methodInvocationsNames.size() != nonImportedNames.size()) {
            return super.visit(node, data);
        }
        boolean hasJunit3Setup = false;
        boolean hasJunit3TearDown = false;
        boolean hasJunit4Setup = false;
        boolean hasJunit4TearDown = false;
        boolean hasSignatureDeclareThrowsException = false;
        for (int i = 0; i < methodInvocationsNames.size(); i++) {
            QualifiedName name = methodInvocationsNames.get(i);
            if (name.toString().equals("setUp") && nonImportedNames.contains(name)) {
                if (hasJunit3Setup || hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3Setup = true;
            }
            if (name.toString().equals("tearDown") && nonImportedNames.contains(name)) {
                if (hasJunit3TearDown || hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3TearDown = true;
            }
            if (name.toString().equals("@Before") && nonImportedNames.contains(name)) {
                if (hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4Setup = true;
            }
            if (name.toString().equals("@After") && nonImportedNames.contains(name)) {
                if (hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4TearDown = true;
            }
            if (name.toString().equals("record") && nonImportedNames.contains(name)) {
                if (hasSignatureDeclareThrowsException) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasSignatureDeclareThrowsException = true;
            }
        }
        if (hasSignatureDeclareThrowsException) {
            addViolation(this, node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ConstructorDeclaration node, Object data) {
        List<MethodInvocation> methodInvocations = new ArrayList<>();
        walk(node.getBody(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    methodInvocations.add((MethodInvocation) node);
                }
            }
        });
        if (methodInvocations.isEmpty()) {
            return super.visit(node, data);
        }
        List<Name> methodInvocationsNames = new ArrayList<>();
        walk(methodInvocations, new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    MethodInvocation methodInvocation = (MethodInvocation) node;
                    if (methodInvocation.getExpression() instanceof SimpleName) {
                        methodInvocationsNames.add((SimpleName) methodInvocation.getExpression());
                    }
                }
            }
        });
        Set<QualifiedName> importedNames = new HashSet<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof ImportDeclaration) {
                    ImportDeclaration importDeclaration = (ImportDeclaration) node;
                    for (QualifiedName name : importDeclaration.getQualifiedNames()) {
                        importedNames.add(name);
                    }
                }
            }
        });
        List<Name> allNames = new ArrayList<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof SimpleName) {
                    allNames.add((SimpleName) node);
                }
            }
        });
        Set<QualifiedName> nonImportedNames = new HashSet<>();
        for (Name name : allNames) {
            if (!importedNames.contains(name.getQualifiedName())) {
                nonImportedNames.add(name.getQualifiedName());
            }
        }
        if (methodInvocationsNames.size() != nonImportedNames.size()) {
            return super.visit(node, data);
        }
        boolean hasJunit3Setup = false;
        boolean hasJunit3TearDown = false;
        boolean hasJunit4Setup = false;
        boolean hasJunit4TearDown = false;
        boolean hasSignatureDeclareThrowsException = false;
        for (int i = 0; i < methodInvocationsNames.size(); i++) {
            QualifiedName name = methodInvocationsNames.get(i);
            if (name.toString().equals("setUp") && nonImportedNames.contains(name)) {
                if (hasJunit3Setup || hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3Setup = true;
            }
            if (name.toString().equals("tearDown") && nonImportedNames.contains(name)) {
                if (hasJunit3TearDown || hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3TearDown = true;
            }
            if (name.toString().equals("@Before") && nonImportedNames.contains(name)) {
                if (hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4Setup = true;
            }
            if (name.toString().equals("@After") && nonImportedNames.contains(name)) {
                if (hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4TearDown = true;
            }
            if (name.toString().equals("record") && nonImportedNames.contains(name)) {
                if (hasSignatureDeclareThrowsException) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasSignatureDeclareThrowsException = true;
            }
        }
        if (hasSignatureDeclareThrowsException) {
            addViolation(this, node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(InitializerDeclaration node, Object data) {
        List<MethodInvocation> methodInvocations = new ArrayList<>();
        walk(node.getBody(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    methodInvocations.add((MethodInvocation) node);
                }
            }
        });
        if (methodInvocations.isEmpty()) {
            return super.visit(node, data);
        }
        List<Name> methodInvocationsNames = new ArrayList<>();
        walk(methodInvocations, new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    MethodInvocation methodInvocation = (MethodInvocation) node;
                    if (methodInvocation.getExpression() instanceof SimpleName) {
                        methodInvocationsNames.add((SimpleName) methodInvocation.getExpression());
                    }
                }
            }
        });
        Set<QualifiedName> importedNames = new HashSet<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof ImportDeclaration) {
                    ImportDeclaration importDeclaration = (ImportDeclaration) node;
                    for (QualifiedName name : importDeclaration.getQualifiedNames()) {
                        importedNames.add(name);
                    }
                }
            }
        });
        List<Name> allNames = new ArrayList<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof SimpleName) {
                    allNames.add((SimpleName) node);
                }
            }
        });
        Set<QualifiedName> nonImportedNames = new HashSet<>();
        for (Name name : allNames) {
            if (!importedNames.contains(name.getQualifiedName())) {
                nonImportedNames.add(name.getQualifiedName());
            }
        }
        if (methodInvocationsNames.size() != nonImportedNames.size()) {
            return super.visit(node, data);
        }
        boolean hasJunit3Setup = false;
        boolean hasJunit3TearDown = false;
        boolean hasJunit4Setup = false;
        boolean hasJunit4TearDown = false;
        boolean hasSignatureDeclareThrowsException = false;
        for (int i = 0; i < methodInvocationsNames.size(); i++) {
            QualifiedName name = methodInvocationsNames.get(i);
            if (name.toString().equals("setUp") && nonImportedNames.contains(name)) {
                if (hasJunit3Setup || hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3Setup = true;
            }
            if (name.toString().equals("tearDown") && nonImportedNames.contains(name)) {
                if (hasJunit3TearDown || hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3TearDown = true;
            }
            if (name.toString().equals("@Before") && nonImportedNames.contains(name)) {
                if (hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4Setup = true;
            }
            if (name.toString().equals("@After") && nonImportedNames.contains(name)) {
                if (hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4TearDown = true;
            }
            if (name.toString().equals("record") && nonImportedNames.contains(name)) {
                if (hasSignatureDeclareThrowsException) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasSignatureDeclareThrowsException = true;
            }
        }
        if (hasSignatureDeclareThrowsException) {
            addViolation(this, node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(BlockStatement node, Object data) {
        List<MethodInvocation> methodInvocations = new ArrayList<>();
        walk(node.getStatements(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    methodInvocations.add((MethodInvocation) node);
                }
            }
        });
        if (methodInvocations.isEmpty()) {
            return super.visit(node, data);
        }
        List<Name> methodInvocationsNames = new ArrayList<>();
        walk(methodInvocations, new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof MethodInvocation) {
                    MethodInvocation methodInvocation = (MethodInvocation) node;
                    if (methodInvocation.getExpression() instanceof SimpleName) {
                        methodInvocationsNames.add((SimpleName) methodInvocation.getExpression());
                    }
                }
            }
        });
        Set<QualifiedName> importedNames = new HashSet<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof ImportDeclaration) {
                    ImportDeclaration importDeclaration = (ImportDeclaration) node;
                    for (QualifiedName name : importDeclaration.getQualifiedNames()) {
                        importedNames.add(name);
                    }
                }
            }
        });
        List<Name> allNames = new ArrayList<>();
        walk(node.getScope(), new Walker() {
            @Override
            public void walk(ASTNode node, Object data) {
                if (node instanceof SimpleName) {
                    allNames.add((SimpleName) node);
                }
            }
        });
        Set<QualifiedName> nonImportedNames = new HashSet<>();
        for (Name name : allNames) {
            if (!importedNames.contains(name.getQualifiedName())) {
                nonImportedNames.add(name.getQualifiedName());
            }
        }
        if (methodInvocationsNames.size() != nonImportedNames.size()) {
            return super.visit(node, data);
        }
        boolean hasJunit3Setup = false;
        boolean hasJunit3TearDown = false;
        boolean hasJunit4Setup = false;
        boolean hasJunit4TearDown = false;
        boolean hasSignatureDeclareThrowsException = false;
        for (int i = 0; i < methodInvocationsNames.size(); i++) {
            QualifiedName name = methodInvocationsNames.get(i);
            if (name.toString().equals("setUp") && nonImportedNames.contains(name)) {
                if (hasJunit3Setup || hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3Setup = true;
            }
            if (name.toString().equals("tearDown") && nonImportedNames.contains(name)) {
                if (hasJunit3TearDown || hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit3TearDown = true;
            }
            if (name.toString().equals("@Before") && nonImportedNames.contains(name)) {
                if (hasJunit4Setup) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4Setup = true;
            }
            if (name.toString().equals("@After") && nonImportedNames.contains(name)) {
                if (hasJunit4TearDown) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasJunit4TearDown = true;
            }
            if (name.toString().equals("record") && nonImportedNames.contains(name)) {
                if (hasSignatureDeclareThrowsException) {
                    hasSignatureDeclareThrowsException = true;
                    break;
                }
                hasSignatureDeclareThrowsException = true;
            }
        }
        if (hasSignatureDeclareThrowsException) {
            addViolation(this, node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(AmbientContext node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(Name node, Object data) {
        if (node.getQualifier() instanceof QualifiedName && ((QualifiedName) node.getQualifier()).toString().equals("Exception")) {
            addViolation(this, node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(PrimitiveType node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(QualifiedName node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(SimpleName node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(MethodInvocation node, Object data) {
        if (node.getExpression() instanceof SimpleName) {
            SimpleName name = (SimpleName) node.getExpression();
            if (name.getQualifier() instanceof QualifiedName && ((QualifiedName) name.getQualifier()).toString().equals("Exception")) {
                addViolation(this, node, data);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(Statement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ParameterDeclaration node, Object data) {
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: A method/constructor shouldn’t explicitly throw the generic java.lang.Exception.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// method throws Exception
public class Foo {
    void foo() throws Exception {}
}
```
2. This is a positive test case
```java
// ok
public class Foo {
    void foo() {}
}
```
3. This is a negative test case
```java
// constructor throws Exception
public class Foo {
    Foo() throws Exception {}
}
```
4. This is a positive test case
```java
// constructor throws IOException
import java.io.IOException;
            public class Foo {
                Foo() throws IOException { }
            }
```
5. This is a positive test case
```java
// method throws IOException
import java.io.IOException;
            public class Foo {
                void foo() throws IOException { }
            }
```
6. This is a positive test case
```java
// skip junit3 setUp method
import junit.framework.*;
public class Foo extends TestCase {
    void setUp() throws Exception {}
}
```
7. This is a positive test case
```java
// skip junit3 tearDown method
import junit.framework.*;
public class Foo extends TestCase {
    void tearDown() throws Exception {}
}
```
8. This is a positive test case
```java
// JUnit 4 testcase
import org.junit.*;
public class Foo {
    @Before
    void setUp() throws Exception {}
}
```
9. This is a negative test case
```java
// Don't skip other methods
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
10. This is a negative test case
```java
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
11. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase
public class Foo extends net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase {
    void setUp() throws Exception {}
}
```
12. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, imported explicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
13. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, but is imported implicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.*;
public class Foo extends MyTestCase {
 void setUp() throws Exception {}
}
```
14. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase  and is in the same package
package net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception;

public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
15. This is a positive test case
```java
// Generics
public class Foo {
    public <T> Bar<T> foo() { /* blah */}
}
class Bar<X> {}
```
16. This is a positive test case
```java
// skip any method starting with 'test' for junit3
import junit.framework.*;
public class FooTest extends TestCase {
    public void testFoo() throws Exception {}
}
```
17. This is a negative test case
```java
// #913 SignatureDeclareThrowsException is raised twice
import javax.swing.SwingWorker;
public class BugSignature {
  public void record() {
    SwingWorker worker = new SwingWorker() {
      protected String construct() throws Exception {
        //
      }
    };
  }
}
```
18. This is a positive test case
```java
// #1535 [java] SignatureDeclareThrowsException: ClassCastException with Annotation
import java.util.List;
public class UnmodifiableList<T> implements @Readonly List<@Readonly T> {}
@interface Readonly {}
```
19. This is a negative test case
```java
// #350 allow throws exception when overriding a method defined elsewhere
public class BugSignature implements LousyInterface {
    @Override
    public void record() throws Exception {
    }
}
interface LousyInterface {
    void record() throws Exception; // <-- this is reported
}
```
20. This is a negative test case
```java
import junit.framework.*;

public class JUnitAnnotationTest extends TestCase {
    public JUnitAnnotationTest() throws Exception {
    }
}
```
21. This is a positive test case
```java
// #1369 ClassCastException in annotated extends
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public final class Namespace {

    @Target(ElementType.TYPE_USE)
    public @interface Weird {
    }

    public class WeirdException extends @Weird Exception {
    }

}
```
22. This is a positive test case
```java
// #4477:[java] SignatureDeclareThrowsException: false-positive with TestNG annotations
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    @org.testng.annotations.AfterClass
    void setUp() throws Exception {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {

    public SignatureDeclareThrowsExceptionRule() {
        super(JavaNode.METHOD_DECLARATION, JavaNode.CONSTRUCTOR_DECLARATION, JavaNode.CLASS_OR_INTERFACE_DECLARATION);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (isSignature(node, JavaNode.METHOD_DECLARATION)) {
            if (TypeUtils.isRawType(node.getReturnType()) && node.getThrows().contains("java.lang.Exception")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorDeclaration node, Object data) {
        if (isSignature(node, JavaNode.CONSTRUCTOR_DECLARATION)) {
            if (TypeUtils.isRawType(node.getReturnType()) && node.getThrows().contains("java.lang.Exception")) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceDeclaration node, Object data) {
        if (isSignature(node, JavaNode.CLASS_OR_INTERFACE_DECLARATION)) {
            for (ASTMethodDeclaration method : node.getMethods()) {
                if (TypeUtils.isRawType(method.getReturnType()) && method.getThrows().contains("java.lang.Exception")) {
                    addViolation(data, method);
                }
            }
            for (ASTConstructorDeclaration constructor : node.getConstructors()) {
                if (TypeUtils.isRawType(constructor.getReturnType()) && constructor.getThrows().contains("java.lang.Exception")) {
                    addViolation(data, constructor);
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isSignature(JavaNode node, int type) {
        if (node instanceof ASTClassOrInterfaceDeclaration) {
            if (((ASTClassOrInterfaceDeclaration) node).isInterface()) {
                return false;
            }
        }
        if (node instanceof ASTMethodDeclaration) {
            if (((ASTMethodDeclaration) node).isStatic()) {
                return false;
            }
            if (((ASTMethodDeclaration) node).getDeclaredModifiers().contains(Modifier.ABSTRACT)) {
                return false;
            }
        }
        if (node instanceof ASTConstructorDeclaration) {
            if (((ASTConstructorDeclaration) node).isStatic()) {
                return false;
            }
        }
        if (node.getSuperClass() != null && node.getSuperClass().toString().startsWith("java.lang.")) {
            if (node.getSuperClass().toString().equals("java.lang.TestCase") && (node instanceof ASTMethodDeclaration || node instanceof ASTConstructorDeclaration)) {
                return false;
            }
        }
        if (node.getEnclosingScope() instanceof ASTImportDeclaration) {
            ASTImportDeclaration importDecl = (ASTImportDeclaration) node.getEnclosingScope();
            if (importDecl.toString().startsWith("junit.framework.") || importDecl.toString().startsWith("org.junit.")) {
                return false;
            }
        }
        return true;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: A method/constructor shouldn’t explicitly throw the generic java.lang.Exception.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// method throws Exception
public class Foo {
    void foo() throws Exception {}
}
```
2. This is a positive test case
```java
// ok
public class Foo {
    void foo() {}
}
```
3. This is a negative test case
```java
// constructor throws Exception
public class Foo {
    Foo() throws Exception {}
}
```
4. This is a positive test case
```java
// constructor throws IOException
import java.io.IOException;
            public class Foo {
                Foo() throws IOException { }
            }
```
5. This is a positive test case
```java
// method throws IOException
import java.io.IOException;
            public class Foo {
                void foo() throws IOException { }
            }
```
6. This is a positive test case
```java
// skip junit3 setUp method
import junit.framework.*;
public class Foo extends TestCase {
    void setUp() throws Exception {}
}
```
7. This is a positive test case
```java
// skip junit3 tearDown method
import junit.framework.*;
public class Foo extends TestCase {
    void tearDown() throws Exception {}
}
```
8. This is a positive test case
```java
// JUnit 4 testcase
import org.junit.*;
public class Foo {
    @Before
    void setUp() throws Exception {}
}
```
9. This is a negative test case
```java
// Don't skip other methods
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
10. This is a negative test case
```java
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
11. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase
public class Foo extends net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase {
    void setUp() throws Exception {}
}
```
12. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, imported explicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
13. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, but is imported implicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.*;
public class Foo extends MyTestCase {
 void setUp() throws Exception {}
}
```
14. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase  and is in the same package
package net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception;

public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
15. This is a positive test case
```java
// Generics
public class Foo {
    public <T> Bar<T> foo() { /* blah */}
}
class Bar<X> {}
```
16. This is a positive test case
```java
// skip any method starting with 'test' for junit3
import junit.framework.*;
public class FooTest extends TestCase {
    public void testFoo() throws Exception {}
}
```
17. This is a negative test case
```java
// #913 SignatureDeclareThrowsException is raised twice
import javax.swing.SwingWorker;
public class BugSignature {
  public void record() {
    SwingWorker worker = new SwingWorker() {
      protected String construct() throws Exception {
        //
      }
    };
  }
}
```
18. This is a positive test case
```java
// #1535 [java] SignatureDeclareThrowsException: ClassCastException with Annotation
import java.util.List;
public class UnmodifiableList<T> implements @Readonly List<@Readonly T> {}
@interface Readonly {}
```
19. This is a negative test case
```java
// #350 allow throws exception when overriding a method defined elsewhere
public class BugSignature implements LousyInterface {
    @Override
    public void record() throws Exception {
    }
}
interface LousyInterface {
    void record() throws Exception; // <-- this is reported
}
```
20. This is a negative test case
```java
import junit.framework.*;

public class JUnitAnnotationTest extends TestCase {
    public JUnitAnnotationTest() throws Exception {
    }
}
```
21. This is a positive test case
```java
// #1369 ClassCastException in annotated extends
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public final class Namespace {

    @Target(ElementType.TYPE_USE)
    public @interface Weird {
    }

    public class WeirdException extends @Weird Exception {
    }

}
```
22. This is a positive test case
```java
// #4477:[java] SignatureDeclareThrowsException: false-positive with TestNG annotations
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    @org.testng.annotations.AfterClass
    void setUp() throws Exception {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {

    public SignatureDeclareThrowsExceptionRule() {
        super(JavaNode.METHOD_DECLARATION, JavaNode.CONSTRUCTOR_DECLARATION);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (node.getThrowsClause() != null && node.getThrowsClause().getIdentifier() != null
                && node.getThrowsClause().getIdentifier().getImage().equals("java.lang.Exception")) {
            addViolation(data, createRuleViolation(node));
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorDeclaration node, Object data) {
        if (node.getThrowsClause() != null && node.getThrowsClause().getIdentifier() != null
                && node.getThrowsClause().getIdentifier().getImage().equals("java.lang.Exception")) {
            addViolation(data, createRuleViolation(node));
        }
        return super.visit(node, data);
    }

    private RuleViolation createRuleViolation(JavaNode node) {
        // Create a new rule violation
        return new RuleViolation(getName(), node, "Method/constructor should not explicitly throw java.lang.Exception.");
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: A method/constructor shouldn’t explicitly throw the generic java.lang.Exception.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// method throws Exception
public class Foo {
    void foo() throws Exception {}
}
```
2. This is a positive test case
```java
// ok
public class Foo {
    void foo() {}
}
```
3. This is a negative test case
```java
// constructor throws Exception
public class Foo {
    Foo() throws Exception {}
}
```
4. This is a positive test case
```java
// constructor throws IOException
import java.io.IOException;
            public class Foo {
                Foo() throws IOException { }
            }
```
5. This is a positive test case
```java
// method throws IOException
import java.io.IOException;
            public class Foo {
                void foo() throws IOException { }
            }
```
6. This is a positive test case
```java
// skip junit3 setUp method
import junit.framework.*;
public class Foo extends TestCase {
    void setUp() throws Exception {}
}
```
7. This is a positive test case
```java
// skip junit3 tearDown method
import junit.framework.*;
public class Foo extends TestCase {
    void tearDown() throws Exception {}
}
```
8. This is a positive test case
```java
// JUnit 4 testcase
import org.junit.*;
public class Foo {
    @Before
    void setUp() throws Exception {}
}
```
9. This is a negative test case
```java
// Don't skip other methods
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
10. This is a negative test case
```java
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
11. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase
public class Foo extends net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase {
    void setUp() throws Exception {}
}
```
12. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, imported explicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
13. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, but is imported implicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.*;
public class Foo extends MyTestCase {
 void setUp() throws Exception {}
}
```
14. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase  and is in the same package
package net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception;

public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
15. This is a positive test case
```java
// Generics
public class Foo {
    public <T> Bar<T> foo() { /* blah */}
}
class Bar<X> {}
```
16. This is a positive test case
```java
// skip any method starting with 'test' for junit3
import junit.framework.*;
public class FooTest extends TestCase {
    public void testFoo() throws Exception {}
}
```
17. This is a negative test case
```java
// #913 SignatureDeclareThrowsException is raised twice
import javax.swing.SwingWorker;
public class BugSignature {
  public void record() {
    SwingWorker worker = new SwingWorker() {
      protected String construct() throws Exception {
        //
      }
    };
  }
}
```
18. This is a positive test case
```java
// #1535 [java] SignatureDeclareThrowsException: ClassCastException with Annotation
import java.util.List;
public class UnmodifiableList<T> implements @Readonly List<@Readonly T> {}
@interface Readonly {}
```
19. This is a negative test case
```java
// #350 allow throws exception when overriding a method defined elsewhere
public class BugSignature implements LousyInterface {
    @Override
    public void record() throws Exception {
    }
}
interface LousyInterface {
    void record() throws Exception; // <-- this is reported
}
```
20. This is a negative test case
```java
import junit.framework.*;

public class JUnitAnnotationTest extends TestCase {
    public JUnitAnnotationTest() throws Exception {
    }
}
```
21. This is a positive test case
```java
// #1369 ClassCastException in annotated extends
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public final class Namespace {

    @Target(ElementType.TYPE_USE)
    public @interface Weird {
    }

    public class WeirdException extends @Weird Exception {
    }

}
```
22. This is a positive test case
```java
// #4477:[java] SignatureDeclareThrowsException: false-positive with TestNG annotations
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    @org.testng.annotations.AfterClass
    void setUp() throws Exception {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;

import java.util.List;
import java.util.Map;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {

    public SignatureDeclareThrowsExceptionRule() {
        addRuleMessage("A method/constructor shouldn't explicitly throw the generic java.lang.Exception.");
        addRulePriority(3);
        addRuleCategory(org.pmd.lang.java.rule.DesignRule.CATEGORY);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTModifier node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTNode node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTThrowStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(JNode node, Object data) {
        return super.visit(node, data);
    }

    private class SignatureDeclareThrowsExceptionVisitor extends DepthFirstVisitor {

        @Override
        public Object visit(ASTMethodDeclaration node, Object data) {
            List<ASTModifier> modifiers = node.getModifiers();
            boolean isJunitSetupMethod = isJunitSetupMethod(node, modifiers);
            if (isJunitSetupMethod && !isJunit4(node)) {
                return data;
            }
            JMethodDeclaration methodDeclaration = (JMethodDeclaration) node;
            if (methodDeclaration.isExceptionThrown() && !(isJunitSetupMethod || isJunit4(node))) {
                addRuleViolation(node, "A method/constructor shouldn't explicitly throw the generic java.lang.Exception.");
            }
            return super.visit(node, data);
        }

        private boolean isJunitSetupMethod(ASTMethodDeclaration node, List<ASTModifier> modifiers) {
            boolean isSetupMethod = false;
            if (modifiers != null) {
                for (ASTModifier modifier : modifiers) {
                    if (Modifier.isPublic(modifier.getKind()) && (Modifier.isStatic(modifier.getKind()) || node.getName().equals("setUp"))) {
                        isSetupMethod = true;
                        break;
                    }
                }
            }
            if (node.getName().equals("setUp")) {
                JNode parent = node.getParent();
                if (parent instanceof ASTClassOrInterfaceDeclaration) {
                    JClassOrInterfaceDeclaration classOrInterfaceDeclaration = (JClassOrInterfaceDeclaration) parent;
                    if (classOrInterfaceDeclaration.getQualifiedName().equals("junit.framework.TestCase")) {
                        isSetupMethod = true;
                    }
                }
            }
            return isSetupMethod;
        }

        private boolean isJunit4(ASTMethodDeclaration node) {
            JNode parent = node.getParent();
            if (parent instanceof ASTClassOrInterfaceDeclaration) {
                JClassOrInterfaceDeclaration classOrInterfaceDeclaration = (JClassOrInterfaceDeclaration) parent;
                if (classOrInterfaceDeclaration.getQualifiedName().equals("org.junit.Before") || classOrInterfaceDeclaration.getQualifiedName().equals("org.junit.Test") || classOrInterfaceDeclaration.getQualifiedName().equals("org.junit.After")) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public Object visit(JClassOrInterfaceBody node, Object data) {
            return super.visit(node, data);
        }

        @Override
        public Object visit(JConstructorDeclaration node, Object data) {
            return super.visit(node, data);
        }

        @Override
        public Object visit(JMethodDeclaration node, Object data) {
            return super.visit(node, data);
        }

        @Override
        public Object visit(JNode node, Object data) {
            return super.visit(node, data);
        }

        @Override
        public Object visit(JThrowStatement node, Object data) {
            return super.visit(node, data);
        }
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        Type type = TypeUtils.getAnnotatedType(node, java.lang.Exception.class);
        if (type != null) {
            addRuleViolation(node, "A method/constructor shouldn't explicitly throw the generic java.lang.Exception.");
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorDeclaration node, Object data) {
        Type type = TypeUtils.getAnnotatedType(node, java.lang.Exception.class);
        if (type != null) {
            addRuleViolation(node, "A method/constructor shouldn't explicitly throw the generic java.lang.Exception.");
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        Type type = TypeUtils.getAnnotatedType(node, java.lang.Exception.class);
        if (type != null) {
            addRuleViolation(node, "A method/constructor shouldn't explicitly throw the generic java.lang.Exception.");
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTNode node, Object data) {
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: A method/constructor shouldn’t explicitly throw the generic java.lang.Exception.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// method throws Exception
public class Foo {
    void foo() throws Exception {}
}
```
2. This is a positive test case
```java
// ok
public class Foo {
    void foo() {}
}
```
3. This is a negative test case
```java
// constructor throws Exception
public class Foo {
    Foo() throws Exception {}
}
```
4. This is a positive test case
```java
// constructor throws IOException
import java.io.IOException;
            public class Foo {
                Foo() throws IOException { }
            }
```
5. This is a positive test case
```java
// method throws IOException
import java.io.IOException;
            public class Foo {
                void foo() throws IOException { }
            }
```
6. This is a positive test case
```java
// skip junit3 setUp method
import junit.framework.*;
public class Foo extends TestCase {
    void setUp() throws Exception {}
}
```
7. This is a positive test case
```java
// skip junit3 tearDown method
import junit.framework.*;
public class Foo extends TestCase {
    void tearDown() throws Exception {}
}
```
8. This is a positive test case
```java
// JUnit 4 testcase
import org.junit.*;
public class Foo {
    @Before
    void setUp() throws Exception {}
}
```
9. This is a negative test case
```java
// Don't skip other methods
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
10. This is a negative test case
```java
import junit.framework.*;
public class Foo extends TestCase {
    void bar() throws Exception {}
}
```
11. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase
public class Foo extends net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase {
    void setUp() throws Exception {}
}
```
12. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, imported explicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
13. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase, but is imported implicitly
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.*;
public class Foo extends MyTestCase {
 void setUp() throws Exception {}
}
```
14. This is a positive test case
```java
// skip junit setUp method where the superclass is TestCase  and is in the same package
package net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception;

public class Foo extends MyTestCase {
    void setUp() throws Exception {}
}
```
15. This is a positive test case
```java
// Generics
public class Foo {
    public <T> Bar<T> foo() { /* blah */}
}
class Bar<X> {}
```
16. This is a positive test case
```java
// skip any method starting with 'test' for junit3
import junit.framework.*;
public class FooTest extends TestCase {
    public void testFoo() throws Exception {}
}
```
17. This is a negative test case
```java
// #913 SignatureDeclareThrowsException is raised twice
import javax.swing.SwingWorker;
public class BugSignature {
  public void record() {
    SwingWorker worker = new SwingWorker() {
      protected String construct() throws Exception {
        //
      }
    };
  }
}
```
18. This is a positive test case
```java
// #1535 [java] SignatureDeclareThrowsException: ClassCastException with Annotation
import java.util.List;
public class UnmodifiableList<T> implements @Readonly List<@Readonly T> {}
@interface Readonly {}
```
19. This is a negative test case
```java
// #350 allow throws exception when overriding a method defined elsewhere
public class BugSignature implements LousyInterface {
    @Override
    public void record() throws Exception {
    }
}
interface LousyInterface {
    void record() throws Exception; // <-- this is reported
}
```
20. This is a negative test case
```java
import junit.framework.*;

public class JUnitAnnotationTest extends TestCase {
    public JUnitAnnotationTest() throws Exception {
    }
}
```
21. This is a positive test case
```java
// #1369 ClassCastException in annotated extends
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public final class Namespace {

    @Target(ElementType.TYPE_USE)
    public @interface Weird {
    }

    public class WeirdException extends @Weird Exception {
    }

}
```
22. This is a positive test case
```java
// #4477:[java] SignatureDeclareThrowsException: false-positive with TestNG annotations
import net.sourceforge.pmd.lang.java.rule.design.signaturedeclarethrowsexception.MyTestCase;
public class Foo extends MyTestCase {
    @org.testng.annotations.AfterClass
    void setUp() throws Exception {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.design;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.design;


import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class SignatureDeclareThrowsExceptionRule extends AbstractJavaRulechainRule {

    private static final String EXCEPTION_TYPE = "java.lang.Exception";

    @Override
    public Object visit(ASTMethodDeclaration node, Object data) {
        if (!node.isConstructor()) {
            if (node.getThrows() != null) {
                for (ASTType throwsType : node.getThrows().getTypeList()) {
                    if (throwsType.toString().equals(EXCEPTION_TYPE)) {
                        addViolation(this, data, node);
                        return data;
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTConstructorDeclaration node, Object data) {
        if (node.getThrows() != null) {
            for (ASTType throwsType : node.getThrows().getTypeList()) {
                if (throwsType.toString().equals(EXCEPTION_TYPE)) {
                    addViolation(this, data, node);
                    return data;
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceBody node, Object data) {
        for (ASTClassOrInterfaceBodyDeclaration methodDeclaration : node.getMethods()) {
            if (methodDeclaration instanceof ASTClassOrInterfaceBodyDeclarationMethodDeclaration) {
                ASTClassOrInterfaceBodyDeclarationMethodDeclaration method = (ASTClassOrInterfaceBodyDeclarationMethodDeclaration) methodDeclaration;
                if (!method.isConstructor()) {
                    if (method.getThrows() != null) {
                        for (ASTType throwsType : method.getThrows().getTypeList()) {
                            if (throwsType.toString().equals(EXCEPTION_TYPE)) {
                                addViolation(this, data, method.getDeclaration());
                                return data;
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceType node, Object data) {
        ASTClassOrInterfaceBody body = node.getBody();
        if (body != null) {
            return visit(body, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTPrimaryExpression node, Object data) {
        if (node instanceof ASTIdentifier) {
            ASTIdentifier identifier = (ASTIdentifier) node;
            String name = identifier.getImage();
            if (name.equals("Exception")) {
                addViolation(this, data, node);
                return data;
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceTypeMemberReference node, Object data) {
        if (node.getType().getImage().equals(EXCEPTION_TYPE)) {
            addViolation(this, data, node);
            return data;
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ASTClassOrInterfaceTypeMethodReference node, Object data) {
        if (node.getType().getImage().equals(EXCEPTION_TYPE)) {
            addViolation(this, data, node);
            return data;
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 240.334326505661 秒
