开始

========================================== Rule LiteralsFirstInComparisonsRule ===========================================
一共 33 个测试用例
正例 22 个
反例 11 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
21. This is a negative test case
```java
// bad, testing false negative at the end of a chain
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
```
22. This is a positive test case
```java
// ok, should be ignored in case both operands are string literals
public class Foo {
    boolean isFoo;
    public void bar() {
        this.isFoo = "Hello".equals("World");
    }
}
```
23. This is a negative test case
```java
// Equals on method result with String argument
public class Foo {
    private String getStr(String a) {
        return "a" + a;
    }
    public void bar() {
        if (getStr("b").equals("ab")) { }   // nok
        if ("ab".equals(getStr("b"))) { }   // ok
    }
}
```
24. This is a negative test case
```java
// FN with unresolved types
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}
```
25. This is a negative test case
```java
// #575 LiteralsFirstInComparisons to consider constant fields, i.e. static final Strings
public class Foo {
    private static final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
26. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
27. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
28. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the constant field is not a String
public class Foo {
    private final Integer TEST_CONSTANT = 5;
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
29. This is a negative test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static final String T = "t";

                public static int convert(String type) {
                    if (type.equals(Q)) {
                        return 1;
                    } else if (type.equals(T)) {
                        return 2;
                    } else {
                        return 3;
                    }
                }
            }
```
30. This is a positive test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
```
31. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315
import net.sourceforge.pmd.PMDVersion;
public class LiteralsFirstInComparisonCase {
    private static final String S1 = "s1";
    private static final String S2 = "s2";
    public static boolean compare() {
        return S1.equals(S2);
    }
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
32. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315 - with on demand import
import net.sourceforge.pmd.*;
public class LiteralsFirstInComparisonCase {
    private static final String S2 = "s2";
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
33. This is a positive test case
```java
// False positive with non-String constants
import java.math.BigInteger;

public class LiteralsFirstInComparisonBigInteger {
    public void foo() {
        BigInteger value = new BigInteger("1");
        if (value.equals(BigInteger.ZERO)) {
            System.out.println("1==0!!");
        }
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
21. This is a negative test case
```java
// bad, testing false negative at the end of a chain
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
```
22. This is a positive test case
```java
// ok, should be ignored in case both operands are string literals
public class Foo {
    boolean isFoo;
    public void bar() {
        this.isFoo = "Hello".equals("World");
    }
}
```
23. This is a negative test case
```java
// Equals on method result with String argument
public class Foo {
    private String getStr(String a) {
        return "a" + a;
    }
    public void bar() {
        if (getStr("b").equals("ab")) { }   // nok
        if ("ab".equals(getStr("b"))) { }   // ok
    }
}
```
24. This is a negative test case
```java
// FN with unresolved types
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}
```
25. This is a negative test case
```java
// #575 LiteralsFirstInComparisons to consider constant fields, i.e. static final Strings
public class Foo {
    private static final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
26. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
27. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
28. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the constant field is not a String
public class Foo {
    private final Integer TEST_CONSTANT = 5;
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
29. This is a negative test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static final String T = "t";

                public static int convert(String type) {
                    if (type.equals(Q)) {
                        return 1;
                    } else if (type.equals(T)) {
                        return 2;
                    } else {
                        return 3;
                    }
                }
            }
```
30. This is a positive test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
```
31. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315
import net.sourceforge.pmd.PMDVersion;
public class LiteralsFirstInComparisonCase {
    private static final String S1 = "s1";
    private static final String S2 = "s2";
    public static boolean compare() {
        return S1.equals(S2);
    }
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
32. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315 - with on demand import
import net.sourceforge.pmd.*;
public class LiteralsFirstInComparisonCase {
    private static final String S2 = "s2";
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
33. This is a positive test case
```java
// False positive with non-String constants
import java.math.BigInteger;

public class LiteralsFirstInComparisonBigInteger {
    public void foo() {
        BigInteger value = new BigInteger("1");
        if (value.equals(BigInteger.ZERO)) {
            System.out.println("1==0!!");
        }
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public PositionLiteralsFirstInComparisonsRule() {
        super(MethodDeclaration.class);
    }

    @Override
    public Object visit(MethodDeclaration n, Object data) {
        if (n.getBody() != null && n.getBody().isPrimitive()) {
            ExpressionTreeVisitor visitor = new ExpressionTreeVisitor();
            JavaNode root = n.getBody();
            String test = visitor.findMethodCall(root);
            if (test != null) {
                List<MethodCall> calls = visitor.getMethodCalls(root);
                for (MethodCall call : calls) {
                    String name = call.getMethodName();
                    if (name.equals("equals") || name.equals("equalsIgnoreCase") || name.equals("compareTo") || name.equals("compareToIgnoreCase") || name.equals("contentEquals")) {
                        if (name.equals("equals")) {
                            ExpressionTreeVisitor equalsVisitor = new ExpressionTreeVisitor();
                            equalsVisitor.setMethodCall(call);
                            if (!equalsVisitor.isLiteralFirst(call)) {
                                addViolation(this, data, call);
                            }
                        } else if (name.equals("equalsIgnoreCase")) {
                            ExpressionTreeVisitor equalsVisitor = new ExpressionTreeVisitor();
                            equalsVisitor.setMethodCall(call);
                            if (!equalsVisitor.isLiteralFirst(call)) {
                                addViolation(this, data, call);
                            }
                        } else if (name.equals("compareTo")) {
                            ExpressionTreeVisitor compareToVisitor = new ExpressionTreeVisitor();
                            compareToVisitor.setMethodCall(call);
                            if (!compareToVisitor.isLiteralFirst(call)) {
                                addViolation(this, data, call);
                            }
                        } else if (name.equals("compareToIgnoreCase")) {
                            ExpressionTreeVisitor compareToVisitor = new ExpressionTreeVisitor();
                            compareToVisitor.setMethodCall(call);
                            if (!compareToVisitor.isLiteralFirst(call)) {
                                addViolation(this, data, call);
                            }
                        } else if (name.equals("contentEquals")) {
                            ExpressionTreeVisitor contentEqualsVisitor = new ExpressionTreeVisitor();
                            contentEqualsVisitor.setMethodCall(call);
                            if (!contentEqualsVisitor.isLiteralFirst(call)) {
                                addViolation(this, data, call);
                            }
                        }
                    }
                }
            }
        }
        return super.visit(n, data);
    }

    private class ExpressionTreeVisitor {
        private MethodCall methodCall;
        private List<MethodCall> methodCalls = new ArrayList<>();
        private boolean isLiteralFirst(MethodCall call) {
            ExpressionTreeVisitor visitor = new ExpressionTreeVisitor();
            visitor.setMethodCall(call);
            visitor.visit(call.getArguments().get(0));
            if (visitor.getMethodCalls().size() != 0) {
                return false;
            }
            if (call.getArguments().get(0) instanceof Literal) {
                return true;
            }
            return visitor.isLiteralFirst(call.getArguments().get(0));
        }

        public void setMethodCall(MethodCall call) {
            this.methodCall = call;
        }

        public MethodCall getMethodCall() {
            return methodCall;
        }

        public List<MethodCall> getMethodCalls() {
            return methodCalls;
        }

        public void visit(Expression n) {
            if (n instanceof MethodCall) {
                methodCalls.add((MethodCall) n);
            }

            for (Expression child : n.getChildren()) {
                visit(child);
            }
        }

        public String findMethodCall(JavaNode root) {
            if (root instanceof MethodCall) {
                return ((MethodCall) root).getMethodName();
            }
            for (Expression child : root.getChildren()) {
                String result = findMethodCall(child);
                if (result != null) {
                    return result;
                }
            }
            return null;
        }
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
21. This is a negative test case
```java
// bad, testing false negative at the end of a chain
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
```
22. This is a positive test case
```java
// ok, should be ignored in case both operands are string literals
public class Foo {
    boolean isFoo;
    public void bar() {
        this.isFoo = "Hello".equals("World");
    }
}
```
23. This is a negative test case
```java
// Equals on method result with String argument
public class Foo {
    private String getStr(String a) {
        return "a" + a;
    }
    public void bar() {
        if (getStr("b").equals("ab")) { }   // nok
        if ("ab".equals(getStr("b"))) { }   // ok
    }
}
```
24. This is a negative test case
```java
// FN with unresolved types
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}
```
25. This is a negative test case
```java
// #575 LiteralsFirstInComparisons to consider constant fields, i.e. static final Strings
public class Foo {
    private static final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
26. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
27. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
28. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the constant field is not a String
public class Foo {
    private final Integer TEST_CONSTANT = 5;
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
29. This is a negative test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static final String T = "t";

                public static int convert(String type) {
                    if (type.equals(Q)) {
                        return 1;
                    } else if (type.equals(T)) {
                        return 2;
                    } else {
                        return 3;
                    }
                }
            }
```
30. This is a positive test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
```
31. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315
import net.sourceforge.pmd.PMDVersion;
public class LiteralsFirstInComparisonCase {
    private static final String S1 = "s1";
    private static final String S2 = "s2";
    public static boolean compare() {
        return S1.equals(S2);
    }
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
32. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315 - with on demand import
import net.sourceforge.pmd.*;
public class LiteralsFirstInComparisonCase {
    private static final String S2 = "s2";
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
33. This is a positive test case
```java
// False positive with non-String constants
import java.math.BigInteger;

public class LiteralsFirstInComparisonBigInteger {
    public void foo() {
        BigInteger value = new BigInteger("1");
        if (value.equals(BigInteger.ZERO)) {
            System.out.println("1==0!!");
        }
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public LiteralsFirstInComparisonsRule() {
        addRuleChainVisitor(this, MethodDeclaration.class, Identifier.class, Expression.class, InvocationExpression.class);
        addRuleChainVisitor(this, MethodDeclaration.class, Identifier.class, Expression.class, MethodInvocation.class);
        addRuleChainVisitor(this, MethodDeclaration.class, Identifier.class, Expression.class, CompoundAssignment.class);
        addRuleChainVisitor(this, MethodDeclaration.class, Identifier.class, Expression.class, Assignment.class);
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(MethodInvocation node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        List<ASTNode> operands = node.getOperands();
        if (operands != null && operands.size() > 1 && operands.get(0) instanceof Identifier && operands.get(1) instanceof Expression) {
            Expression expression = (Expression) operands.get(1);
            if (expression instanceof InstanceofExpression || expression instanceof PostfixExpression || expression instanceof PrefixExpression || expression instanceof UnaryExpression || expression instanceof CastExpression || expression instanceof MethodInvocation || expression instanceof MethodReferenceExpression) {
                return null;
            }
            if (expression instanceof BinaryExpression) {
                BinaryExpression binaryExpression = (BinaryExpression) expression;
                if (binaryExpression.getLeftOperand() instanceof Literal && binaryExpression.getRightOperand() instanceof Identifier) {
                    return null;
                }
                if (binaryExpression.getLeftOperand() instanceof Identifier && binaryExpression.getRightOperand() instanceof Literal) {
                    addViolation(data, node);
                }
            }
            if (expression instanceof InvocationExpression) {
                InvocationExpression invocationExpression = (InvocationExpression) expression;
                if (invocationExpression.getArgumentList() != null && invocationExpression.getArgumentList(). getArguments() != null && invocationExpression.getArgumentList().getArguments().size() > 0 && invocationExpression.getArgumentList().getArguments().get(0) instanceof Identifier) {
                    return null;
                }
                if (invocationExpression.getExpression() instanceof Literal && invocationExpression.getMethodName() instanceof Identifier) {
                    return null;
                }
                if (invocationExpression.getExpression() instanceof Identifier && invocationExpression.getMethodName() instanceof Literal) {
                    addViolation(data, node);
                }
            }
        }
        return result;
    }

    @Override
    public Object visit(MethodReferenceExpression node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getArgumentList() != null && node.getArgumentList().getArguments() != null && node.getArgumentList().getArguments().size() > 0) {
            Expression expression = node.getArgumentList().getArguments().get(0);
            if (expression instanceof Identifier) {
                return null;
            }
            if (expression instanceof Literal) {
                return null;
            }
            if (expression instanceof InstanceofExpression || expression instanceof PostfixExpression || expression instanceof PrefixExpression || expression instanceof UnaryExpression || expression instanceof CastExpression || expression instanceof MethodInvocation) {
                return null;
            }
            if (expression instanceof BinaryExpression) {
                BinaryExpression binaryExpression = (BinaryExpression) expression;
                if (binaryExpression.getLeftOperand() instanceof Literal && binaryExpression.getRightOperand() instanceof Identifier) {
                    return null;
                }
                if (binaryExpression.getLeftOperand() instanceof Identifier && binaryExpression.getRightOperand() instanceof Literal) {
                    addViolation(data, node);
                }
            }
        }
        return result;
    }

    @Override
    public Object visit(Assignment node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getLeftHandSide() instanceof Identifier && node.getRightHandSide() instanceof InvocationExpression) {
            InvocationExpression invocationExpression = (InvocationExpression) node.getRightHandSide();
            if (invocationExpression.getArgumentList() != null && invocationExpression.getArgumentList().getArguments() != null && invocationExpression.getArgumentList().getArguments().size() > 0 && invocationExpression.getArgumentList().getArguments().get(0) instanceof Identifier) {
                return null;
            }
            if (invocationExpression.getExpression() instanceof Literal && invocationExpression.getMethodName() instanceof Identifier) {
                return null;
            }
            if (invocationExpression.getExpression() instanceof Identifier && invocationExpression.getMethodName() instanceof Literal) {
                addViolation(data, node);
            }
        }
        return result;
    }

    @Override
    public Object visit(CompoundAssignment node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getLeftHandSide() instanceof Identifier && node.getRightHandSide() instanceof InvocationExpression) {
            InvocationExpression invocationExpression = (InvocationExpression) node.getRightHandSide();
            if (invocationExpression.getArgumentList() != null && invocationExpression.getArgumentList().getArguments() != null && invocationExpression.getArgumentList().getArguments().size() > 0 && invocationExpression.getArgumentList().getArguments().get(0) instanceof Identifier) {
                return null;
            }
            if (invocationExpression.getExpression() instanceof Literal && invocationExpression.getMethodName() instanceof Identifier) {
                return null;
            }
            if (invocationExpression.getExpression() instanceof Identifier && invocationExpression.getMethodName() instanceof Literal) {
                addViolation(data, node);
            }
        }
        return result;
    }

    @Override
    public Object visit(InstanceofExpression node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getRightOperand() instanceof Literal) {
            return null;
        }
        if (node.getRightOperand() instanceof Identifier) {
            return null;
        }
        if (node.getRightOperand() instanceof InstanceofExpression || node.getRightOperand() instanceof PostfixExpression || node.getRightOperand() instanceof PrefixExpression || node.getRightOperand() instanceof UnaryExpression || node.getRightOperand() instanceof CastExpression || node.getRightOperand() instanceof MethodInvocation || node.getRightOperand() instanceof MethodReferenceExpression) {
            return null;
        }
        if (node.getRightOperand() instanceof BinaryExpression) {
            BinaryExpression binaryExpression = (BinaryExpression) node.getRightOperand();
            if (binaryExpression.getLeftOperand() instanceof Literal && binaryExpression.getRightOperand() instanceof Identifier) {
                return null;
            }
            if (binaryExpression.getLeftOperand() instanceof Identifier && binaryExpression.getRightOperand() instanceof Literal) {
                addViolation(data, node);
            }
        }
        return result;
    }

    @Override
    public Object visit(PostfixExpression node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getOperand() instanceof Literal) {
            return null;
        }
        if (node.getOperand() instanceof Identifier) {
            return null;
        }
        if (node.getOperand() instanceof InstanceofExpression || node.getOperand() instanceof PostfixExpression || node.getOperand() instanceof PrefixExpression || node.getOperand() instanceof UnaryExpression || node.getOperand() instanceof CastExpression || node.getOperand() instanceof MethodInvocation || node.getOperand() instanceof MethodReferenceExpression) {
            return null;
        }
        if (node.getOperand() instanceof BinaryExpression) {
            BinaryExpression binaryExpression = (BinaryExpression) node.getOperand();
            if (binaryExpression.getLeftOperand() instanceof Literal && binaryExpression.getRightOperand() instanceof Identifier) {
                return null;
            }
            if (binaryExpression.getLeftOperand() instanceof Identifier && binaryExpression.getRightOperand() instanceof Literal) {
                addViolation(data, node);
            }
        }
        return result;
    }

    @Override
    public Object visit(PrefixExpression node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getOperand() instanceof Literal) {
            return null;
        }
        if (node.getOperand() instanceof Identifier) {
            return null;
        }
        if (node.getOperand() instanceof InstanceofExpression || node.getOperand() instanceof PostfixExpression || node.getOperand() instanceof PrefixExpression || node.getOperand() instanceof UnaryExpression || node.getOperand() instanceof CastExpression || node.getOperand() instanceof MethodInvocation || node.getOperand() instanceof MethodReferenceExpression) {
            return null;
        }
        if (node.getOperand() instanceof BinaryExpression) {
            BinaryExpression binaryExpression = (BinaryExpression) node.getOperand();
            if (binaryExpression.getLeftOperand() instanceof Literal && binaryExpression.getRightOperand() instanceof Identifier) {
                return null;
            }
            if (binaryExpression.getLeftOperand() instanceof Identifier && binaryExpression.getRightOperand() instanceof Literal) {
                addViolation(data, node);
            }
        }
        return result;
    }

    @Override
    public Object visit(UnaryExpression node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getOperand() instanceof Literal) {
            return null;
        }
        if (node.getOperand() instanceof Identifier) {
            return null;
        }
        if (node.getOperand() instanceof InstanceofExpression || node.getOperand() instanceof PostfixExpression || node.getOperand() instanceof PrefixExpression || node.getOperand() instanceof UnaryExpression || node.getOperand() instanceof CastExpression || node.getOperand() instanceof MethodInvocation || node.getOperand() instanceof MethodReferenceExpression) {
            return null;
        }
        if (node.getOperand() instanceof BinaryExpression) {
            BinaryExpression binaryExpression = (BinaryExpression) node.getOperand();
            if (binaryExpression.getLeftOperand() instanceof Literal && binaryExpression.getRightOperand() instanceof Identifier) {
                return null;
            }
            if (binaryExpression.getLeftOperand() instanceof Identifier && binaryExpression.getRightOperand() instanceof Literal) {
                addViolation(data, node);
            }
        }
        return result;
    }

    @Override
    public Object visit(CastExpression node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getExpression() instanceof Literal) {
            return null;
        }
        if (node.getExpression() instanceof Identifier) {
            return null;
        }
        if (node.getExpression() instanceof InstanceofExpression || node.getExpression() instanceof PostfixExpression || node.getExpression() instanceof PrefixExpression || node.getExpression() instanceof UnaryExpression || node.getExpression() instanceof CastExpression || node.getExpression() instanceof MethodInvocation || node.getExpression() instanceof MethodReferenceExpression) {
            return null;
        }
        if (node.getExpression() instanceof BinaryExpression) {
            BinaryExpression binaryExpression = (BinaryExpression) node.getExpression();
            if (binaryExpression.getLeftOperand() instanceof Literal && binaryExpression.getRightOperand() instanceof Identifier) {
                return null;
            }
            if (binaryExpression.getLeftOperand() instanceof Identifier && binaryExpression.getRightOperand() instanceof Literal) {
                addViolation(data, node);
            }
        }
        return result;
    }

    @Override
    public Object visit(BinaryExpression node, Object data) {
        Object result = super.visit(node, data);
        if (result != null) {
            return result;
        }
        if (node.getLeftOperand() instanceof Literal && node.getRightOperand() instanceof Identifier) {
            return null;
        }
        if (node.getLeftOperand() instanceof Identifier && node.getRightOperand() instanceof Literal) {
            addViolation(data, node);
        }
        return result;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
21. This is a negative test case
```java
// bad, testing false negative at the end of a chain
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
```
22. This is a positive test case
```java
// ok, should be ignored in case both operands are string literals
public class Foo {
    boolean isFoo;
    public void bar() {
        this.isFoo = "Hello".equals("World");
    }
}
```
23. This is a negative test case
```java
// Equals on method result with String argument
public class Foo {
    private String getStr(String a) {
        return "a" + a;
    }
    public void bar() {
        if (getStr("b").equals("ab")) { }   // nok
        if ("ab".equals(getStr("b"))) { }   // ok
    }
}
```
24. This is a negative test case
```java
// FN with unresolved types
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}
```
25. This is a negative test case
```java
// #575 LiteralsFirstInComparisons to consider constant fields, i.e. static final Strings
public class Foo {
    private static final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
26. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
27. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
28. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the constant field is not a String
public class Foo {
    private final Integer TEST_CONSTANT = 5;
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
29. This is a negative test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static final String T = "t";

                public static int convert(String type) {
                    if (type.equals(Q)) {
                        return 1;
                    } else if (type.equals(T)) {
                        return 2;
                    } else {
                        return 3;
                    }
                }
            }
```
30. This is a positive test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
```
31. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315
import net.sourceforge.pmd.PMDVersion;
public class LiteralsFirstInComparisonCase {
    private static final String S1 = "s1";
    private static final String S2 = "s2";
    public static boolean compare() {
        return S1.equals(S2);
    }
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
32. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315 - with on demand import
import net.sourceforge.pmd.*;
public class LiteralsFirstInComparisonCase {
    private static final String S2 = "s2";
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
33. This is a positive test case
```java
// False positive with non-String constants
import java.math.BigInteger;

public class LiteralsFirstInComparisonBigInteger {
    public void foo() {
        BigInteger value = new BigInteger("1");
        if (value.equals(BigInteger.ZERO)) {
            System.out.println("1==0!!");
        }
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;

import java.util.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    @Override
    public Object visit(MethodCallExpr node, Object data) {
        if (node.getImage().equals("equals") || node.getImage().equals("equalsIgnoreCase") || node.getImage().equals("compareTo") || node.getImage().equals("compareToIgnoreCase") || node.getImage().equals("contentEquals")) {
            Object arg = node.getFirstChildByType(MethodCallExpr.class).getFirstChildByType(Assignee.class).getFirstChildByType(Identifier.class);
            if (arg != null && arg.getClass().equals(MetaIdentity.class)) {
                return super.visit(node, data);
            }
            Object target = node.getFirstChildByType(MethodCallExpr.class).getParentByType(MethodCallExpr.class);
            if (target != null && target.getClass().equals(MethodCallExpr.class) && target.getImage().equals("equals") || target.getImage().equals("equalsIgnoreCase")) {
                Object targetArg = target.getFirstChildByType(MethodCallExpr.class).getFirstChildByType(Assignee.class).getFirstChildByType(Identifier.class);
                if (targetArg != null && targetArg.getClass().equals(MetaIdentity.class)) {
                    return super.visit(node, data);
                }
            }
            if (arg != null && arg.getClass().equals(Identifier.class) && ((Identifier) arg).getImage().startsWith("get") && ((Identifier) arg).getImage().endsWith("String") && ((Identifier) arg).getImage().contains("(") && ((Identifier) arg).getImage().contains(")")) {
                if (target == null) {
                    return super.visit(node, data);
                }
            }
            if (target != null && target.getClass().equals(MethodCallExpr.class) && target.getImage().equals("compareTo") || target.getImage().equals("compareToIgnoreCase")) {
                Object targetArg = target.getFirstChildByType(MethodCallExpr.class).getFirstChildByType(Assignee.class).getFirstChildByType(Identifier.class);
                if (targetArg != null && targetArg.getClass().equals(MetaIdentity.class)) {
                    return super.visit(node, data);
                }
            }
            if (target != null && target.getClass().equals(MethodCallExpr.class) && target.getImage().equals("contentEquals")) {
                Object targetArg = target.getFirstChildByType(MethodCallExpr.class).getFirstChildByType(Assignee.class).getFirstChildByType(Identifier.class);
                if (targetArg != null && targetArg.getClass().equals(MetaIdentity.class)) {
                    return super.visit(node, data);
                }
            }
            if (target == null || target.getClass().equals(MetaIdentity.class)) {
                addViolation(data, node);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(MethodCallExpr node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(Identifier node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        String methodName = node.getImage();
        if (methodName.equals("equals") || methodName.equals("equalsIgnoreCase") || methodName.equals("compareTo") || methodName.equals("compareToIgnoreCase") || methodName.equals("contentEquals")) {
            for (Object child : node.getChildren()) {
                MethodCallExpr methodCall = (MethodCallExpr) child;
                Object arg = methodCall.getFirstChildByType(MethodCallExpr.class).getFirstChildByType(Assignee.class).getFirstChildByType(Identifier.class);
                if (arg != null && arg.getClass().equals(Identifier.class) && ((Identifier) arg).getImage().startsWith("get") && ((Identifier) arg).getImage().endsWith("String") && ((Identifier) arg).getImage().contains("(") && ((Identifier) arg).getImage().contains(")")) {
                    addViolation(data, methodCall);
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ClassOrInterfaceDeclaration node, Object data) {
        for (Object field : node.getFields()) {
            FieldDeclaration fieldDecl = (FieldDeclaration) field;
            if (fieldDecl.getType().getImage().equals("String") && fieldDecl.getImage().equals("TEST_CONSTANT") && !((FieldAccessExpr) fieldDecl.getModifiers()).getImage().equals("final") && !((FieldAccessExpr) fieldDecl.getModifiers()).getImage().equals("static")) {
                addViolation(data, fieldDecl);
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
21. This is a negative test case
```java
// bad, testing false negative at the end of a chain
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
```
22. This is a positive test case
```java
// ok, should be ignored in case both operands are string literals
public class Foo {
    boolean isFoo;
    public void bar() {
        this.isFoo = "Hello".equals("World");
    }
}
```
23. This is a negative test case
```java
// Equals on method result with String argument
public class Foo {
    private String getStr(String a) {
        return "a" + a;
    }
    public void bar() {
        if (getStr("b").equals("ab")) { }   // nok
        if ("ab".equals(getStr("b"))) { }   // ok
    }
}
```
24. This is a negative test case
```java
// FN with unresolved types
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}
```
25. This is a negative test case
```java
// #575 LiteralsFirstInComparisons to consider constant fields, i.e. static final Strings
public class Foo {
    private static final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
26. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
27. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
28. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the constant field is not a String
public class Foo {
    private final Integer TEST_CONSTANT = 5;
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
29. This is a negative test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static final String T = "t";

                public static int convert(String type) {
                    if (type.equals(Q)) {
                        return 1;
                    } else if (type.equals(T)) {
                        return 2;
                    } else {
                        return 3;
                    }
                }
            }
```
30. This is a positive test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
```
31. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315
import net.sourceforge.pmd.PMDVersion;
public class LiteralsFirstInComparisonCase {
    private static final String S1 = "s1";
    private static final String S2 = "s2";
    public static boolean compare() {
        return S1.equals(S2);
    }
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
32. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315 - with on demand import
import net.sourceforge.pmd.*;
public class LiteralsFirstInComparisonCase {
    private static final String S2 = "s2";
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
33. This is a positive test case
```java
// False positive with non-String constants
import java.math.BigInteger;

public class LiteralsFirstInComparisonBigInteger {
    public void foo() {
        BigInteger value = new BigInteger("1");
        if (value.equals(BigInteger.ZERO)) {
            System.out.println("1==0!!");
        }
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.bestpractices;

import java.util.*;
import java.lang.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {

    public PositionLiteralsFirstInComparisonsRule() {
        super(MethodDeclaration.class);
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        if (node.isStatic() || node.isPrivate() || node.isProtected() || node.isFinal()) {
            return super.visit(node, data);
        }

        if (node.getName().equals("equals") || node.getName().equals("equalsIgnoreCase") || node.getName().equals("compareTo") || node.getName().equals("compareToIgnoreCase") || node.getName().equals("contentEquals")) {
            for (ExpressionStatement statement : node.getBody().getStatements()) {
                if (statement.getExpression() instanceof MethodCallExpression) {
                    MethodCallExpression methodCall = (MethodCallExpression) statement.getExpression();
                    if (methodCall.getMethodName().equals("equals") || methodCall.getMethodName().equals("equalsIgnoreCase") || methodCall.getMethodName().equals("compareTo") || methodCall.getMethodName().equals("compareToIgnoreCase") || methodCall.getMethodName().equals("contentEquals")) {
                        Expression arg = methodCall.getArgument(0);
                        if (arg instanceof ConstantExpression) {
                            ConstantExpression constant = (ConstantExpression) arg;
                            String literal = constant.getImage();
                            if (isLiteralString(literal)) {
                                Expression arg2 = methodCall.getArgument(1);
                                if (arg2 instanceof VariableNameExpression) {
                                    VariableNameExpression variable = (VariableNameExpression) arg2;
                                    if (variable.getName().equals(node.getName())) {
                                        addViolation(data, node, "Position literals first in " + methodCall.getMethodName() + " comparison");
                                    }
                                }
                            }
                        } else if (arg instanceof MethodCallExpression) {
                            MethodCallExpression methodCall2 = (MethodCallExpression) arg;
                            String methodName = methodCall2.getMethodName();
                            if (methodName.equals("get") && methodCall2.getArgument(0) instanceof VariableNameExpression) {
                                VariableNameExpression variable = (VariableNameExpression) methodCall2.getArgument(0);
                                if (variable.getName().equals(node.getName())) {
                                    Expression arg3 = methodCall2.getArgument(1);
                                    if (arg3 instanceof ConstantExpression) {
                                        ConstantExpression constant = (ConstantExpression) arg3;
                                        String literal = constant.getImage();
                                        if (isLiteralString(literal)) {
                                            addViolation(data, node, "Position literals first in " + methodCall.getMethodName() + " comparison");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private boolean isLiteralString(String literal) {
        return (literal != null && !literal.isEmpty() && Character.isLetter(literal.charAt(0)) && Character.isLowerCase(literal.charAt(0)));
    }

    @Override
    public Object visit(VariableDeclarator node, Object data) {
        if (node.getType().getName().equals("String")) {
            if (node.getInitializer() instanceof ConstantExpression) {
                ConstantExpression constant = (ConstantExpression) node.getInitializer();
                String literal = constant.getImage();
                if (isLiteralString(literal)) {
                    addViolation(data, node, "Position literals first in comparison");
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(FieldAccessExpression node, Object data) {
        if (node.getType().getName().equals("String")) {
            if (node.getMember() instanceof VariableNameExpression) {
                VariableNameExpression variable = (VariableNameExpression) node.getMember();
                if (variable.getName().equals("TEST_CONSTANT") && node.getScope() instanceof FieldDeclaration) {
                    FieldDeclaration fieldDeclaration = (FieldDeclaration) node.getScope();
                    if (!fieldDeclaration.isFinal() || !fieldDeclaration.isStatic()) {
                        return super.visit(node, data);
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(Identifier node, Object data) {
        if (node.getName().equals("Q") || node.getName().equals("T")) {
            return super.visit(node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        if (node.getName().equals("equals") || node.getName().equals("equalsIgnoreCase") || node.getName().equals("compareTo") || node.getName().equals("compareToIgnoreCase") || node.getName().equals("contentEquals")) {
            for (ExpressionStatement statement : node.getBody().getStatements()) {
                if (statement.getExpression() instanceof MethodCallExpression) {
                    MethodCallExpression methodCall = (MethodCallExpression) statement.getExpression();
                    if (methodCall.getMethodName().equals("equals") || methodCall.getMethodName().equals("equalsIgnoreCase") || methodCall.getMethodName().equals("compareTo") || methodCall.getMethodName().equals("compareToIgnoreCase") || methodCall.getMethodName().equals("contentEquals")) {
                        Expression arg = methodCall.getArgument(0);
                        if (arg instanceof ConstantExpression) {
                            ConstantExpression constant = (ConstantExpression) arg;
                            String literal = constant.getImage();
                            if (isLiteralString(literal)) {
                                Expression arg2 = methodCall.getArgument(1);
                                if (arg2 instanceof VariableNameExpression) {
                                    VariableNameExpression variable = (VariableNameExpression) arg2;
                                    if (variable.getName().equals(node.getName())) {
                                        addViolation(data, node, "Position literals first in " + methodCall.getMethodName() + " comparison");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(AnonymousClassDeclaration node, Object data) {
        for (MethodDeclaration method : node.getMethods()) {
            if (method.getName().equals("equals") || method.getName().equals("equalsIgnoreCase") || method.getName().equals("compareTo") || method.getName().equals("compareToIgnoreCase") || method.getName().equals("contentEquals")) {
                for (ExpressionStatement statement : method.getBody().getStatements()) {
                    if (statement.getExpression() instanceof MethodCallExpression) {
                        MethodCallExpression methodCall = (MethodCallExpression) statement.getExpression();
                        if (methodCall.getMethodName().equals("equals") || methodCall.getMethodName().equals("equalsIgnoreCase") || methodCall.getMethodName().equals("compareTo") || methodCall.getMethodName().equals("compareToIgnoreCase") || methodCall.getMethodName().equals("contentEquals")) {
                            Expression arg = methodCall.getArgument(0);
                            if (arg instanceof ConstantExpression) {
                                ConstantExpression constant = (ConstantExpression) arg;
                                String literal = constant.getImage();
                                if (isLiteralString(literal)) {
                                    Expression arg2 = methodCall.getArgument(1);
                                    if (arg2 instanceof VariableNameExpression) {
                                        VariableNameExpression variable = (VariableNameExpression) arg2;
                                        if (variable.getName().equals(method.getName())) {
                                            addViolation(data, method, "Position literals first in " + methodCall.getMethodName() + " comparison");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Position literals first in all String comparison methods: non-overloaded 'boolean equals(Object o)' and 'equalsIgnoreCase' and 'compareTo' and 'compareToIgnoreCase' and 'contentEquals', if the second argument is null then NullPointerExceptions can be avoided, they will just return false.;

The following are the test cases of the rule:
1. This is a positive test case
```java
// ok, literal comes first in .equals comparison
public class Foo {
    boolean bar(String x) {
        return "2".equals(x);
    }
}
```
2. This is a negative test case
```java
// bad, literal comes last in .equals comparison
public class Foo {
    boolean bar(String x) {
        return x.equals("2");
    }
}
```
3. This is a negative test case
```java
// ok, empty literal in .equals comparison
public class Foo {
    void bar(String str) {
        if ((str == null) || (str.equals(""))) {
            str = "snafu";
        }
        if (str == null || str.equals("")) {
            str = "snafu";
        }
        if ((str != null) && (str.equals(""))) {
            str = "snafu";
        }
        if (str != null && str.equals("")) {
            str = "snafu";
        }
    }
}
```
4. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug(Number number)
    {
        if (number.equals(new BigDecimal("123"))) {}
    }
}
```
5. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equals false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (str.equals(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
6. This is a positive test case
```java
// #1256 PositionLiteralsFirstInComparisons .equals false positive with Characters
public class LiteralTest {
    protected final boolean check;
    public LiteralTest(Character c) {
        check = c.equals('x');
    }
}
```
7. This is a positive test case
```java
// ok, literal comes first in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".equalsIgnoreCase(x);
    }
}
```
8. This is a negative test case
```java
// bad, literal comes last in .equalsIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.equalsIgnoreCase("2");
    }
}
```
9. This is a positive test case
```java
// ok, testing .equalsIgnoreCase false positive
public class Foo {
    void bar() {
        if ((str == null) || (equalsIgnoreCase(""))) {
            str = "snafu";
        }
    }
}
```
10. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
import java.math.BigDecimal;
public class Foo
{
    public void bug()
    {
        if (equalsIgnoreCase(new BigDecimal("123"))) {}
    }
}
```
11. This is a positive test case
```java
// Test case from bug [1472195] - PositionLiteralsFirstInComparisons gives many .equalsIgnoreCase false positives
public class Foo
{
    public void testMethod(String str)
    {
        if (equalsIgnoreCase(getAnotherString("abc"))){}
    }

    private String getAnotherString(String str)
    {
        return "xyz";
    }
}
```
12. This is a positive test case
```java
// ok, literal comes first in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareTo(x) < 0;
    }
}
```
13. This is a negative test case
```java
// bad, literal comes last in .compareTo comparison
public class Foo {
    boolean bar(String x) {
        return x.compareTo("2") > 0;
    }
}
```
14. This is a positive test case
```java
// ok, testing for .compareTo false positive
public class Foo {
    boolean bar() {
        return compareTo("randomStringArg");
    }
}
```
15. This is a positive test case
```java
// ok, literal comes first in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return "2".compareToIgnoreCase(x) < 0;
    }
}
```
16. This is a negative test case
```java
// bad, literal comes last in .compareToIgnoreCase comparison
public class Foo {
    boolean bar(String x) {
        return x.compareToIgnoreCase("2") > 0;
    }
}
```
17. This is a positive test case
```java
// ok, testing ,compareToIgnoreCase false positive
public class Foo {
    String bar() {
        return compareToIgnoreCase("randomStringArg");
    }
}
```
18. This is a positive test case
```java
// ok, literal comes first in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return "2".contentEquals(x);
    }
}
```
19. This is a negative test case
```java
// bad, literal comes last in .contentEquals comparison
public class Foo {
    boolean bar(String x) {
        return x.contentEquals("2");
    }
}
```
20. This is a positive test case
```java
// ok, testing .contentEquals false positive
public class Foo {
    boolean bar(String x) {
        return contentEquals("2");
    }
}
```
21. This is a negative test case
```java
// bad, testing false negative at the end of a chain
import java.io.File;
public class Foo {
    public boolean bar() {
        File f;
        return f.getParent().equals("testStr");
    }
}
```
22. This is a positive test case
```java
// ok, should be ignored in case both operands are string literals
public class Foo {
    boolean isFoo;
    public void bar() {
        this.isFoo = "Hello".equals("World");
    }
}
```
23. This is a negative test case
```java
// Equals on method result with String argument
public class Foo {
    private String getStr(String a) {
        return "a" + a;
    }
    public void bar() {
        if (getStr("b").equals("ab")) { }   // nok
        if ("ab".equals(getStr("b"))) { }   // ok
    }
}
```
24. This is a negative test case
```java
// FN with unresolved types
import java.util.Map;
import my.Unknown;
class Foo {
    public void testObjectArray(Unknown uk) {
        Unknown hasMap = (Unknown) this.beanFactory.getBean("literalMap");
        assertTrue(hasMap.getMap().size() == 3);
        assertTrue(hasMap.getMap().get("foo").equals("bar"));
        assertTrue(hasMap.getMap().get("fi").equals("fum"));
        assertTrue(hasMap.getMap().get("fa") == null);
    }
}
```
25. This is a negative test case
```java
// #575 LiteralsFirstInComparisons to consider constant fields, i.e. static final Strings
public class Foo {
    private static final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
26. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not final
public class Foo {
    private static String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
27. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the field is not static
public class Foo {
    private final String TEST_CONSTANT = "Test-Constant";
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
28. This is a positive test case
```java
// #575 LiteralsFirstInComparisons must not trigger if the constant field is not a String
public class Foo {
    private final Integer TEST_CONSTANT = 5;
    public boolean test(String someString) {
        return someString.equals(TEST_CONSTANT);
    }
}
```
29. This is a negative test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static final String T = "t";

                public static int convert(String type) {
                    if (type.equals(Q)) {
                        return 1;
                    } else if (type.equals(T)) {
                        return 2;
                    } else {
                        return 3;
                    }
                }
            }
```
30. This is a positive test case
```java
// #3236 [java] LiteralsFirstInComparisons should consider constant fields (cont'd)
class DT1 {
                public static final String Q = "q";
                public static int convert2(String type) {
                    if (Q.equals(type)) {
                        return 1;
                    } else {
                        return 3;
                    }
                }
            }
```
31. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315
import net.sourceforge.pmd.PMDVersion;
public class LiteralsFirstInComparisonCase {
    private static final String S1 = "s1";
    private static final String S2 = "s2";
    public static boolean compare() {
        return S1.equals(S2);
    }
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
32. This is a positive test case
```java
// [java] LiteralsFirstInComparisons with two constants #3315 - with on demand import
import net.sourceforge.pmd.*;
public class LiteralsFirstInComparisonCase {
    private static final String S2 = "s2";
    public static boolean isUnkown() {
        return PMDVersion.VERSION.equals(S2);
    }
}
```
33. This is a positive test case
```java
// False positive with non-String constants
import java.math.BigInteger;

public class LiteralsFirstInComparisonBigInteger {
    public void foo() {
        BigInteger value = new BigInteger("1");
        if (value.equals(BigInteger.ZERO)) {
            System.out.println("1==0!!");
        }
    }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.bestpractices;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class LiteralsFirstInComparisonsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

出现语法错误，这一轮舍弃，直接重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 735.0951340198517 秒
