开始

========================================== Rule AvoidInstantiatingObjectsInLoopsRule ===========================================
一共 23 个测试用例
正例 14 个
反例 9 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: New objects can not be created within loops;

The following are the test cases of the rule:
1. This is a negative test case
```java
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
```
2. This is a negative test case
```java
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
```
3. This is a negative test case
```java
// TEST3
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
4. This is a negative test case
```java
// TEST4
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
5. This is a positive test case
```java
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
```
6. This is a positive test case
```java
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
```
7. This is a positive test case
```java
// #278 Semi-false positive for instantiating new object in loop
public class Foo {
    public void test1() {
        while (true) {
            try {
            } catch (Exception e) {
                url = new StringBuffer();
                break;
            }
        }
    }
}
```
8. This is a positive test case
```java
// #1215 AvoidInstantiatingObjectsInLoops matches the right side of a list iteration loop
import java.util.ArrayList;
import java.io.File;

public class TestInstantiationInLoop {
    public static void main(String args[]) {
        for (String test : new ArrayList<String>()) { // facetious but simple example
            System.out.println(test);
        }
        for (String filename : new File("subdirectory").list()) { // complex but realistically conceivable (albeit exagerrated/oversimplified/rarely advisable) example
            System.out.println(filename);
        }
    }
}
```
9. This is a positive test case
```java
// [java] False positive: AvoidInstantiatingObjectsInLoops should not flag objects with different parameters or objects assigned or passed as parameters #2207
import java.awt.Dimension;

public class PMDDemo {
    public static void main(final String[] args) {
        final Dimension[] arr = new Dimension[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new Dimension(i, i); // rule violation here
        }
    }
}
```
10. This is a positive test case
```java
// False positive when assigning to a list/array (see #2207 and #1043)
import java.util.Collection;
import java.util.ArrayList;

public class PMDDemo {
    public void checkArray() {
        Car[] cars = new Car[3];
        for(int i = 0; i < cars.length; ++i) {
           cars[i] = new Car();
        }
    }
    public void checkCollection() {
        Collection<Car> cars = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
           cars.add(new Car());
        }
    }

    private static class Car {}
}
```
11. This is a negative test case
```java
// False negative with break in other for-loop
import java.util.function.Function;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

public class Message {
    private List<Function<Message, Boolean>> filters;

    public Message(Message message) {}

    private SortedSet<Message> getFilteredMessages(List<Message> messages) {
        final SortedSet<Message> result = new TreeSet<>(messages);
        for (Message element : messages) {
            Message event = new Message(element);
            for (Function<Message, Boolean> filter : filters) {
                if (!filter.apply(event)) {
                    result.remove(element);
                    break;
                }
            }
        }
        return result;
    }
}
```
12. This is a negative test case
```java
// Instantiation in loop condition
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
```
13. This is a negative test case
```java
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
```
14. This is a positive test case
```java
// false positive with list
import java.util.Collection;
import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
15. This is a negative test case
```java
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
16. This is a negative test case
```java
// False negative with array allocations within loops
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}
```
17. This is a positive test case
```java
// False positive with for-each loop over new array
public class AvoidInstantiatingArrayInLoops {
    public static void main(String[] args) {
        for (String configName : new String[] {"config", "test"}) {
            System.out.println(configName);
        }
    }
}
```
18. This is a positive test case
```java
// False positive with adding to a collection/array field
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    private List<String> field = new ArrayList<>();
    private String[] arrayField = new String[10];

    public static void main(String[] args) {
        for (String arg : args) {
            this.field.add(new String(arg));
        }
        for (int i = 0; i < args.length; i++) {
            this.arrayField[i] = new String(args[i]);
        }
    }
}
```
19. This is a positive test case
```java
// False positive with adding wrapped new arrays to collection
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    public void testBytes(String s) {
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        List<ByteBuffer> buffers = new ArrayList<>();
        for (byte b : bytes) {
            buffers.add(ByteBuffer.wrap(new byte[]{b}));
        }
    }
}
```
20. This is a positive test case
```java
// False positive with temporary object assigned to an array
public class AvoidInstantiatingObjectsInLoops {
    public static void main(String[] args) {
        String[] data = new String[10];
        for (int i = 0; i < data.length; i++) {
            data[i] = new StringBuilder().append("foo").toString();
        }
    }
}
```
21. This is a positive test case
```java
// False positive with array allocation and assignment
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        int[][] arr = new int[10];
        for (int i = 0; i < 10; i++) {
            arr[i] = new int[] { i };
        }
    }
}
```
22. This is a positive test case
```java
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
```
23. This is a positive test case
```java
// False positive when converting collection to array
import java.util.ArrayList;
import java.util.List;

public class AvoidInsantiatingArraysInLoops {
    public void test() {
        List<String> data = new ArrayList<>();

        for (String arg : args) {
            this.consume(data.toArray(new String[0]));
        }
    }

    private void consume(String[] array) { }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: New objects can not be created within loops;

The following are the test cases of the rule:
1. This is a negative test case
```java
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
```
2. This is a negative test case
```java
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
```
3. This is a negative test case
```java
// TEST3
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
4. This is a negative test case
```java
// TEST4
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
5. This is a positive test case
```java
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
```
6. This is a positive test case
```java
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
```
7. This is a positive test case
```java
// #278 Semi-false positive for instantiating new object in loop
public class Foo {
    public void test1() {
        while (true) {
            try {
            } catch (Exception e) {
                url = new StringBuffer();
                break;
            }
        }
    }
}
```
8. This is a positive test case
```java
// #1215 AvoidInstantiatingObjectsInLoops matches the right side of a list iteration loop
import java.util.ArrayList;
import java.io.File;

public class TestInstantiationInLoop {
    public static void main(String args[]) {
        for (String test : new ArrayList<String>()) { // facetious but simple example
            System.out.println(test);
        }
        for (String filename : new File("subdirectory").list()) { // complex but realistically conceivable (albeit exagerrated/oversimplified/rarely advisable) example
            System.out.println(filename);
        }
    }
}
```
9. This is a positive test case
```java
// [java] False positive: AvoidInstantiatingObjectsInLoops should not flag objects with different parameters or objects assigned or passed as parameters #2207
import java.awt.Dimension;

public class PMDDemo {
    public static void main(final String[] args) {
        final Dimension[] arr = new Dimension[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new Dimension(i, i); // rule violation here
        }
    }
}
```
10. This is a positive test case
```java
// False positive when assigning to a list/array (see #2207 and #1043)
import java.util.Collection;
import java.util.ArrayList;

public class PMDDemo {
    public void checkArray() {
        Car[] cars = new Car[3];
        for(int i = 0; i < cars.length; ++i) {
           cars[i] = new Car();
        }
    }
    public void checkCollection() {
        Collection<Car> cars = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
           cars.add(new Car());
        }
    }

    private static class Car {}
}
```
11. This is a negative test case
```java
// False negative with break in other for-loop
import java.util.function.Function;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

public class Message {
    private List<Function<Message, Boolean>> filters;

    public Message(Message message) {}

    private SortedSet<Message> getFilteredMessages(List<Message> messages) {
        final SortedSet<Message> result = new TreeSet<>(messages);
        for (Message element : messages) {
            Message event = new Message(element);
            for (Function<Message, Boolean> filter : filters) {
                if (!filter.apply(event)) {
                    result.remove(element);
                    break;
                }
            }
        }
        return result;
    }
}
```
12. This is a negative test case
```java
// Instantiation in loop condition
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
```
13. This is a negative test case
```java
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
```
14. This is a positive test case
```java
// false positive with list
import java.util.Collection;
import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
15. This is a negative test case
```java
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
16. This is a negative test case
```java
// False negative with array allocations within loops
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}
```
17. This is a positive test case
```java
// False positive with for-each loop over new array
public class AvoidInstantiatingArrayInLoops {
    public static void main(String[] args) {
        for (String configName : new String[] {"config", "test"}) {
            System.out.println(configName);
        }
    }
}
```
18. This is a positive test case
```java
// False positive with adding to a collection/array field
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    private List<String> field = new ArrayList<>();
    private String[] arrayField = new String[10];

    public static void main(String[] args) {
        for (String arg : args) {
            this.field.add(new String(arg));
        }
        for (int i = 0; i < args.length; i++) {
            this.arrayField[i] = new String(args[i]);
        }
    }
}
```
19. This is a positive test case
```java
// False positive with adding wrapped new arrays to collection
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    public void testBytes(String s) {
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        List<ByteBuffer> buffers = new ArrayList<>();
        for (byte b : bytes) {
            buffers.add(ByteBuffer.wrap(new byte[]{b}));
        }
    }
}
```
20. This is a positive test case
```java
// False positive with temporary object assigned to an array
public class AvoidInstantiatingObjectsInLoops {
    public static void main(String[] args) {
        String[] data = new String[10];
        for (int i = 0; i < data.length; i++) {
            data[i] = new StringBuilder().append("foo").toString();
        }
    }
}
```
21. This is a positive test case
```java
// False positive with array allocation and assignment
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        int[][] arr = new int[10];
        for (int i = 0; i < 10; i++) {
            arr[i] = new int[] { i };
        }
    }
}
```
22. This is a positive test case
```java
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
```
23. This is a positive test case
```java
// False positive when converting collection to array
import java.util.ArrayList;
import java.util.List;

public class AvoidInsantiatingArraysInLoops {
    public void test() {
        List<String> data = new ArrayList<>();

        for (String arg : args) {
            this.consume(data.toArray(new String[0]));
        }
    }

    private void consume(String[] array) { }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {

    private static final String MSG = "New objects cannot be created within loops.";

    @Override
    public Object visit(ForStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(WhileStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(DoWhileStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(NewClass node, Object data) {
        JavaNode parent = node.getParent();
        if (parent instanceof ForStatement || parent instanceof WhileStatement || parent instanceof DoWhileStatement) {
            addViolation(data, node, MSG);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(NewArray node, Object data) {
        JavaNode parent = node.getParent();
        if (parent instanceof ForStatement || parent instanceof WhileStatement || parent instanceof DoWhileStatement) {
            addViolation(data, node, MSG);
        }
        return super.visit(node, data);
    }

    // Test for object instantiation in loop condition
    @Override
    public Object visit(NewClass node, Object data, WhileStatement loop) {
        MethodCall call = loop.getCond().getFirstChildByType(MethodCall.class);
        if (call != null && call.getImage().contains("new")) {
            addViolation(data, node, MSG);
        }
        return super.visit(node, data);
    }

    // Test for instantiation in loop condition
    @Override
    public Object visit(NewArray node, Object data, WhileStatement loop) {
        MethodCall call = loop.getCond().getFirstChildByType(MethodCall.class);
        if (call != null && call.getImage().contains("new")) {
            addViolation(data, node, MSG);
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation and assignment
    @Override
    public Object visit(ArrayAssignment node, Object data, Assign node, ForStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation and assignment
    @Override
    public Object visit(ArrayAssignment node, Object data, Assign node, WhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation and assignment
    @Override
    public Object visit(ArrayAssignment node, Object data, Assign node, DoWhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with adding wrapped new arrays to collection
    @Override
    public Object visit(NewArray node, Object data, Assign node, ForStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with adding wrapped new arrays to collection
    @Override
    public Object visit(NewArray node, Object data, Assign node, WhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with adding wrapped new arrays to collection
    @Override
    public Object visit(NewArray node, Object data, Assign node, DoWhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof Assignment) {
            Assignment assignment = (Assignment) parent;
            if (assignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with adding to a collection/array field
    @Override
    public Object visit(NewArray node, Object data, Assign node, FieldAccess fieldAccess) {
        // Ignore if the field access is not a direct assignment
        return super.visit(node, data);
    }

    // Test for false positive with adding to a collection/array field
    @Override
    public Object visit(NewClass node, Object data, Assign node, FieldAccess fieldAccess) {
        // Ignore if the field access is not a direct assignment
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(ArrayCreation node, Object data, ForStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(ArrayCreation node, Object data, WhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(ArrayCreation node, Object data, DoWhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, ForStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, WhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, DoWhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, ArrayAssignment arrayAssignment) {
        if (arrayAssignment.getOperator().getImage().equals("=")) {
            return super.visit(node, data);
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, ArrayAssignment arrayAssignment) {
        if (arrayAssignment.getOperator().getImage().equals("=")) {
            return super.visit(node, data);
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node, ForStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node, WhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node, DoWhileStatement loop) {
        JavaNode parent = node.getParent();
        if (parent instanceof ArrayAssignment) {
            ArrayAssignment arrayAssignment = (ArrayAssignment) parent;
            if (arrayAssignment.getOperator().getImage().equals("=")) {
                return super.visit(node, data);
            }
        }
        return super.visit(node, data);
    }

    // Test for false positive with array allocation and assignment
    @Override
    public Object visit(ArrayCreation node, Object data, Assign node, FieldAccess fieldAccess) {
        // Ignore if the field access is not a direct assignment
        return super.visit(node, data);
    }

    // Test for false positive with array allocation and assignment
    @Override
    public Object visit(NewArray node, Object data, Assign node, FieldAccess fieldAccess) {
        // Ignore if the field access is not a direct assignment
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(ArrayCreation node, Object data, ForStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, ForStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(ArrayCreation node, Object data, WhileStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, WhileStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(ArrayCreation node, Object data, DoWhileStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, DoWhileStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(ArrayCreation node, Object data, Assign node) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node, ForStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node, WhileStatement loop) {
        return super.visit(node, data);
    }

    // Test for false positive with array allocation within loops
    @Override
    public Object visit(NewArray node, Object data, Assign node, DoWhileStatement loop) {
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: New objects can not be created within loops;

The following are the test cases of the rule:
1. This is a negative test case
```java
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
```
2. This is a negative test case
```java
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
```
3. This is a negative test case
```java
// TEST3
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
4. This is a negative test case
```java
// TEST4
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
5. This is a positive test case
```java
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
```
6. This is a positive test case
```java
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
```
7. This is a positive test case
```java
// #278 Semi-false positive for instantiating new object in loop
public class Foo {
    public void test1() {
        while (true) {
            try {
            } catch (Exception e) {
                url = new StringBuffer();
                break;
            }
        }
    }
}
```
8. This is a positive test case
```java
// #1215 AvoidInstantiatingObjectsInLoops matches the right side of a list iteration loop
import java.util.ArrayList;
import java.io.File;

public class TestInstantiationInLoop {
    public static void main(String args[]) {
        for (String test : new ArrayList<String>()) { // facetious but simple example
            System.out.println(test);
        }
        for (String filename : new File("subdirectory").list()) { // complex but realistically conceivable (albeit exagerrated/oversimplified/rarely advisable) example
            System.out.println(filename);
        }
    }
}
```
9. This is a positive test case
```java
// [java] False positive: AvoidInstantiatingObjectsInLoops should not flag objects with different parameters or objects assigned or passed as parameters #2207
import java.awt.Dimension;

public class PMDDemo {
    public static void main(final String[] args) {
        final Dimension[] arr = new Dimension[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new Dimension(i, i); // rule violation here
        }
    }
}
```
10. This is a positive test case
```java
// False positive when assigning to a list/array (see #2207 and #1043)
import java.util.Collection;
import java.util.ArrayList;

public class PMDDemo {
    public void checkArray() {
        Car[] cars = new Car[3];
        for(int i = 0; i < cars.length; ++i) {
           cars[i] = new Car();
        }
    }
    public void checkCollection() {
        Collection<Car> cars = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
           cars.add(new Car());
        }
    }

    private static class Car {}
}
```
11. This is a negative test case
```java
// False negative with break in other for-loop
import java.util.function.Function;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

public class Message {
    private List<Function<Message, Boolean>> filters;

    public Message(Message message) {}

    private SortedSet<Message> getFilteredMessages(List<Message> messages) {
        final SortedSet<Message> result = new TreeSet<>(messages);
        for (Message element : messages) {
            Message event = new Message(element);
            for (Function<Message, Boolean> filter : filters) {
                if (!filter.apply(event)) {
                    result.remove(element);
                    break;
                }
            }
        }
        return result;
    }
}
```
12. This is a negative test case
```java
// Instantiation in loop condition
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
```
13. This is a negative test case
```java
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
```
14. This is a positive test case
```java
// false positive with list
import java.util.Collection;
import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
15. This is a negative test case
```java
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
16. This is a negative test case
```java
// False negative with array allocations within loops
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}
```
17. This is a positive test case
```java
// False positive with for-each loop over new array
public class AvoidInstantiatingArrayInLoops {
    public static void main(String[] args) {
        for (String configName : new String[] {"config", "test"}) {
            System.out.println(configName);
        }
    }
}
```
18. This is a positive test case
```java
// False positive with adding to a collection/array field
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    private List<String> field = new ArrayList<>();
    private String[] arrayField = new String[10];

    public static void main(String[] args) {
        for (String arg : args) {
            this.field.add(new String(arg));
        }
        for (int i = 0; i < args.length; i++) {
            this.arrayField[i] = new String(args[i]);
        }
    }
}
```
19. This is a positive test case
```java
// False positive with adding wrapped new arrays to collection
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    public void testBytes(String s) {
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        List<ByteBuffer> buffers = new ArrayList<>();
        for (byte b : bytes) {
            buffers.add(ByteBuffer.wrap(new byte[]{b}));
        }
    }
}
```
20. This is a positive test case
```java
// False positive with temporary object assigned to an array
public class AvoidInstantiatingObjectsInLoops {
    public static void main(String[] args) {
        String[] data = new String[10];
        for (int i = 0; i < data.length; i++) {
            data[i] = new StringBuilder().append("foo").toString();
        }
    }
}
```
21. This is a positive test case
```java
// False positive with array allocation and assignment
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        int[][] arr = new int[10];
        for (int i = 0; i < 10; i++) {
            arr[i] = new int[] { i };
        }
    }
}
```
22. This is a positive test case
```java
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
```
23. This is a positive test case
```java
// False positive when converting collection to array
import java.util.ArrayList;
import java.util.List;

public class AvoidInsantiatingArraysInLoops {
    public void test() {
        List<String> data = new ArrayList<>();

        for (String arg : args) {
            this.consume(data.toArray(new String[0]));
        }
    }

    private void consume(String[] array) { }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(JavaNode.METHOD_DECLARATION, JavaNode.BLOCK, JavaNode.FOR_STATEMENT, JavaNode.WHILE_STATEMENT, JavaNode.DO_STATEMENT);
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(Block node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ForStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(WhileStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(DoStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(Statement node, Object data) {
        if (node.isOfTypes(JavaNode.EXPRESSION_STATEMENT)) {
            ASTExpressionStatement statement = (ASTExpressionStatement) node;
            ASTExpression expression = statement.getExpression();
            if (expression.isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION)) {
                ASTAssignmentExpression assignment = (ASTAssignmentExpression) expression;
                ASTExpression lhs = assignment.getLeftHandSide();
                ASTExpression rhs = assignment.getRightHandSide();
                if (rhs.isOfTypes(JavaNode.THROW_STATEMENT)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.RETURN_STATEMENT)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.CONTINUE_STATEMENT) || rhs.isOfTypes(JavaNode.BREAK_STATEMENT)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION)) {
                    ASTNewArrayExpression newArray = (ASTNewArrayExpression) rhs;
                    if (rhs.getParent().isOfTypes(JavaNode.FOR_STATEMENT) || rhs.getParent().isOfTypes(JavaNode.WHILE_STATEMENT) || rhs.getParent().isOfTypes(JavaNode.DO_STATEMENT)) {
                        addViolation(data, node);
                    }
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                    ASTNewClassExpression newClass = (ASTNewClassExpression) rhs;
                    if (rhs.getParent().isOfTypes(JavaNode.FOR_STATEMENT) || rhs.getParent().isOfTypes(JavaNode.WHILE_STATEMENT) || rhs.getParent().isOfTypes(JavaNode.DO_STATEMENT)) {
                        addViolation(data, node);
                    }
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.METHOD_INVOCATION)) {
                    return super.visit(node, data);
                }
                if (lhs.isOfTypes(JavaNode.ARRAY_ACCESS)) {
                    return super.visit(node, data);
                }
                if (lhs.isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION)) {
                    if (lhs.getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || lhs.getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                        return super.visit(node, data);
                    }
                }
                if (rhs.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) && rhs.getOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) && rhs.getOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) && rhs.getOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) && rhs.getOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.CHAR_LITERAL) || rhs.isOfTypes(JavaNode.STRING_LITERAL) || rhs.isOfTypes(JavaNode.BOOLEAN_LITERAL) || rhs.isOfTypes(JavaNode.INTEGER_LITERAL) || rhs.isOfTypes(JavaNode.FLOAT_LITERAL) || rhs.isOfTypes(JavaNode.LONG_LITERAL) || rhs.isOfTypes(JavaNode.DOUBLE_LITERAL)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.NULL_LITERAL)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.THIS_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.ARRAY_INITIALIZER)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.ASSIGNMENT_OPERATOR)) {
                    ASTAssignmentOperator operator = (ASTAssignmentOperator) rhs;
                    if (operator.isOfTypes(JavaNode.ASSIGNMENT_OPERATOR)) {
                        return super.visit(node, data);
                    }
                }
                if (rhs.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) || rhs.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) || rhs.isOfTypes(JavaNode.CAST_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.BINARY_EXPRESSION_LEFT)) {
                    ASTBinaryExpression binary = (ASTBinaryExpression) rhs;
                    if (binary.getLeftOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || binary.getLeftOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || binary.getRightOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || binary.getRightOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                        return super.visit(node, data);
                    }
                }
                if (rhs.isOfTypes(JavaNode.TERNARY_EXPRESSION)) {
                    ASTConditionalExpression ternary = (ASTConditionalExpression) rhs;
                    if (ternary.getCondition().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getCondition().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || ternary.getThenExpression().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getThenExpression().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || ternary.getElseExpression().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getElseExpression().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                        return super.visit(node, data);
                    }
                }
                if (rhs.isOfTypes(JavaNode.CHAR_LITERAL) || rhs.isOfTypes(JavaNode.STRING_LITERAL) || rhs.isOfTypes(JavaNode.BOOLEAN_LITERAL) || rhs.isOfTypes(JavaNode.INTEGER_LITERAL) || rhs.isOfTypes(JavaNode.FLOAT_LITERAL) || rhs.isOfTypes(JavaNode.LONG_LITERAL) || rhs.isOfTypes(JavaNode.DOUBLE_LITERAL)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.NULL_LITERAL)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.THIS_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.ARRAY_INITIALIZER)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.ASSIGNMENT_OPERATOR)) {
                    ASTAssignmentOperator operator = (ASTAssignmentOperator) rhs;
                    if (operator.isOfTypes(JavaNode.ASSIGNMENT_OPERATOR)) {
                        return super.visit(node, data);
                    }
                }
                if (rhs.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) || rhs.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) || rhs.isOfTypes(JavaNode.CAST_EXPRESSION)) {
                    return super.visit(node, data);
                }
                if (rhs.isOfTypes(JavaNode.BINARY_EXPRESSION_LEFT)) {
                    ASTBinaryExpression binary = (ASTBinaryExpression) rhs;
                    if (binary.getLeftOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || binary.getLeftOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || binary.getRightOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || binary.getRightOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                        return super.visit(node, data);
                    }
                }
                if (rhs.isOfTypes(JavaNode.TERNARY_EXPRESSION)) {
                    ASTConditionalExpression ternary = (ASTConditionalExpression) rhs;
                    if (ternary.getCondition().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getCondition().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || ternary.getThenExpression().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getThenExpression().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || ternary.getElseExpression().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getElseExpression().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                        return super.visit(node, data);
                    }
                }
                if (rhs.isOfTypes(JavaNode.ARRAY_ACCESS) || rhs.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) || rhs.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) || rhs.isOfTypes(JavaNode.CAST_EXPRESSION)) {
                    return super.visit(node, data);
                }
            }
            if (expression.isOfTypes(JavaNode.THROW_STATEMENT)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.RETURN_STATEMENT)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.CONTINUE_STATEMENT) || expression.isOfTypes(JavaNode.BREAK_STATEMENT)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION)) {
                ASTNewArrayExpression newArray = (ASTNewArrayExpression) expression;
                if (expression.getParent().isOfTypes(JavaNode.FOR_STATEMENT) || expression.getParent().isOfTypes(JavaNode.WHILE_STATEMENT) || expression.getParent().isOfTypes(JavaNode.DO_STATEMENT)) {
                    addViolation(data, node);
                }
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                ASTNewClassExpression newClass = (ASTNewClassExpression) expression;
                if (expression.getParent().isOfTypes(JavaNode.FOR_STATEMENT) || expression.getParent().isOfTypes(JavaNode.WHILE_STATEMENT) || expression.getParent().isOfTypes(JavaNode.DO_STATEMENT)) {
                    addViolation(data, node);
                }
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.METHOD_INVOCATION)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.ARRAY_ACCESS)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION)) {
                if (expression.getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || expression.getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                    return super.visit(node, data);
                }
            }
            if (expression.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) && expression.getOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) && expression.getOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) && expression.getOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) && expression.getOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.CHAR_LITERAL) || expression.isOfTypes(JavaNode.STRING_LITERAL) || expression.isOfTypes(JavaNode.BOOLEAN_LITERAL) || expression.isOfTypes(JavaNode.INTEGER_LITERAL) || expression.isOfTypes(JavaNode.FLOAT_LITERAL) || expression.isOfTypes(JavaNode.LONG_LITERAL) || expression.isOfTypes(JavaNode.DOUBLE_LITERAL)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.NULL_LITERAL)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.THIS_EXPRESSION)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.ARRAY_INITIALIZER)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.ASSIGNMENT_OPERATOR)) {
                ASTAssignmentOperator operator = (ASTAssignmentOperator) expression;
                if (operator.isOfTypes(JavaNode.ASSIGNMENT_OPERATOR)) {
                    return super.visit(node, data);
                }
            }
            if (expression.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) || expression.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) || expression.isOfTypes(JavaNode.CAST_EXPRESSION)) {
                return super.visit(node, data);
            }
            if (expression.isOfTypes(JavaNode.BINARY_EXPRESSION_LEFT)) {
                ASTBinaryExpression binary = (ASTBinaryExpression) expression;
                if (binary.getLeftOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || binary.getLeftOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || binary.getRightOperand().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || binary.getRightOperand().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                    return super.visit(node, data);
                }
            }
            if (expression.isOfTypes(JavaNode.TERNARY_EXPRESSION)) {
                ASTConditionalExpression ternary = (ASTConditionalExpression) expression;
                if (ternary.getCondition().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getCondition().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || ternary.getThenExpression().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getThenExpression().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION) || ternary.getElseExpression().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ternary.getElseExpression().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                    return super.visit(node, data);
                }
            }
            if (expression.isOfTypes(JavaNode.ARRAY_ACCESS) || expression.isOfTypes(JavaNode.PREFIX_UNARY_EXPRESSION) || expression.isOfTypes(JavaNode.POSTFIX_UNARY_EXPRESSION) || expression.isOfTypes(JavaNode.CAST_EXPRESSION)) {
                return super.visit(node, data);
            }
        }
        if (node.isOfTypes(JavaNode.FOR_STATEMENT)) {
            ASTForStatement forStatement = (ASTForStatement) node;
            if (forStatement.getInitializer().isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION) && forStatement.getInitializer().getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || forStatement.getInitializer().getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                addViolation(data, node);
            }
            if (forStatement.getUpdate().isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION) && forStatement.getUpdate().getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || forStatement.getUpdate().getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                addViolation(data, node);
            }
            if (forStatement.getBody().isOfTypes(JavaNode.BLOCK) && forStatement.getBody().getChildren().stream().anyMatch(c -> c.isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION) && ((ASTAssignmentExpression) c).getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ((ASTAssignmentExpression) c).getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION))) {
                addViolation(data, node);
            }
            return super.visit(node, data);
        }
        if (node.isOfTypes(JavaNode.WHILE_STATEMENT)) {
            ASTWhileStatement whileStatement = (ASTWhileStatement) node;
            if (whileStatement.getTest().isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION) && whileStatement.getTest().getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || whileStatement.getTest().getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                addViolation(data, node);
            }
            if (whileStatement.getBody().isOfTypes(JavaNode.BLOCK) && whileStatement.getBody().getChildren().stream().anyMatch(c -> c.isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION) && ((ASTAssignmentExpression) c).getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ((ASTAssignmentExpression) c).getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION))) {
                addViolation(data, node);
            }
            return super.visit(node, data);
        }
        if (node.isOfTypes(JavaNode.DO_STATEMENT)) {
            ASTDoStatement doStatement = (ASTDoStatement) node;
            if (doStatement.getTest().isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION) && doStatement.getTest().getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || doStatement.getTest().getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION)) {
                addViolation(data, node);
            }
            if (doStatement.getBody().isOfTypes(JavaNode.BLOCK) && doStatement.getBody().getChildren().stream().anyMatch(c -> c.isOfTypes(JavaNode.ASSIGNMENT_EXPRESSION) && ((ASTAssignmentExpression) c).getRightHandSide().isOfTypes(JavaNode.NEW_ARRAY_EXPRESSION) || ((ASTAssignmentExpression) c).getRightHandSide().isOfTypes(JavaNode.NEW_CLASS_EXPRESSION))) {
                addViolation(data, node);
            }
            return super.visit(node, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(CatchStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ReturnStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ContinueStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(BreakStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ThrowStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(TryStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(LabeledStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(EmptyStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(EmptyForStatement node, Object data) {
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: New objects can not be created within loops;

The following are the test cases of the rule:
1. This is a negative test case
```java
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
```
2. This is a negative test case
```java
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
```
3. This is a negative test case
```java
// TEST3
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
4. This is a negative test case
```java
// TEST4
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
5. This is a positive test case
```java
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
```
6. This is a positive test case
```java
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
```
7. This is a positive test case
```java
// #278 Semi-false positive for instantiating new object in loop
public class Foo {
    public void test1() {
        while (true) {
            try {
            } catch (Exception e) {
                url = new StringBuffer();
                break;
            }
        }
    }
}
```
8. This is a positive test case
```java
// #1215 AvoidInstantiatingObjectsInLoops matches the right side of a list iteration loop
import java.util.ArrayList;
import java.io.File;

public class TestInstantiationInLoop {
    public static void main(String args[]) {
        for (String test : new ArrayList<String>()) { // facetious but simple example
            System.out.println(test);
        }
        for (String filename : new File("subdirectory").list()) { // complex but realistically conceivable (albeit exagerrated/oversimplified/rarely advisable) example
            System.out.println(filename);
        }
    }
}
```
9. This is a positive test case
```java
// [java] False positive: AvoidInstantiatingObjectsInLoops should not flag objects with different parameters or objects assigned or passed as parameters #2207
import java.awt.Dimension;

public class PMDDemo {
    public static void main(final String[] args) {
        final Dimension[] arr = new Dimension[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new Dimension(i, i); // rule violation here
        }
    }
}
```
10. This is a positive test case
```java
// False positive when assigning to a list/array (see #2207 and #1043)
import java.util.Collection;
import java.util.ArrayList;

public class PMDDemo {
    public void checkArray() {
        Car[] cars = new Car[3];
        for(int i = 0; i < cars.length; ++i) {
           cars[i] = new Car();
        }
    }
    public void checkCollection() {
        Collection<Car> cars = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
           cars.add(new Car());
        }
    }

    private static class Car {}
}
```
11. This is a negative test case
```java
// False negative with break in other for-loop
import java.util.function.Function;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

public class Message {
    private List<Function<Message, Boolean>> filters;

    public Message(Message message) {}

    private SortedSet<Message> getFilteredMessages(List<Message> messages) {
        final SortedSet<Message> result = new TreeSet<>(messages);
        for (Message element : messages) {
            Message event = new Message(element);
            for (Function<Message, Boolean> filter : filters) {
                if (!filter.apply(event)) {
                    result.remove(element);
                    break;
                }
            }
        }
        return result;
    }
}
```
12. This is a negative test case
```java
// Instantiation in loop condition
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
```
13. This is a negative test case
```java
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
```
14. This is a positive test case
```java
// false positive with list
import java.util.Collection;
import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
15. This is a negative test case
```java
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
16. This is a negative test case
```java
// False negative with array allocations within loops
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}
```
17. This is a positive test case
```java
// False positive with for-each loop over new array
public class AvoidInstantiatingArrayInLoops {
    public static void main(String[] args) {
        for (String configName : new String[] {"config", "test"}) {
            System.out.println(configName);
        }
    }
}
```
18. This is a positive test case
```java
// False positive with adding to a collection/array field
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    private List<String> field = new ArrayList<>();
    private String[] arrayField = new String[10];

    public static void main(String[] args) {
        for (String arg : args) {
            this.field.add(new String(arg));
        }
        for (int i = 0; i < args.length; i++) {
            this.arrayField[i] = new String(args[i]);
        }
    }
}
```
19. This is a positive test case
```java
// False positive with adding wrapped new arrays to collection
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    public void testBytes(String s) {
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        List<ByteBuffer> buffers = new ArrayList<>();
        for (byte b : bytes) {
            buffers.add(ByteBuffer.wrap(new byte[]{b}));
        }
    }
}
```
20. This is a positive test case
```java
// False positive with temporary object assigned to an array
public class AvoidInstantiatingObjectsInLoops {
    public static void main(String[] args) {
        String[] data = new String[10];
        for (int i = 0; i < data.length; i++) {
            data[i] = new StringBuilder().append("foo").toString();
        }
    }
}
```
21. This is a positive test case
```java
// False positive with array allocation and assignment
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        int[][] arr = new int[10];
        for (int i = 0; i < 10; i++) {
            arr[i] = new int[] { i };
        }
    }
}
```
22. This is a positive test case
```java
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
```
23. This is a positive test case
```java
// False positive when converting collection to array
import java.util.ArrayList;
import java.util.List;

public class AvoidInsantiatingArraysInLoops {
    public void test() {
        List<String> data = new ArrayList<>();

        for (String arg : args) {
            this.consume(data.toArray(new String[0]));
        }
    }

    private void consume(String[] array) { }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(ForStatement.class, WhileStatement.class, DoStatement.class);
    }

    @Override
    public Object visit(ForStatement node, Object data) {
        if (node.getInit() != null) {
            initNode(node.getInit(), data);
        }
        List<Statement> body = node.getBody();
        if (body != null) {
            for (Statement statement : body) {
                if (statement instanceof ExpressionStatement) {
                    Expression expression = ((ExpressionStatement) statement).getExpression();
                    if (expression instanceof NewClassExpression) {
                        addViolation(data, node, "New objects cannot be created within loops");
                    }
                } else if (statement instanceof Block) {
                    ((Block) statement).accept(this, data);
                } else {
                    statement.accept(this, data);
                }
            }
        }
        if (node.getUpdate() != null) {
            updateNode(node.getUpdate(), data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(WhileStatement node, Object data) {
        Expression expression = node.getExpression();
        if (expression instanceof NewClassExpression) {
            addViolation(data, node, "New objects cannot be created within loops");
        }
        if (node.getBody() != null) {
            ((Block) node.getBody()).accept(this, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(DoStatement node, Object data) {
        Expression expression = node.getExpression();
        if (expression instanceof NewClassExpression) {
            addViolation(data, node, "New objects cannot be created within loops");
        }
        if (node.getBody() != null) {
            ((Block) node.getBody()).accept(this, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(Block node, Object data) {
        for (Statement statement : node.getStatements()) {
            statement.accept(this, data);
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(ExpressionStatement node, Object data) {
        Expression expression = node.getExpression();
        if (expression instanceof NewClassExpression) {
            addViolation(data, node, "New objects cannot be created within loops");
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(NewClassExpression node, Object data) {
        if (isInLoop(node.getParent())) {
            addViolation(data, node, "New objects cannot be created within loops");
        }
        return super.visit(node, data);
    }

    private boolean isInLoop(JavaNode node) {
        if (node instanceof ForStatement) {
            return true;
        }
        if (node instanceof WhileStatement) {
            return true;
        }
        if (node instanceof DoStatement) {
            return true;
        }
        return false;
    }

    private void addViolation(Object data, JavaNode node, String message) {
        Violation violation = new Violation(getRuleName(), node.getImage(), message);
        addViolation(data, violation);
    }

    private void initNode(Statement node, Object data) {
        if (node instanceof NewClassExpression) {
            addViolation(data, node, "New objects cannot be created within loops");
        }
    }

    private void updateNode(Statement node, Object data) {
        if (node instanceof NewClassExpression) {
            addViolation(data, node, "New objects cannot be created within loops");
        }
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: New objects can not be created within loops;

The following are the test cases of the rule:
1. This is a negative test case
```java
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
```
2. This is a negative test case
```java
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
```
3. This is a negative test case
```java
// TEST3
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
4. This is a negative test case
```java
// TEST4
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
5. This is a positive test case
```java
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
```
6. This is a positive test case
```java
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
```
7. This is a positive test case
```java
// #278 Semi-false positive for instantiating new object in loop
public class Foo {
    public void test1() {
        while (true) {
            try {
            } catch (Exception e) {
                url = new StringBuffer();
                break;
            }
        }
    }
}
```
8. This is a positive test case
```java
// #1215 AvoidInstantiatingObjectsInLoops matches the right side of a list iteration loop
import java.util.ArrayList;
import java.io.File;

public class TestInstantiationInLoop {
    public static void main(String args[]) {
        for (String test : new ArrayList<String>()) { // facetious but simple example
            System.out.println(test);
        }
        for (String filename : new File("subdirectory").list()) { // complex but realistically conceivable (albeit exagerrated/oversimplified/rarely advisable) example
            System.out.println(filename);
        }
    }
}
```
9. This is a positive test case
```java
// [java] False positive: AvoidInstantiatingObjectsInLoops should not flag objects with different parameters or objects assigned or passed as parameters #2207
import java.awt.Dimension;

public class PMDDemo {
    public static void main(final String[] args) {
        final Dimension[] arr = new Dimension[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new Dimension(i, i); // rule violation here
        }
    }
}
```
10. This is a positive test case
```java
// False positive when assigning to a list/array (see #2207 and #1043)
import java.util.Collection;
import java.util.ArrayList;

public class PMDDemo {
    public void checkArray() {
        Car[] cars = new Car[3];
        for(int i = 0; i < cars.length; ++i) {
           cars[i] = new Car();
        }
    }
    public void checkCollection() {
        Collection<Car> cars = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
           cars.add(new Car());
        }
    }

    private static class Car {}
}
```
11. This is a negative test case
```java
// False negative with break in other for-loop
import java.util.function.Function;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

public class Message {
    private List<Function<Message, Boolean>> filters;

    public Message(Message message) {}

    private SortedSet<Message> getFilteredMessages(List<Message> messages) {
        final SortedSet<Message> result = new TreeSet<>(messages);
        for (Message element : messages) {
            Message event = new Message(element);
            for (Function<Message, Boolean> filter : filters) {
                if (!filter.apply(event)) {
                    result.remove(element);
                    break;
                }
            }
        }
        return result;
    }
}
```
12. This is a negative test case
```java
// Instantiation in loop condition
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
```
13. This is a negative test case
```java
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
```
14. This is a positive test case
```java
// false positive with list
import java.util.Collection;
import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
15. This is a negative test case
```java
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
16. This is a negative test case
```java
// False negative with array allocations within loops
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}
```
17. This is a positive test case
```java
// False positive with for-each loop over new array
public class AvoidInstantiatingArrayInLoops {
    public static void main(String[] args) {
        for (String configName : new String[] {"config", "test"}) {
            System.out.println(configName);
        }
    }
}
```
18. This is a positive test case
```java
// False positive with adding to a collection/array field
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    private List<String> field = new ArrayList<>();
    private String[] arrayField = new String[10];

    public static void main(String[] args) {
        for (String arg : args) {
            this.field.add(new String(arg));
        }
        for (int i = 0; i < args.length; i++) {
            this.arrayField[i] = new String(args[i]);
        }
    }
}
```
19. This is a positive test case
```java
// False positive with adding wrapped new arrays to collection
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    public void testBytes(String s) {
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        List<ByteBuffer> buffers = new ArrayList<>();
        for (byte b : bytes) {
            buffers.add(ByteBuffer.wrap(new byte[]{b}));
        }
    }
}
```
20. This is a positive test case
```java
// False positive with temporary object assigned to an array
public class AvoidInstantiatingObjectsInLoops {
    public static void main(String[] args) {
        String[] data = new String[10];
        for (int i = 0; i < data.length; i++) {
            data[i] = new StringBuilder().append("foo").toString();
        }
    }
}
```
21. This is a positive test case
```java
// False positive with array allocation and assignment
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        int[][] arr = new int[10];
        for (int i = 0; i < 10; i++) {
            arr[i] = new int[] { i };
        }
    }
}
```
22. This is a positive test case
```java
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
```
23. This is a positive test case
```java
// False positive when converting collection to array
import java.util.ArrayList;
import java.util.List;

public class AvoidInsantiatingArraysInLoops {
    public void test() {
        List<String> data = new ArrayList<>();

        for (String arg : args) {
            this.consume(data.toArray(new String[0]));
        }
    }

    private void consume(String[] array) { }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public void apply(List<RuleViolation> violations) {
        NodeStream ns = getRootNode().findDescendantsOfType(ForStatement.class);
        for (ForStatement node : ns) {
            if (node.getBody() != null) {
                for (Statement stat : node.getBody().getStatements()) {
                    if (stat instanceof ExpressionStatement) {
                        Expression expr = ((ExpressionStatement) stat).getExpression();
                        if (expr instanceof NewClassExpression) {
                            NewClassExpression newExpr = (NewClassExpression) expr;
                            if (isLoop()) {
                                violations.add(new RuleViolation(node.getBeginLine(), node.getBeginColumn(), this.getClass().getSimpleName(), "Avoid instantiate objects in loops"));
                            }
                        }
                    }
                }
            }
        }
    }

    private boolean isLoop() {
        NodeStream ns = getRootNode().findDescendantsOfType(ForStatement.class, WhileStatement.class, DoWhileStatement.class);
        for (Statement node : ns) {
            if (node == getRootNode()) {
                return true;
            }
        }
        return false;
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(ClassOrInterfaceDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(ForStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(WhileStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(DoWhileStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(ThrowStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(ReturnStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(BreakStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(ContinueStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(SwitchStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(SynchronizedStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(IfStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(WhileParanthesis node, Object data) {
        return null;
    }

    @Override
    public Object visit(LabeledStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(EmptyStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnhancedForStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(ForeachStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(SwitchExpressionStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(LambdaExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(MarkerAnnotation node, Object data) {
        return null;
    }

    @Override
    public Object visit(SingleMemberAnnotation node, Object data) {
        return null;
    }

    @Override
    public Object visit(MultilineAnnotation node, Object data) {
        return null;
    }

    @Override
    public Object visit(SimpleType node, Object data) {
        return null;
    }

    @Override
    public Object visit(ArrayType node, Object data) {
        return null;
    }

    @Override
    public Object visit(ParameterizedType node, Object data) {
        return null;
    }

    @Override
    public Object visit(PrimitiveType node, Object data) {
        return null;
    }

    @Override
    public Object visit(ClassOrInterfaceType node, Object data) {
        return null;
    }

    @Override
    public Object visit(VariableDeclarator node, Object data) {
        return null;
    }

    @Override
    public Object visit(VariableDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(VariableDeclaratorId node, Object data) {
        return null;
    }

    @Override
    public Object visit(ArrayDeclarator node, Object data) {
        return null;
    }

    @Override
    public Object visit(MethodInvocation node, Object data) {
        return null;
    }

    @Override
    public Object visit(ClassLiteral node, Object data) {
        return null;
    }

    @Override
    public Object visit(ThisExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(InstanceOfExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(PostfixExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(UnaryExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(PrefixExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(CastExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(BinaryExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(LiteralExpression node, Object data) {
        return null;
    }

    @Override
    public Object visit(CaseLabel node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumConstant node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumConstantName node, Object data) {
        return null;
    }

    @Override
    public Object visit(CompilationUnitDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(ImportDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(EmptyCompilationUnit node, Object data) {
        return null;
    }

    @Override
    public Object visit(AnonymousClassDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(AnonymousClassBody node, Object data) {
        return null;
    }

    @Override
    public Object visit(ThisConstructorInvocation node, Object data) {
        return null;
    }

    @Override
    public Object visit(SuperConstructorInvocation node, Object data) {
        return null;
    }

    @Override
    public Object visit(MethodInvocation node, Object data) {
        return null;
    }

    @Override
    public Object visit(ClassOrInterfaceDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumConstant node, Object data) {
        return null;
    }

    @Override
    public Object visit(EmptyStatement node, Object data) {
        return null;
    }

    @Override
    public Object visit(EmptyCompilationUnit node, Object data) {
        return null;
    }

    @Override
    public Object visit(TypeDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumConstant node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumConstantName node, Object data) {
        return null;
    }

    @Override
    public Object visit(EnumDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(TypeDeclaration node, Object data) {
        return null;
    }

    @Override
    public Object visit(NewClassExpression node, Object data) {
        return null;
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: New objects can not be created within loops;

The following are the test cases of the rule:
1. This is a negative test case
```java
// TEST1
public class Foo {
    public void test1() {
        for(;;) {
            String a = new String();
        }
    }
}
```
2. This is a negative test case
```java
// TEST2
public class Foo {
    public void test1() {
        while(true) {
            String a = new String();
        }
    }
}
```
3. This is a negative test case
```java
// TEST3
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
4. This is a negative test case
```java
// TEST4
public class Foo {
    public void test1() {
        do {
            String a = new String();
        } while(true);
    }
}
```
5. This is a positive test case
```java
// throw new is OK
public class Foo {
    public void test1() {
        for(;;) {
            throw new Exception();
        }
    }
}
```
6. This is a positive test case
```java
// return new in loop is OK
public class Foo {
    public String test1() {
        for(;;) {
            return new String();
        }
    }
}
```
7. This is a positive test case
```java
// #278 Semi-false positive for instantiating new object in loop
public class Foo {
    public void test1() {
        while (true) {
            try {
            } catch (Exception e) {
                url = new StringBuffer();
                break;
            }
        }
    }
}
```
8. This is a positive test case
```java
// #1215 AvoidInstantiatingObjectsInLoops matches the right side of a list iteration loop
import java.util.ArrayList;
import java.io.File;

public class TestInstantiationInLoop {
    public static void main(String args[]) {
        for (String test : new ArrayList<String>()) { // facetious but simple example
            System.out.println(test);
        }
        for (String filename : new File("subdirectory").list()) { // complex but realistically conceivable (albeit exagerrated/oversimplified/rarely advisable) example
            System.out.println(filename);
        }
    }
}
```
9. This is a positive test case
```java
// [java] False positive: AvoidInstantiatingObjectsInLoops should not flag objects with different parameters or objects assigned or passed as parameters #2207
import java.awt.Dimension;

public class PMDDemo {
    public static void main(final String[] args) {
        final Dimension[] arr = new Dimension[10];
        for (int i = 0; i < arr.length; i++) {
            arr[i] = new Dimension(i, i); // rule violation here
        }
    }
}
```
10. This is a positive test case
```java
// False positive when assigning to a list/array (see #2207 and #1043)
import java.util.Collection;
import java.util.ArrayList;

public class PMDDemo {
    public void checkArray() {
        Car[] cars = new Car[3];
        for(int i = 0; i < cars.length; ++i) {
           cars[i] = new Car();
        }
    }
    public void checkCollection() {
        Collection<Car> cars = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
           cars.add(new Car());
        }
    }

    private static class Car {}
}
```
11. This is a negative test case
```java
// False negative with break in other for-loop
import java.util.function.Function;
import java.util.List;
import java.util.SortedSet;
import java.util.TreeSet;

public class Message {
    private List<Function<Message, Boolean>> filters;

    public Message(Message message) {}

    private SortedSet<Message> getFilteredMessages(List<Message> messages) {
        final SortedSet<Message> result = new TreeSet<>(messages);
        for (Message element : messages) {
            Message event = new Message(element);
            for (Function<Message, Boolean> filter : filters) {
                if (!filter.apply(event)) {
                    result.remove(element);
                    break;
                }
            }
        }
        return result;
    }
}
```
12. This is a negative test case
```java
// Instantiation in loop condition
public class Foo {
    public void test1() {
        while(new String().length() > 0) {
        }
    }
}
```
13. This is a negative test case
```java
// false negative in anonymous classes
public class Sample {
    private static class Inner {
        private void baz() {
            for(;;) {
                String a = new String();
            }
        }
    }

    public void foo() {
        Sample anonymousClass = new Sample() {
            void bar() {
                for(;;) {
                    String a = new String();
                }
            }
        };
    }
}
```
14. This is a positive test case
```java
// false positive with list
import java.util.Collection;
import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
15. This is a negative test case
```java
// Collections with unresolved type
// Types are unresolved
//import java.util.Collection;
//import java.util.ArrayList;

public class Sample {
    public Collection<Car> checkCollection() {
        Collection<Car> thisIsACar = new ArrayList<>();
        for(int i = 0; i < 3; ++i) {
            thisIsACar.add(new Car());
        }
        return thisIsACar;
    }

    private static class Car {
    }
}
```
16. This is a negative test case
```java
// False negative with array allocations within loops
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        for (String arg : args) {
            String[] copy = new String[] { arg };
        }
    }
}
```
17. This is a positive test case
```java
// False positive with for-each loop over new array
public class AvoidInstantiatingArrayInLoops {
    public static void main(String[] args) {
        for (String configName : new String[] {"config", "test"}) {
            System.out.println(configName);
        }
    }
}
```
18. This is a positive test case
```java
// False positive with adding to a collection/array field
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    private List<String> field = new ArrayList<>();
    private String[] arrayField = new String[10];

    public static void main(String[] args) {
        for (String arg : args) {
            this.field.add(new String(arg));
        }
        for (int i = 0; i < args.length; i++) {
            this.arrayField[i] = new String(args[i]);
        }
    }
}
```
19. This is a positive test case
```java
// False positive with adding wrapped new arrays to collection
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

public class AvoidInstantiatingObjectsInLoops {
    public void testBytes(String s) {
        byte[] bytes = s.getBytes(StandardCharsets.UTF_8);
        List<ByteBuffer> buffers = new ArrayList<>();
        for (byte b : bytes) {
            buffers.add(ByteBuffer.wrap(new byte[]{b}));
        }
    }
}
```
20. This is a positive test case
```java
// False positive with temporary object assigned to an array
public class AvoidInstantiatingObjectsInLoops {
    public static void main(String[] args) {
        String[] data = new String[10];
        for (int i = 0; i < data.length; i++) {
            data[i] = new StringBuilder().append("foo").toString();
        }
    }
}
```
21. This is a positive test case
```java
// False positive with array allocation and assignment
public class AvoidInstantiatingArraysInLoops {
    public static void main(String[] args) {
        int[][] arr = new int[10];
        for (int i = 0; i < 10; i++) {
            arr[i] = new int[] { i };
        }
    }
}
```
22. This is a positive test case
```java
// False positive when array is returned
public class AvoidInstantiatingArraysInLoops {
    public int[] test() {
        for (int i = 0; i < 10; i++) {
            return new int[] { i };
        }

        for (int i = 0; i < 10; i++) {
            int[] a = new int[] { i };
            break;
        }
    }
}
```
23. This is a positive test case
```java
// False positive when converting collection to array
import java.util.ArrayList;
import java.util.List;

public class AvoidInsantiatingArraysInLoops {
    public void test() {
        List<String> data = new ArrayList<>();

        for (String arg : args) {
            this.consume(data.toArray(new String[0]));
        }
    }

    private void consume(String[] array) { }
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.performance;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.performance;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidInstantiatingObjectsInLoopsRule extends AbstractJavaRulechainRule {
    public AvoidInstantiatingObjectsInLoopsRule() {
        super(Method.class, ForStatement.class, WhileStatement.class, DoStatement.class);
    }

    @Override
    public Object visit(Method node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ForStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(WhileStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(DoStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(PrimitiveType node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ClassOrInterfaceDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(NewArrayExpression node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(NewClassExpression node, Object data) {
        if (node.getExpression() != null && node.getExpression().getImage().startsWith("new")) {
            return super.visit(node, data);
        }
        for (JavaNode child : node.jjtGetChildren()) {
            if (child instanceof MethodInvocation) {
                MethodInvocation methodInvocation = (MethodInvocation) child;
                if (methodInvocation.getName().getImage().equals("newInstance")) {
                    return super.visit(node, data);
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(Identifier node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ReturnStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ThrowStatement node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ConstructorDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(VariableDeclarator node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ClassOrInterfaceBody node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(VariableDeclaratorId node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(ForControl node, Object data) {
        if (node.getExpression() != null && node.getExpression() instanceof NewArrayExpression) {
            return super.visit(node, data);
        } else if (node.getExpression() != null && node.getExpression() instanceof NewClassExpression) {
            if (node.getExpression() instanceof NewClassExpression) {
                NewClassExpression newClassExpression = (NewClassExpression) node.getExpression();
                if (newClassExpression.getExpression() != null && newClassExpression.getExpression().getImage().startsWith("new")) {
                    return super.visit(node, data);
                }
                for (JavaNode child : newClassExpression.jjtGetChildren()) {
                    if (child instanceof MethodInvocation) {
                        MethodInvocation methodInvocation = (MethodInvocation) child;
                        if (methodInvocation.getName().getImage().equals("newInstance")) {
                            return super.visit(node, data);
                        }
                    }
                }
            }
            return super.visit(node, data);
        } else if (node.getExpression() != null && node.getExpression() instanceof Assignment) {
            Assignment assignment = (Assignment) node.getExpression();
            if (assignment.getOperator() == AssignmentOperator.ASSIGN) {
                if (assignment.getExpression() instanceof NewArrayExpression) {
                    return super.visit(node, data);
                } else if (assignment.getExpression() instanceof NewClassExpression) {
                    if (assignment.getExpression() instanceof NewClassExpression) {
                        NewClassExpression newClassExpression = (NewClassExpression) assignment.getExpression();
                        if (newClassExpression.getExpression() != null && newClassExpression.getExpression().getImage().startsWith("new")) {
                            return super.visit(node, data);
                        }
                        for (JavaNode child : newClassExpression.jjtGetChildren()) {
                            if (child instanceof MethodInvocation) {
                                MethodInvocation methodInvocation = (MethodInvocation) child;
                                if (methodInvocation.getName().getImage().equals("newInstance")) {
                                    return super.visit(node, data);
                                }
                            }
                        }
                    }
                    return super.visit(node, data);
                }
            }
            return super.visit(node, data);
        } else {
            for (JavaNode child : node.jjtGetChildren()) {
                if (child instanceof NewArrayExpression) {
                    return super.visit(node, data);
                } else if (child instanceof NewClassExpression) {
                    if (child instanceof NewClassExpression) {
                        NewClassExpression newClassExpression = (NewClassExpression) child;
                        if (newClassExpression.getExpression() != null && newClassExpression.getExpression().getImage().startsWith("new")) {
                            return super.visit(node, data);
                        }
                        for (JavaNode grandChild : newClassExpression.jjtGetChildren()) {
                            if (grandChild instanceof MethodInvocation) {
                                MethodInvocation methodInvocation = (MethodInvocation) grandChild;
                                if (methodInvocation.getName().getImage().equals("newInstance")) {
                                    return super.visit(node, data);
                                }
                            }
                        }
                    }
                    return super.visit(node, data);
                } else if (child instanceof MethodInvocation) {
                    MethodInvocation methodInvocation = (MethodInvocation) child;
                    if (methodInvocation.getName().getImage().equals("newInstance")) {
                        return super.visit(node, data);
                    }
                } else if (child instanceof Assignment) {
                    Assignment assignment = (Assignment) child;
                    if (assignment.getOperator() == AssignmentOperator.ASSIGN) {
                        if (assignment.getExpression() instanceof NewArrayExpression) {
                            return super.visit(node, data);
                        } else if (assignment.getExpression() instanceof NewClassExpression) {
                            if (assignment.getExpression() instanceof NewClassExpression) {
                                NewClassExpression newClassExpression = (NewClassExpression) assignment.getExpression();
                                if (newClassExpression.getExpression() != null && newClassExpression.getExpression().getImage().startsWith("new")) {
                                    return super.visit(node, data);
                                }
                                for (JavaNode grandChild : newClassExpression.jjtGetChildren()) {
                                    if (grandChild instanceof MethodInvocation) {
                                        MethodInvocation methodInvocation = (MethodInvocation) grandChild;
                                        if (methodInvocation.getName().getImage().equals("newInstance")) {
                                            return super.visit(node, data);
                                        }
                                    }
                                }
                            }
                            return super.visit(node, data);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(PrimaryPrefix node, Object data) {
        if (node instanceof NewArrayExpression) {
            return super.visit(node, data);
        } else if (node instanceof NewClassExpression) {
            if (node instanceof NewClassExpression) {
                NewClassExpression newClassExpression = (NewClassExpression) node;
                if (newClassExpression.getExpression() != null && newClassExpression.getExpression().getImage().startsWith("new")) {
                    return super.visit(node, data);
                }
                for (JavaNode child : newClassExpression.jjtGetChildren()) {
                    if (child instanceof MethodInvocation) {
                        MethodInvocation methodInvocation = (MethodInvocation) child;
                        if (methodInvocation.getName().getImage().equals("newInstance")) {
                            return super.visit(node, data);
                        }
                    }
                }
            }
            return super.visit(node, data);
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 269.81153297424316 秒
