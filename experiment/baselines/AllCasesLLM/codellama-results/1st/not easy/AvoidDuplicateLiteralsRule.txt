开始

========================================== Rule AvoidDuplicateLiteralsRule ===========================================
一共 11 个测试用例
正例 3 个
反例 8 个
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========================第1轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public AvoidDuplicateLiteralsRule() {
        super(LiteralExpression.class, NewArrayCreation.class, AnnotationMemberValue.class);
    }

    @Override
    public Object visit(LiteralExpression node, Object data) {
        if (node.getImage().length() < 3) return super.visit(node, data);
        Set<String> literals = new LinkedHashSet<>();
        boolean seenDuplicate = false;
        for (Object sibling : node.findChildrenOfType(LiteralExpression.class)) {
            String literal = sibling.getImage();
            if (literal.length() < 3) continue;
            if (literals.contains(literal)) {
                seenDuplicate = true;
                break;
            }
            literals.add(literal);
            if (literals.size() >= 4) break;
        }
        if (seenDuplicate) {
            addRuleViolation(node, "Duplicate string literals");
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(NewArrayCreation node, Object data) {
        if (node.getType().isPrimitiveType() || node.getType().isArrayType()) return super.visit(node, data);
        List<String> literals = new ArrayList<>();
        boolean seenDuplicate = false;
        for (Object element : node.getChildrenOfType(LiteralExpression.class)) {
            String literal = ((LiteralExpression) element).getImage();
            if (literal.length() < 3) continue;
            if (literals.contains(literal)) {
                seenDuplicate = true;
                break;
            }
            literals.add(literal);
            if (literals.size() >= 4) break;
        }
        if (seenDuplicate) {
            addRuleViolation(node, "Duplicate string literals");
        }
        return super.visit(node, data);
    }

    @Override
    public Object visit(AnnotationMemberValue node, Object data) {
        if (!node.getType().isStringType()) return super.visit(node, data);
        Set<String> literals = new LinkedHashSet<>();
        boolean seenDuplicate = false;
        for (Object sibling : node.findChildrenOfType(LiteralExpression.class)) {
            String literal = sibling.getImage();
            if (literal.length() < 3) continue;
            if (literals.contains(literal)) {
                seenDuplicate = true;
                break;
            }
            literals.add(literal);
            if (literals.size() >= 4) break;
        }
        if (seenDuplicate) {
            addRuleViolation(node, "Duplicate string literals");
        }
        return super.visit(node, data);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第2轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private static final int DUPLICATE_LITERAL_THRESHOLD = 4;
    private static final int MIN_LITERAL_LENGTH = 3;

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        int literalCount = 0;
        Set<String> literals = new HashSet<>();

        for (Expression arg : node.getParameters().getParameters()) {
            if (arg instanceof StringLiteral) {
                String value = ((StringLiteral) arg).getImage();

                if (value.length() < MIN_LITERAL_LENGTH) {
                    continue;
                }

                if (literals.contains(value)) {
                    literalCount++;
                } else {
                    literals.add(value);
                }
            }
        }

        if (literalCount >= DUPLICATE_LITERAL_THRESHOLD) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    @Override
    public Object visit(AnnotationExpr node, Object data) {
        int literalCount = 0;
        Set<String> literals = new HashSet<>();

        for (Expression expr : node.getMemberValuePairs().getMemberValuePairs()) {
            if (expr instanceof StringLiteral) {
                String value = ((StringLiteral) expr).getImage();

                if (value.length() < MIN_LITERAL_LENGTH) {
                    continue;
                }

                if (literals.contains(value)) {
                    literalCount++;
                } else {
                    literals.add(value);
                }
            }
        }

        if (literalCount >= DUPLICATE_LITERAL_THRESHOLD) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    @Override
    public Object visit(FieldDeclaration node, Object data) {
        int literalCount = 0;
        Set<String> literals = new HashSet<>();

        for (VariableDeclaratorId id : node.getVariables()) {
            if (id.getExpression() instanceof StringLiteral) {
                String value = ((StringLiteral) id.getExpression()).getImage();

                if (value.length() < MIN_LITERAL_LENGTH) {
                    continue;
                }

                if (literals.contains(value)) {
                    literalCount++;
                } else {
                    literals.add(value);
                }
            }
        }

        if (literalCount >= DUPLICATE_LITERAL_THRESHOLD) {
            addViolation(data, node);
        }

        return super.visit(node, data);
    }

    @Override
    public Object visit(StringLiteral node, Object data) {
        if (node.getImage().length() < MIN_LITERAL_LENGTH) {
            return super.visit(node, data);
        }

        return addViolation(data, node);
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第3轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private int threshold = 4;
    private int minLength = 3;

    public AvoidDuplicateLiteralsRule() {
        setRuleName("Avoid duplicate literals");
        setRuleDescription("Code containing duplicate String literals can usually be improved by declaring the String as a constant field.");
        setLanguage(net.sourceforge.pmd.lang.java.JavaLanguage);
    }

    @Override
    public Object visit(MethodDeclaration node, Object data) {
        return super.visit(node, data);
    }

    @Override
    public Object visit(Expression node, Object data) {
        if (node instanceof StringLiteral) {
            String value = ((StringLiteral) node).getImage();
            if (value.length() >= minLength) {
                Collection<StringLiteral> duplicateLiterals = new ArrayList<>();
                collectDuplicateLiterals(node, duplicateLiterals);
                if (duplicateLiterals.size() >= threshold) {
                    addViolation(data, node);
                }
            }
        } else if (node instanceof ArrayAccess) {
            Expression array = ((ArrayAccess) node).getArray();
            if (array instanceof StringLiteral) {
                String value = ((StringLiteral) array).getImage();
                if (value.length() >= minLength) {
                    Collection<StringLiteral> duplicateLiterals = new ArrayList<>();
                    collectDuplicateLiterals(node, duplicateLiterals);
                    if (duplicateLiterals.size() >= threshold) {
                        addViolation(data, node);
                    }
                }
            }
        } else if (node instanceof Annotation) {
            NodeList<Expression> annotations = ((Annotation) node).getExpressions();
            for (Expression annotation : annotations) {
                if (annotation instanceof StringLiteral) {
                    String value = ((StringLiteral) annotation).getImage();
                    if (value.length() >= minLength) {
                        Collection<StringLiteral> duplicateLiterals = new ArrayList<>();
                        collectDuplicateLiterals(node, duplicateLiterals);
                        if (duplicateLiterals.size() >= threshold) {
                            addViolation(data, node);
                        }
                    }
                }
            }
        }
        return super.visit(node, data);
    }

    private void collectDuplicateLiterals(Node node, Collection<StringLiteral> duplicateLiterals) {
        if (node instanceof Expression && ((Expression) node).getImage() != null) {
            String value = ((Expression) node).getImage();
            if (value.length() >= minLength) {
                duplicateLiterals.add((StringLiteral) node);
            }
        }
        for (JavaNode child : node.jjtGetChildren()) {
            collectDuplicateLiterals(child, duplicateLiterals);
        }
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第4轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

==========5轮中每一轮为第一个测试用例生成的checker===============
package net.sourceforge.pmd.lang.java.rule.errorprone;

import java.util.*;
import java.lang.*;

import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast. *;
import net.sourceforge.pmd.lang.java.ast.internal. *;
import net.sourceforge.pmd.lang.java.types. *;
import net.sourceforge.pmd.lang.java.symbols. *;
import net.sourceforge.pmd.lang.ast.NodeStream;
public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {

    private static final int DUPLICATE_LITERALS_THRESHOLD = 4;
    private static final int MIN_LITERAL_LENGTH = 3;

    public AvoidDuplicateLiteralsRule() {
        super(ASTClassOrInterfaceBody.class, ASTBlock.class);
    }

    @Override
    public Object visit(ClassOrInterfaceBody node, Object data) {
        Map<String, Integer> literals = new HashMap<>();
        int literalCount = 0;

        visit(node.getStatements(), literals);

        for (Map.Entry<String, Integer> entry : literals.entrySet()) {
            if (entry.getValue() >= DUPLICATE_LITERALS_THRESHOLD && entry.getKey().length() < MIN_LITERAL_LENGTH) {
                addViolation(data, node);
            }
        }

        return super.visit(node, data);
    }

    private void visit(List<Statement> statements, Map<String, Integer> literals) {
        for (Statement statement : statements) {
            if (statement instanceof ExpressionStatement) {
                Expression expression = ((ExpressionStatement) statement).getExpression();
                if (expression instanceof PrimaryExpression) {
                    PrimaryExpression primaryExpression = (PrimaryExpression) expression;
                    if (primaryExpression instanceof LiteralExpression) {
                        LiteralExpression literalExpression = (LiteralExpression) primaryExpression;
                        if (literalExpression instanceof StringLiteral) {
                            StringLiteral stringLiteral = (StringLiteral) literalExpression;
                            String string = stringLiteral.getStringLiteral();
                            literals.put(string, literals.getOrDefault(string, 0) + 1);
                        }
                    }
                }
            } else if (statement instanceof MethodCallExpression) {
                MethodCallExpression methodCallExpression = (MethodCallExpression) statement;
                if (methodCallExpression.getOperator() instanceof Identifier) {
                    Identifier identifier = (Identifier) methodCallExpression.getOperator();
                    String methodName = identifier.getImage();
                    if (methodName.equals("getResources")) {
                        ArgumentList argumentList = methodCallExpression.getArgumentList();
                        if (argumentList != null) {
                            List<Expression> arguments = argumentList.getArguments();
                            for (Expression argument : arguments) {
                                if (argument instanceof PrimaryExpression) {
                                    PrimaryExpression primaryExpression = (PrimaryExpression) argument;
                                    if (primaryExpression instanceof LiteralExpression) {
                                        LiteralExpression literalExpression = (LiteralExpression) primaryExpression;
                                        if (literalExpression instanceof StringLiteral) {
                                            StringLiteral stringLiteral = (StringLiteral) literalExpression;
                                            String string = stringLiteral.getStringLiteral();
                                            literals.put(string, literals.getOrDefault(string, 0) + 1);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (statement instanceof NewArrayExpression) {
                NewArrayExpression newArrayExpression = (NewArrayExpression) statement;
                if (newArrayExpression.getExpression() instanceof StringLiteral) {
                    StringLiteral stringLiteral = (StringLiteral) newArrayExpression.getExpression();
                    String string = stringLiteral.getStringLiteral();
                    literals.put(string, literals.getOrDefault(string, 0) + 1);
                }
            } else if (statement instanceof ArrayAccessExpression) {
                ArrayAccessExpression arrayAccessExpression = (ArrayAccessExpression) statement;
                if (arrayAccessExpression.getExpression() instanceof StringLiteral) {
                    StringLiteral stringLiteral = (StringLiteral) arrayAccessExpression.getExpression();
                    String string = stringLiteral.getStringLiteral();
                    literals.put(string, literals.getOrDefault(string, 0) + 1);
                }
            } else if (statement instanceof FieldDeclaration) {
                FieldDeclaration fieldDeclaration = (FieldDeclaration) statement;
                if (fieldDeclaration.getType() instanceof ArrayType) {
                    ArrayType arrayType = (ArrayType) fieldDeclaration.getType();
                    if (arrayType.getComponentType() instanceof StringType) {
                        StringType stringType = (StringType) arrayType.getComponentType();
                        fieldDeclaration.getInitializer().accept(new SymbolTableVisitor() {
                            public void visit(ArrayInitializer arrayInitializer) {
                                for (Expression expression : arrayInitializer.getExpressions()) {
                                    if (expression instanceof StringLiteral) {
                                        StringLiteral stringLiteral = (StringLiteral) expression;
                                        String string = stringLiteral.getStringLiteral();
                                        literals.put(string, literals.getOrDefault(string, 0) + 1);
                                    }
                                }
                            }
                        });
                    }
                }
            } else if (statement instanceof MethodDeclaration) {
                MethodDeclaration methodDeclaration = (MethodDeclaration) statement;
                if (methodDeclaration.getType() instanceof StringType) {
                    StringType stringType = (StringType) methodDeclaration.getType();
                    methodDeclaration.getParameters().forEach(parameter -> {
                        if (parameter.getType() instanceof StringType) {
                            StringType stringType1 = (StringType) parameter.getType();
                            parameter.getInitializer().accept(new SymbolTableVisitor() {
                                public void visit(StringLiteral stringLiteral) {
                                    String string = stringLiteral.getStringLiteral();
                                    literals.put(string, literals.getOrDefault(string, 0) + 1);
                                }
                            });
                        }
                    });
                }
            } else if (statement instanceof Annotation) {
                Annotation annotation = (Annotation) statement;
                if (annotation.getMembers().size() > DUPLICATE_LITERALS_THRESHOLD) {
                    for (AnnotationMember annotationMember : annotation.getMembers()) {
                        if (annotationMember instanceof StringLiteral) {
                            StringLiteral stringLiteral = (StringLiteral) annotationMember;
                            String string = stringLiteral.getStringLiteral();
                            literals.put(string, literals.getOrDefault(string, 0) + 1);
                        }
                    }
                }
            } else if (statement instanceof PackageDeclaration) {
                PackageDeclaration packageDeclaration = (PackageDeclaration) statement;
                packageDeclaration.getImports().forEach(importDecl -> {
                    if (importDecl.getImportType() instanceof StringType) {
                        StringType stringType = (StringType) importDecl.getImportType();
                        importDecl.getImportName().accept(new SymbolTableVisitor() {
                            public void visit(StringLiteral stringLiteral) {
                                String string = stringLiteral.getStringLiteral();
                                literals.put(string, literals.getOrDefault(string, 0) + 1);
                            }
                        });
                    }
                });
            }
            visit(statement.getBody().getStatements(), literals);
        }
    }

    private class SymbolTableVisitor extends RecursiveASTVisitor {

        @Override
        public boolean visit(Identifier node) {
            return false;
        }

        @Override
        public boolean visit(StringLiteral node) {
            String string = node.getStringLiteral();
            literals.put(string, literals.getOrDefault(string, 0) + 1);
            return false;
        }
    }
}
第一个测试用例生成的checker开始编译
一开始编译是否通过：
False
编译错误不在预期范围内，重新生成
==========================第5轮生成checker========================
开始写checker
==========================The_first_checker_query=========================
You are an expert in writing java rule checkers and I need your help to generate a custom java rule checker in PMD tool version 7.0.0. 
I will give you a rule description and its several test cases.

The following is the description of the rule:
Rule description: Code containing duplicate String literals can usually be improved by declaring the String as a constant field. The duplicate string literals number threshold is 4. Strings with length less than 3 are ignored.;

The following are the test cases of the rule:
1. This is a negative test case
```java
// duplicate literals in argument list
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
2. This is a positive test case
```java
// literal int argument, ok for now
public class Foo {
    private void bar() {
        buz(2);
    }
    private void buz(int x) {}
}
```
3. This is a negative test case
```java
// duplicate literals in field decl
public class Foo {
    String[] FOO = {"foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo", "foo"};
}
```
4. This is a negative test case
```java
// duplicate literals in annotations, default case
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
@SuppressWarnings("foo")
public class Foo {
}
```
5. This is a positive test case
```java
public class Foo {
    private void bar() {
        buz("Howdy");
        buz("Howdy");
    }
    private void buz(String x) {}
}
```
6. This is a negative test case
```java
// exception list property
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
    }
    private void buz(String x) {}
}
```
7. This is a positive test case
```java
// exception list with escape
public class Foo {
    private void bar() {
        buz("Howdy,foo");
        buz("Howdy,foo");
    }
    private void buz(String x) {}
}
```
8. This is a negative test case
```java
public class Foo {
    private void bar() {
        buz("Howdy"); buz("Howdy"); buz("Howdy"); buz("Howdy");
    }
    private void buz(String x) {}
}
```
9. This is a negative test case
```java
// minimum length property, default value
public class Foo {
    private void bar() {
        buz("foo"); buz("foo"); buz("foo"); buz("foo");
        buz("fo"); buz("fo"); buz("fo"); buz("fo");
    }
    private void buz(String x) {}
}
```
10. This is a negative test case
```java
// #1425 Invalid XML Characters in Output
public class Duplicate {
    String s1 = "Tokenizer \ud801\udc1ctest";
    String s2 = "Tokenizer \ud801\udc1ctest";
    String s3 = "Tokenizer \ud801\udc1ctest";
    String s4 = "Tokenizer \ud801\udc1ctest";
    char c = '\uffef';
    char c\u0030 = 'a';
}
```
11. This is a negative test case
```java
// Duplicated string literals as annotation parameter
public class AnnotationParams {
    public static void foo(@SuppressWarnings("unused") Object str,
                           @SuppressWarnings("unused") String str2,
                           @SuppressWarnings("unused") String str3,
                           @SuppressWarnings("unused") String str4) {}
}
```


The checker code framework(you must conform to):
```java
package net.sourceforge.pmd.lang.java.rule.errorprone;
import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;
import net.sourceforge.pmd.lang.java.ast.*;
import net.sourceforge.pmd.lang.java.ast.internal.*;
import net.sourceforge.pmd.lang.java.types.*;
import net.sourceforge.pmd.lang.java.symbols.*;
import net.sourceforge.pmd.lang.java.ast.JavaNode;
import net.sourceforge.pmd.lang.ast.NodeStream;
import java.util.*;
import java.lang.*;

public class AvoidDuplicateLiteralsRule extends AbstractJavaRulechainRule {
    public rule_name() {
        super(node1_Of_AST_to_visit.class, node2_Of_AST_to_visit.class, ...);
    }
    @Override
    public Object visit(node1_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    @Override
    public Object visit(node2_Of_AST_to_visit node, Object data) {
        return super.visit(node, data);
    }
    ...
}
```
Some useful packages are already imported, if you need other packages, please import additionally.
Please give me the complete checker code including the import info, do not contain pseudocode, and do not give it step by step. No comment needed.

出现语法错误，这一轮舍弃，直接重新生成
5轮生成失败
结束

规则执行完毕，时间总花销： 740.7602603435516 秒
